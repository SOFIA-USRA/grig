<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>grig package &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <script src="../_static/documentation_options.js?v=9559a862"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="grig.grid package" href="grig.grid.html" />
    <link rel="prev" title="The Spline class" href="../grig/toolkit/splines/spline_examples.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="grig.grid.html" title="grig.grid package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../grig/toolkit/splines/spline_examples.html" title="The Spline class"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../grig/index.html" accesskey="U">Grig Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="grig-package">
<h1>grig package<a class="headerlink" href="#grig-package" title="Link to this heading">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="grig.grid.html">grig.grid package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="grig.grid.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="grig.grid.html#module-grig.grid.base_grid">grig.grid.base_grid module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.grid.html#grig.grid.base_grid.BaseGrid"><code class="docutils literal notranslate"><span class="pre">BaseGrid</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grig.grid.html#module-grig.grid.kernel_grid">grig.grid.kernel_grid module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.grid.html#grig.grid.kernel_grid.KernelGrid"><code class="docutils literal notranslate"><span class="pre">KernelGrid</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grig.grid.html#module-grig.grid.polynomial_grid">grig.grid.polynomial_grid module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.grid.html#grig.grid.polynomial_grid.PolynomialGrid"><code class="docutils literal notranslate"><span class="pre">PolynomialGrid</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grig.toolkit.html">grig.toolkit package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="grig.toolkit.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="grig.toolkit.splines.html">grig.toolkit.splines package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.splines.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="grig.toolkit.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="grig.toolkit.html#module-grig.toolkit.func">grig.toolkit.func module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.byte_size_of_object"><code class="docutils literal notranslate"><span class="pre">byte_size_of_object()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.julia_fractal"><code class="docutils literal notranslate"><span class="pre">julia_fractal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.moments"><code class="docutils literal notranslate"><span class="pre">moments()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.robust_mask"><code class="docutils literal notranslate"><span class="pre">robust_mask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.slicer"><code class="docutils literal notranslate"><span class="pre">slicer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.func.taylor"><code class="docutils literal notranslate"><span class="pre">taylor()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grig.toolkit.html#module-grig.toolkit.multiproc">grig.toolkit.multiproc module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.MultitaskHandler"><code class="docutils literal notranslate"><span class="pre">MultitaskHandler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.get_core_number"><code class="docutils literal notranslate"><span class="pre">get_core_number()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.in_main_thread"><code class="docutils literal notranslate"><span class="pre">in_main_thread()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.log_for_multitask"><code class="docutils literal notranslate"><span class="pre">log_for_multitask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.log_records_to_pickle_file"><code class="docutils literal notranslate"><span class="pre">log_records_to_pickle_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.log_with_multi_handler"><code class="docutils literal notranslate"><span class="pre">log_with_multi_handler()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.multitask"><code class="docutils literal notranslate"><span class="pre">multitask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.pickle_list"><code class="docutils literal notranslate"><span class="pre">pickle_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.pickle_object"><code class="docutils literal notranslate"><span class="pre">pickle_object()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.purge_multitask_logs"><code class="docutils literal notranslate"><span class="pre">purge_multitask_logs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.relative_cores"><code class="docutils literal notranslate"><span class="pre">relative_cores()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.unpickle_file"><code class="docutils literal notranslate"><span class="pre">unpickle_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.unpickle_list"><code class="docutils literal notranslate"><span class="pre">unpickle_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.valid_relative_jobs"><code class="docutils literal notranslate"><span class="pre">valid_relative_jobs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.wrap_function"><code class="docutils literal notranslate"><span class="pre">wrap_function()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="grig.toolkit.html#grig.toolkit.multiproc.wrapped_with_logger"><code class="docutils literal notranslate"><span class="pre">wrapped_with_logger()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grig.tree.html">grig.tree package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="grig.tree.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="grig.tree.html#module-grig.tree.base_tree">grig.tree.base_tree module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.tree.html#grig.tree.base_tree.BaseTree"><code class="docutils literal notranslate"><span class="pre">BaseTree</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grig.tree.html#module-grig.tree.kernel_tree">grig.tree.kernel_tree module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.tree.html#grig.tree.kernel_tree.KernelTree"><code class="docutils literal notranslate"><span class="pre">KernelTree</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grig.tree.html#module-grig.tree.polynomial_tree">grig.tree.polynomial_tree module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="grig.tree.html#grig.tree.polynomial_tree.PolynomialTree"><code class="docutils literal notranslate"><span class="pre">PolynomialTree</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
<section id="module-grig.clean_image">
<span id="grig-clean-image-module"></span><h3>grig.clean_image module<a class="headerlink" href="#module-grig.clean_image" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="grig.clean_image.clean_image">
<span class="sig-prename descclassname"><span class="pre">grig.clean_image.</span></span><span class="sig-name descname"><span class="pre">clean_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/clean_image.html#clean_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.clean_image.clean_image" title="Link to this definition">¶</a></dt>
<dd><p>Uses <cite>ResamplePolynomial</cite> to correct NaNs in image and/or supplied in mask.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array_like of float</span></dt><dd><p>(M, N) array of data values.  NaN values will automatically be
considered ‘bad’ and replaced.</p>
</dd>
<dt><strong>error</strong><span class="classifier">array_like of float, optional</span></dt><dd><p>(M, N) array of error (1-sigma) values
associated with the <cite>data</cite> array.  <cite>error</cite> will be used to
weight fits and also be propagated to the output error values.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array_like of bool, optional</span></dt><dd><p>(M, N) array of bool where True indicates a valid data point
that can be included the fitting and False indicates data points
that should be excluded from the fit and replaced.
Masked points will be reflected in the output counts array.</p>
</dd>
<dt><strong>window</strong><span class="classifier">array_like or float or int, optional</span></dt><dd><p>(2,) array or single float value specifying the maximum
euclidean distance of a data sample from a resampling point such
that it can be included in a local fit.  <cite>window</cite> may be declared
for each feature.  For example, when fitting 2-dimensional (x, y)
data, a window of 1.0 would create a circular fitting window
around each resampling point, whereas a window of (1.0, 0.5)
would create an eliptical fitting window with a semi-major axis
of 1.0 in x and semi-minor axis of 0.5 in y.  If not supplied,
<cite>window</cite> is calculated based on an estimate of the median
population density of the data for each feature.</p>
</dd>
<dt><strong>order</strong><span class="classifier">array_like or int, optional</span></dt><dd><p>(2,) array or single integer value specifying the
polynomial fit order for each feature.</p>
</dd>
<dt><strong>fix_order</strong><span class="classifier">bool, optional</span></dt><dd><p>In order for local polynomial fitting to occur, the default
requirement is that nsamples &gt;= (order + 1) ** 2,
where nsamples is the number of data samples within <cite>window</cite>.
If <cite>fix_order</cite> is True and this condition is not met, then
local fitting will be aborted for that point and a value of
<cite>cval</cite> will be returned instead.  If <cite>fix_order</cite> is False,
then <cite>order</cite> will be reduced to the maximum value where this
condition can be met.  NOTE: this is only available if
<cite>order</cite> is symmetrical. i.e. it was passed in as a single
integer to be applied across both x and y.  Otherwise, it is
unclear as to which dimension order should be reduced to meet
the condition.</p>
</dd>
<dt><strong>robust</strong><span class="classifier">float, optional</span></dt><dd><p>Specifies an outlier rejection threshold for <cite>data</cite>.
A data point is identified as an outlier if:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">x_med</span><span class="o">|/</span><span class="n">MAD</span> <span class="o">&gt;</span> <span class="n">robust</span><span class="p">,</span>
</pre></div>
</div>
<p>where x_med is the median,
and MAD is the Median Absolute Deviation defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.482</span> <span class="o">*</span> <span class="n">median</span><span class="p">(</span><span class="o">|</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">x_med</span><span class="o">|</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</dd>
<dt><strong>negthresh</strong><span class="classifier">float, optional</span></dt><dd><p>Specifies a negative value rejection threshold such that
data &lt; (-stddev(data) * negthresh) will be excluded from
the fit.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The type of check to perform on whether the sample distribution
for each resampling point is adequate to derive a polynomial fit.
Depending on <cite>order</cite> and <cite>fix_order</cite>, if the distribution does
not meet the criteria for <cite>mode</cite>, either the fit will be aborted,
returning a value of <cite>cval</cite> or the fit order will be reduced.
Available modes are:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘edges’: Require that there are <cite>order</cite> samples in both
the negative and positive directions of each feature
from the resampling point.</p></li>
<li><p>‘counts’: Require that there are (order + 1) ** 2
samples within the <cite>window</cite> of each resampling point.</p></li>
<li><p>‘extrapolate’: Attempt to fit regardless of the sample
distribution.</p></li>
</ul>
</div></blockquote>
<p>Note that ‘edges’ is the most robust mode as it ensures
that no singular values will be encountered during the
least-squares fitting of polynomial coefficients.</p>
</dd>
<dt><strong>leaf_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points at which to switch to brute-force during the
ball tree query algorithm.  See <cite>sklearn.neighbours.BallTree</cite>
for further details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cleaned_image, [variance_out], [counts]</strong><span class="classifier">n_tuple of numpy.ndarray (M, N)</span></dt><dd><p>See <cite>grig.ResamplePolynomial</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-grig.resample">
<span id="grig-resample-module"></span><h3>grig.resample module<a class="headerlink" href="#module-grig.resample" title="Link to this heading">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="grig.resample.Resample">
<span class="sig-prename descclassname"><span class="pre">grig.resample.</span></span><span class="sig-name descname"><span class="pre">Resample</span></span><a class="headerlink" href="#grig.resample.Resample" title="Link to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial" title="grig.resample_polynomial.ResamplePolynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResamplePolynomial</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample.resampler">
<span class="sig-prename descclassname"><span class="pre">grig.resample.</span></span><span class="sig-name descname"><span class="pre">resampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distribution'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bounded'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grig.resample.resampler" title="Link to this definition">¶</a></dt>
<dd><p>ResamplePolynomial data using local polynomial fitting.</p>
<p>Initializes and then calls the <code class="xref py py-class docutils literal notranslate"><span class="pre">ResamplePolynomial</span></code> class.  For
further details on all available parameters, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__init__()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong></dt><dd></dd>
<dt><strong>data</strong></dt><dd></dd>
<dt><strong>locations</strong></dt><dd></dd>
<dt><strong>error</strong></dt><dd></dd>
<dt><strong>mask</strong></dt><dd></dd>
<dt><strong>window</strong></dt><dd></dd>
<dt><strong>order</strong></dt><dd></dd>
<dt><strong>fix_order</strong></dt><dd></dd>
<dt><strong>robust</strong></dt><dd></dd>
<dt><strong>negthresh</strong></dt><dd></dd>
<dt><strong>window_estimate_bins</strong></dt><dd></dd>
<dt><strong>window_estimate_percentile</strong></dt><dd></dd>
<dt><strong>window_estimate_oversample</strong></dt><dd></dd>
<dt><strong>leaf_size</strong></dt><dd></dd>
<dt><strong>large_data</strong></dt><dd></dd>
<dt><strong>smoothing</strong></dt><dd></dd>
<dt><strong>relative_smooth</strong></dt><dd></dd>
<dt><strong>adaptive_threshold</strong></dt><dd></dd>
<dt><strong>adaptive_algorithm</strong></dt><dd></dd>
<dt><strong>fit_threshold</strong></dt><dd></dd>
<dt><strong>cval</strong></dt><dd></dd>
<dt><strong>edge_threshold</strong></dt><dd></dd>
<dt><strong>edge_algorithm</strong></dt><dd></dd>
<dt><strong>order_algorithm</strong></dt><dd></dd>
<dt><strong>error_weighting</strong></dt><dd></dd>
<dt><strong>estimate_covariance</strong></dt><dd></dd>
<dt><strong>is_covar</strong></dt><dd></dd>
<dt><strong>jobs</strong></dt><dd></dd>
<dt><strong>get_error</strong></dt><dd></dd>
<dt><strong>get_counts</strong></dt><dd></dd>
<dt><strong>get_weights</strong></dt><dd></dd>
<dt><strong>get_distance_weights</strong></dt><dd></dd>
<dt><strong>get_rchi2</strong></dt><dd></dd>
<dt><strong>get_cross_derivatives</strong></dt><dd></dd>
<dt><strong>get_offset_variance</strong></dt><dd></dd>
<dt><strong>distance_kwargs</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier">float or numpy.ndarray or n-tuple of (float or numpy.ndarray)</span></dt><dd><p>If a fit is performed at a single location, the output will consist
of int or float scalar values.  Multiple fits result in numpy arrays.
The exact output shape depends on the number of data sets, number of
fitted points, dimensions of the fit locations.  Assuming that all
get_* keywords are set to <cite>True</cite>, the output order is:</p>
<blockquote>
<div><p>results[0] = fitted values
results[1] = error on the fit
results[2] = sample counts for each fit
results[3] = total weight of all samples in fit
results[4] = total distance weight sum of all samples in fit
results[5] = reduced chi-squared statistic of the fit
results[6] = derivative mean squared cross products
results[7] = offset variance of fit from sample distribution</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-grig.resample_base">
<span id="grig-resample-base-module"></span><h3>grig.resample_base module<a class="headerlink" href="#module-grig.resample_base" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">grig.resample_base.</span></span><span class="sig-name descname"><span class="pre">ResampleBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.features" title="grig.resample_base.ResampleBase.features"><code class="xref py py-obj docutils literal notranslate"><span class="pre">features</span></code></a></dt><dd><p>int : number of data features (dimensions)</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.fit_settings" title="grig.resample_base.ResampleBase.fit_settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_settings</span></code></a></dt><dd><p>dict : Fit reduction settings applied during last call</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.fit_tree" title="grig.resample_base.ResampleBase.fit_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_tree</span></code></a></dt><dd><p>Return the fitting tree representative of points to fit.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.grid_class" title="grig.resample_base.ResampleBase.grid_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_class</span></code></a></dt><dd><p>Return the grid class of the resampler</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.multi_set" title="grig.resample_base.ResampleBase.multi_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_set</span></code></a></dt><dd><p>bool : True if solving for multiple data sets</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.n_samples" title="grig.resample_base.ResampleBase.n_samples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_samples</span></code></a></dt><dd><p>int : The number of samples in each data set.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.n_sets" title="grig.resample_base.ResampleBase.n_sets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_sets</span></code></a></dt><dd><p>int : The number of data sets to fit.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_base.ResampleBase.window" title="grig.resample_base.ResampleBase.window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window</span></code></a></dt><dd><p>numpy.ndarray (n_features,) : Window radius in each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*args[, fit_threshold, cval, ...])</p></td>
<td><p>Resample data defined during initialization onto new coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.block_loop" title="grig.resample_base.ResampleBase.block_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_loop</span></code></a>(sample_values, error, mask, ...)</p></td>
<td><p>Perform resampling reduction in parallel or series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.calculate_minimum_points" title="grig.resample_base.ResampleBase.calculate_minimum_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_minimum_points</span></code></a>()</p></td>
<td><p>Return the minimum number of points for a fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.combine_blocks" title="grig.resample_base.ResampleBase.combine_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_blocks</span></code></a>(blocks, n_sets, n_fits, ...)</p></td>
<td><p>Combines the results from multiple reductions into one set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.estimate_feature_windows" title="grig.resample_base.ResampleBase.estimate_feature_windows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_feature_windows</span></code></a>(coordinates[, ...])</p></td>
<td><p>Estimates the radius of the fitting window for each feature.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.estimate_max_bytes" title="grig.resample_base.ResampleBase.estimate_max_bytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_max_bytes</span></code></a>(coordinates[, window, ...])</p></td>
<td><p>Estimate the maximum number of bytes required by a reduction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.get_grid_class" title="grig.resample_base.ResampleBase.get_grid_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grid_class</span></code></a>()</p></td>
<td><p>Return the appropriate grid class for the resampler.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.global_resampling_values" title="grig.resample_base.ResampleBase.global_resampling_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_resampling_values</span></code></a>()</p></td>
<td><p>Return the global resampling values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.pre_fit" title="grig.resample_base.ResampleBase.pre_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_fit</span></code></a>(settings, *args)</p></td>
<td><p>Perform pre-fitting steps and build the fitting tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.process_block" title="grig.resample_base.ResampleBase.process_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_block</span></code></a>(args, block)</p></td>
<td><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.process_blocks" title="grig.resample_base.ResampleBase.process_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_blocks</span></code></a>(args, kwargs, settings, ...)</p></td>
<td><p>Wrapper for handling block resampling in a multiprocessing environment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.reduction_settings" title="grig.resample_base.ResampleBase.reduction_settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduction_settings</span></code></a>([error_weighting, ...])</p></td>
<td><p>Define a set of reduction instructions based on user input.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.set_sample_tree" title="grig.resample_base.ResampleBase.set_sample_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sample_tree</span></code></a>(coordinates[, radius, ...])</p></td>
<td><p>Build the sample tree from input coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_base.ResampleBase.sufficient_memory_for" title="grig.resample_base.ResampleBase.sufficient_memory_for"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sufficient_memory_for</span></code></a>(memory)</p></td>
<td><p>Return whether there is sufficient available memory for the task.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.block_loop">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">block_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.block_loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.block_loop" title="Link to this definition">¶</a></dt>
<dd><p>Perform resampling reduction in parallel or series.</p>
<p>Utility function to allow the resampling algorithm to process blocks
of data in series or parallel, recombining the data once complete.
Please see <code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code> for descriptions of the
arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_values</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>fit_tree</strong><span class="classifier">BaseTree</span></dt><dd></dd>
<dt><strong>sample_tree</strong><span class="classifier">BaseTree</span></dt><dd></dd>
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>iteration</strong><span class="classifier">int</span></dt><dd></dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_cross_derivatives</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>jobs</strong><span class="classifier">int, optional</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>combined_results</strong><span class="classifier">8-tuple of numpy.ndarray</span></dt><dd><dl class="simple">
<dt>In order: fit, error, counts, weights, distance weights,</dt><dd><p>reduced chi-squared, MSCP derivatives, distribution offset.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.calculate_minimum_points">
<span class="sig-name descname"><span class="pre">calculate_minimum_points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.calculate_minimum_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.calculate_minimum_points" title="Link to this definition">¶</a></dt>
<dd><p>Return the minimum number of points for a fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">n-tuple</span></dt><dd><p>Input arguments used to determine the number of points required for
a fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>minimum_points</strong><span class="classifier">int</span></dt><dd><p>The minimum number of points for a fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.combine_blocks">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">combine_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_fits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.combine_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.combine_blocks" title="Link to this definition">¶</a></dt>
<dd><p>Combines the results from multiple reductions into one set.</p>
<p>The resampling reduction may be performed in serial or parallel over
multiple “blocks”, where each block contains a set of spatially
close fit coordinates and all samples necessary to perform a fit
over all points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">n-tuple of processed reductions for n blocks.</span></dt><dd></dd>
<dt><strong>n_sets</strong><span class="classifier">int</span></dt><dd><p>The number of data sets in the reduction.  Each set is contains
the same sample coordinates as all other sets, but the sample
values may vary.</p>
</dd>
<dt><strong>n_fits</strong><span class="classifier">int</span></dt><dd><p>The number of fitting points over all blocks.</p>
</dd>
<dt><strong>n_dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate dimensions.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>The fill value for missing data in the output fit value arrays.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that errors on the fit were calculated.</p>
</dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the number of samples used for each
fit should be returned.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the total weight sum of all samples used
in each fit should be returned.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the distance weight sum of all samples
used in each fit should be returned.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the reduced chi-squared statistic for
each fit should be returned.</p>
</dd>
<dt><strong>get_cross_derivatives</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the derivative MSCP should be returned.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the offset variance of the fit from the
sample distribution should be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">8-tuple of numpy.ndarray</span></dt><dd><p>results[0] = fitted values
results[1] = error on the fit
results[2] = counts
results[3] = total weight sums
results[4] = total distance weight sums
results[5] = reduced chi-squared statistic
results[6] = derivative MSCP
results[7] = offset variance</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The return value is always an 8-tuple, and the get_* keywords indicate
whether the calculated values in the block reductions are valid.  If
<cite>False</cite>, the corresponding output array will have the correct number of
axes, but be of zero size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.estimate_feature_windows">
<span class="sig-name descname"><span class="pre">estimate_feature_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.estimate_feature_windows"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.estimate_feature_windows" title="Link to this definition">¶</a></dt>
<dd><p>Estimates the radius of the fitting window for each feature.</p>
<p>The estimate of the window is given as the minimum required to
theoretically allow for a polynomial fit based on the number of samples
within such a window.  Since the window is a constant of the
resampling algorithm, it is difficult to calculate a precise value
that will allow all fits to occur at every point within (or close to)
the sample distribution.</p>
<p>Therefore, the sample distribution is divided up into <cite>feature_bins</cite>
n-dimensional boxes over each feature.  For example, if
<cite>feature_bins=10</cite> for 2-dimensional data, we would divide the sample
distribution into a total of 100 (10 * 10) equal boxes before counting
the number of samples inside each box.</p>
<p>The number of samples used to then calculate the final window radius
is determined from a given <cite>percentile</cite> (default = 50) of the box
counts.</p>
<p>For a fit of polynomial order <span class="math notranslate nohighlight">\(p\)</span>, the minimum number of samples
required for fitting is:</p>
<div class="math notranslate nohighlight">
\[N = (p + 1)^K\]</div>
<p>for <span class="math notranslate nohighlight">\(K\)</span> features if the order is “symmetrical” (i.e., the same
for each feature), or</p>
<div class="math notranslate nohighlight">
\[N_{required} = \prod_{k=1}^{K}{(p_k + 1)}\]</div>
<p>if the fit order varies by feature.  Coordinates are then scaled so
that:</p>
<div class="math notranslate nohighlight">
\[x_k^{\prime} = \text{feature\_bins} \times \frac{x_k - min(x_k)}
               {\beta_k}\]</div>
<p>where the scaling factor <span class="math notranslate nohighlight">\(\beta_k = max(x_k) - min(x_k)\)</span>. In this
scheme, the coordinates have been normalized such that the width of the
bin in each dimension is 1, and has a volume equal to one.  Therefore,
the sample density (<span class="math notranslate nohighlight">\(\rho\)</span>) of the bin is equal to the number of
samples it contains.  The volume of a unit radius spheroid is then
calculated as:</p>
<div class="math notranslate nohighlight">
\[V_{r=1} = \frac{\pi^{K/2}}{\Gamma(\frac{n}{2} + 1)}\]</div>
<p>and the expected number of samples expected to fall inside the spheroid
is given as:</p>
<div class="math notranslate nohighlight">
\[N_{r=1} = \rho V_{r=1}\]</div>
<p>We can then set the radius of the spheroid to give the required number
of points as:</p>
<div class="math notranslate nohighlight">
\[r_{scaled} = \left( \frac{N_{required} \nu}{N_{r=1}}
             \right)^{\frac{1}{K}} + \epsilon\]</div>
<p>where <span class="math notranslate nohighlight">\(\nu\)</span> is the <cite>oversample</cite> factor and <span class="math notranslate nohighlight">\(\epsilon\)</span> is
added to ensure that if resampling on a uniform grid of samples,
fitting at a point between two samples will always result in enough
samples available to perform a fit.  <span class="math notranslate nohighlight">\(\epsilon\)</span> is given as:</p>
<div class="math notranslate nohighlight">
\[\epsilon = 0.5 \rho^{\frac{-1}{K}}\]</div>
<p>or half the average spacing between samples.  We can then define the
final window radius for dimension <span class="math notranslate nohighlight">\(k\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\Omega_k = \frac{\beta_k r_{scaled}}{\text{feature\_bins}}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_features, n_coordinates)</span></dt><dd><p>The coordinates of all samples to be fit.</p>
</dd>
<dt><strong>feature_bins</strong><span class="classifier">int, optional</span></dt><dd><p>The number of bins to divide the sample coordinates into, per
feature, when determining the sample density (default = 10).</p>
</dd>
<dt><strong>percentile</strong><span class="classifier">int or float, optional</span></dt><dd><p>The percentile used to define a representative value for samples
per bin.  The default (50), gives the median of all bin
populations.</p>
</dd>
<dt><strong>oversample</strong><span class="classifier">int or float, optional</span></dt><dd><p>The oversampling factor for the window region.  A value of one will
result in a window that should provide the exact number of samples
required for a polynomial fit of the given order assuming
uniform density of the samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>window</strong><span class="classifier">numpy.ndarray (n_features,)</span></dt><dd><p>The principle axes of an ellipsoid used to create a fitting
region around each resampling point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.estimate_max_bytes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">estimate_max_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.estimate_max_bytes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.estimate_max_bytes" title="Link to this definition">¶</a></dt>
<dd><p>Estimate the maximum number of bytes required by a reduction.</p>
<p>Assumes that many factors are precalculated for processing time
reduction and that the ball-tree is constructed in the least efficient
configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The coordinates for the tree of shape (n_dimensions, n)</p>
</dd>
<dt><strong>window</strong><span class="classifier">int or float, optional</span></dt><dd><p>The size of the tree windows</p>
</dd>
<dt><strong>n_sets</strong><span class="classifier">int, optional</span></dt><dd><p>The number of data sets to reduce sharing coordinates.</p>
</dd>
<dt><strong>leaf_size</strong><span class="classifier">int, optional</span></dt><dd><p>The number of leaves used to construct the ball-tree.</p>
</dd>
<dt><strong>full_tree</strong><span class="classifier">bool, optional</span></dt><dd><p>Calculate the maximum number of bytes if the full ball-tree is
pre-calculated.  Otherwise, calculates the size of a single
neighborhood sized ball-tree.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keyword arguments to pass into the calculation for
subclasses of the Reduction.  Will include <cite>order</cite> (<cite>int</cite>) for
polynomial resampling.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_size</strong><span class="classifier">int</span></dt><dd><p>An upper limit for the maximum number of bytes used to construct
the reduction including pre-calculation and all possible inputs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.features">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">features</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.features" title="Link to this definition">¶</a></dt>
<dd><p>int : number of data features (dimensions)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.fit_settings">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_settings</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.fit_settings" title="Link to this definition">¶</a></dt>
<dd><p>dict : Fit reduction settings applied during last call</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.fit_tree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_tree</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.fit_tree" title="Link to this definition">¶</a></dt>
<dd><p>Return the fitting tree representative of points to fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>BaseTree</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.get_grid_class">
<span class="sig-name descname"><span class="pre">get_grid_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.get_grid_class"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.get_grid_class" title="Link to this definition">¶</a></dt>
<dd><p>Return the appropriate grid class for the resampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>BaseGrid subclass</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.global_resampling_values">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">global_resampling_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.global_resampling_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.global_resampling_values" title="Link to this definition">¶</a></dt>
<dd><p>Return the global resampling values.</p>
<p>The global resampling values are of main importance when performing
multiprocessing, and allows each process to gain fast access to the
necessary data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>dict</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.grid_class">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">grid_class</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.grid_class" title="Link to this definition">¶</a></dt>
<dd><p>Return the grid class of the resampler</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>BaseGrid subclass</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.multi_set">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">multi_set</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.multi_set" title="Link to this definition">¶</a></dt>
<dd><p>bool : True if solving for multiple data sets</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.n_samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_samples</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.n_samples" title="Link to this definition">¶</a></dt>
<dd><p>int : The number of samples in each data set.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.n_sets">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_sets</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.n_sets" title="Link to this definition">¶</a></dt>
<dd><p>int : The number of data sets to fit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.pre_fit">
<span class="sig-name descname"><span class="pre">pre_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.pre_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.pre_fit" title="Link to this definition">¶</a></dt>
<dd><p>Perform pre-fitting steps and build the fitting tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>Settings calculated via <cite>reduction_settings</cite> to be applied
if necessary.</p>
</dd>
<dt><strong>args</strong><span class="classifier">n-tuple</span></dt><dd><p>The call input arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.process_block">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">process_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.process_block"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.process_block" title="Link to this definition">¶</a></dt>
<dd><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p>
<p>Utility function that parses the settings and tree objects to something
usable by the numba JIT compiled resampling functions.  This is not
meant to be called directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">2-tuple</span></dt><dd><p>A tuple of form (filename, iteration) where the filename is a
string pointing towards a previously saved pickle file containing
the relevant information for the reduction if required.  If set to
<cite>None</cite>, the arguments are retrieved from the
<cite>_global_resampling_values</cite> global parameter.</p>
</dd>
<dt><strong>block</strong><span class="classifier">int</span></dt><dd><p>The block index to process.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">9-tuple of numpy.ndarray</span></dt><dd><p>The first element contains the fit point indices to be fit.  For
the remaining elements, please see <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> return
values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.process_blocks">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">process_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.process_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.process_blocks" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for handling block resampling in a multiprocessing environment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">n-tuple</span></dt><dd><p>The arguments to pass into <code class="xref py py-func docutils literal notranslate"><span class="pre">multitask()</span></code>.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict or None</span></dt><dd><p>The keyword arguments to pass into <code class="xref py py-func docutils literal notranslate"><span class="pre">multitask()</span></code>.</p>
</dd>
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>Reduction settings.</p>
</dd>
<dt><strong>sample_tree</strong><span class="classifier">BaseTree</span></dt><dd><p>The resampling tree in sample space.</p>
</dd>
<dt><strong>fit_tree</strong><span class="classifier">BaseTree</span></dt><dd><p>The fitting tree.</p>
</dd>
<dt><strong>jobs</strong><span class="classifier">int</span></dt><dd><p>The number of jobs to perform in parallel.</p>
</dd>
<dt><strong>iteration</strong><span class="classifier">int</span></dt><dd><p>The current resampling iteration.  This is simply used as a marker
to distinguish pickled files on each resampling run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">list</span></dt><dd><p>A list of the return values from the <cite>process_block</cite> method
for each block.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.reduction_settings">
<span class="sig-name descname"><span class="pre">reduction_settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distribution'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_threading</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.reduction_settings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.reduction_settings" title="Link to this definition">¶</a></dt>
<dd><p>Define a set of reduction instructions based on user input.</p>
<p>This method is responsible for determining, formatting, and checking
a number variables required for the resampling algorithm based on
user input.  For detailed descriptions of user options, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>fit_threshold</strong><span class="classifier">float, optional</span></dt><dd></dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd></dd>
<dt><strong>edge_threshold</strong><span class="classifier">float or array_like (n_features,), optional</span></dt><dd></dd>
<dt><strong>edge_algorithm</strong><span class="classifier">str, optional</span></dt><dd></dd>
<dt><strong>jobs</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>use_threading</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of threads during multiprocessing.</p>
</dd>
<dt><strong>use_processes</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of sub-processes during multiprocessing.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Optional keyword arguments to the reduction settings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>The reduction settings.  Also, stored as
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.fit_settings()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.set_sample_tree">
<span class="sig-name descname"><span class="pre">set_sample_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.set_sample_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.set_sample_tree" title="Link to this definition">¶</a></dt>
<dd><p>Build the sample tree from input coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The input coordinates of shape (n_features, n_samples).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float or sequence (float), optional</span></dt><dd><p>The radius of the window around each fitting point used to
determine sample selection for fit.  If not supplied, will be
estimated using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_bins</strong><span class="classifier">int, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_percentile</strong><span class="classifier">int or float, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_oversample</strong><span class="classifier">int or float, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>leaf_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points at which to switch to brute-force during the
ball tree query algorithm.  See <cite>sklearn.neighbours.BallTree</cite>
for further details.</p>
</dd>
<dt><strong>large_data</strong><span class="classifier">bool or None, optional</span></dt><dd><p>If <cite>True</cite>, indicates that this resampling algorithm will run on
a large set of data, and the ball tree should be created on
subsets of the data.</p>
</dd>
<dt><strong>check_memory</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, check the memory requirements for resampling the
supplied data.</p>
</dd>
<dt><strong>memory_buffer</strong><span class="classifier">float, optional</span></dt><dd><p>A fraction (positive or negative) with which to modify the memory
estimates for the process memory requirements.  Memory estimates
are scaled by the factor 1 + memory_buffer.</p>
</dd>
<dt><strong>memory_kwargs</strong><span class="classifier">dict, optional</span></dt><dd></dd>
<dt><strong>distance_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keyword arguments passed into
<code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.neighbors.DistanceMetric()</span></code>.  The default is to use
the “minkowski” definition with <cite>p=2</cite>, i.e., the Euclidean
definition.  This is important in determining which samples lie
inside the window region of a resampling point, and when deriving
distance weighting factors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.sufficient_memory_for">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sufficient_memory_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_base.html#ResampleBase.sufficient_memory_for"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_base.ResampleBase.sufficient_memory_for" title="Link to this definition">¶</a></dt>
<dd><p>Return whether there is sufficient available memory for the task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>memory</strong><span class="classifier">int or None</span></dt><dd><p>The memory required for the task in bytes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perform_task</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_base.ResampleBase.window">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">window</span></span><a class="headerlink" href="#grig.resample_base.ResampleBase.window" title="Link to this definition">¶</a></dt>
<dd><p>numpy.ndarray (n_features,) : Window radius in each dimension.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-grig.resample_kernel">
<span id="grig-resample-kernel-module"></span><h3>grig.resample_kernel module<a class="headerlink" href="#module-grig.resample_kernel" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">grig.resample_kernel.</span></span><span class="sig-name descname"><span class="pre">ResampleKernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knot_estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_knots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imperfect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#grig.resample_base.ResampleBase" title="grig.resample_base.ResampleBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.degrees" title="grig.resample_kernel.ResampleKernel.degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degrees</span></code></a></dt><dd><p>Return the degrees of the spline fit to the kernel.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.exit_code" title="grig.resample_kernel.ResampleKernel.exit_code"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exit_code</span></code></a></dt><dd><p>Return the exit code of the spline fit.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.exit_message" title="grig.resample_kernel.ResampleKernel.exit_message"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exit_message</span></code></a></dt><dd><p>Return the spline exit message.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>int : number of data features (dimensions)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_settings</span></code></dt><dd><p>dict : Fit reduction settings applied during last call</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_tree</span></code></dt><dd><p>Return the fitting tree representative of points to fit.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_class</span></code></dt><dd><p>Return the grid class of the resampler</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel" title="grig.resample_kernel.ResampleKernel.kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kernel</span></code></a></dt><dd><p>Return the resampling kernel.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel_offsets" title="grig.resample_kernel.ResampleKernel.kernel_offsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kernel_offsets</span></code></a></dt><dd><p>Return the coordinate offsets for the kernel.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel_spacing" title="grig.resample_kernel.ResampleKernel.kernel_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kernel_spacing</span></code></a></dt><dd><p>Return the spacing between kernel grid points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_set</span></code></dt><dd><p>bool : True if solving for multiple data sets</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_samples</span></code></dt><dd><p>int : The number of samples in each data set.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_sets</span></code></dt><dd><p>int : The number of data sets to fit.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.spline" title="grig.resample_kernel.ResampleKernel.spline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spline</span></code></a></dt><dd><p>Return the spline object for the kernel fit.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">window</span></code></dt><dd><p>numpy.ndarray (n_features,) : Window radius in each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*args[, cval, edge_threshold, ...])</p></td>
<td><p>Resample data defined during initialization onto new coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.block_loop" title="grig.resample_kernel.ResampleKernel.block_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_loop</span></code></a>(sample_values, error, mask, ...)</p></td>
<td><p>Perform resampling reduction in parallel or series.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_minimum_points</span></code>()</p></td>
<td><p>Return the minimum number of points for a fit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.combine_blocks" title="grig.resample_kernel.ResampleKernel.combine_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_blocks</span></code></a>(blocks, n_sets, n_fits, ...)</p></td>
<td><p>Combines the results from multiple reductions into one set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.estimate_feature_windows" title="grig.resample_kernel.ResampleKernel.estimate_feature_windows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_feature_windows</span></code></a>(*args, **kwargs)</p></td>
<td><p>Estimates the radius of the fitting window for each feature.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_max_bytes</span></code>(coordinates[, window, ...])</p></td>
<td><p>Estimate the maximum number of bytes required by a reduction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grid_class</span></code>()</p></td>
<td><p>Return the appropriate grid class for the resampler.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_resampling_values</span></code>()</p></td>
<td><p>Return the global resampling values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_fit</span></code>(settings, *args)</p></td>
<td><p>Perform pre-fitting steps and build the fitting tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.process_block" title="grig.resample_kernel.ResampleKernel.process_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_block</span></code></a>(args, block)</p></td>
<td><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_blocks</span></code>(args, kwargs, settings, ...)</p></td>
<td><p>Wrapper for handling block resampling in a multiprocessing environment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.reduction_settings" title="grig.resample_kernel.ResampleKernel.reduction_settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduction_settings</span></code></a>([error_weighting, ...])</p></td>
<td><p>Define a set of reduction instructions based on user input.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.set_kernel" title="grig.resample_kernel.ResampleKernel.set_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_kernel</span></code></a>(kernel[, kernel_spacing, ...])</p></td>
<td><p>Set the kernel for subsequent fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.set_sample_tree" title="grig.resample_kernel.ResampleKernel.set_sample_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sample_tree</span></code></a>(coordinates[, leaf_size, ...])</p></td>
<td><p>Build the sample tree from input coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sufficient_memory_for</span></code>(memory)</p></td>
<td><p>Return whether there is sufficient available memory for the task.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.block_loop">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">block_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.block_loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.block_loop" title="Link to this definition">¶</a></dt>
<dd><p>Perform resampling reduction in parallel or series.</p>
<p>Utility function to allow the resampling algorithm to process blocks
of data in series or parallel, recombining the data once complete.
Please see <code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code> for descriptions of the
arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_values</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>fit_tree</strong><span class="classifier">resampling.tree.PolynomialTree object</span></dt><dd></dd>
<dt><strong>sample_tree</strong><span class="classifier">resampling.tree.PolynomialTree object</span></dt><dd></dd>
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>iteration</strong><span class="classifier">int</span></dt><dd></dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>jobs</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>For consistency with the resampler base only.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>combined_results</strong><span class="classifier">8-tuple of numpy.ndarray</span></dt><dd><dl class="simple">
<dt>In order: fit, error, counts, weights, distance weights,</dt><dd><p>reduced chi-squared, MSCP derivatives, distribution offset.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.combine_blocks">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">combine_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_fits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.combine_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.combine_blocks" title="Link to this definition">¶</a></dt>
<dd><p>Combines the results from multiple reductions into one set.</p>
<p>The resampling reduction may be performed in serial or parallel over
multiple “blocks”, where each block contains a set of spatially
close fit coordinates and all samples necessary to perform a fit
over all points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">n-tuple of processed reductions for n blocks.</span></dt><dd></dd>
<dt><strong>n_sets</strong><span class="classifier">int</span></dt><dd><p>The number of data sets in the reduction.  Each set is contains
the same sample coordinates as all other sets, but the sample
values may vary.</p>
</dd>
<dt><strong>n_fits</strong><span class="classifier">int</span></dt><dd><p>The number of fitting points over all blocks.</p>
</dd>
<dt><strong>n_dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate dimensions.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>The fill value for missing data in the output fit value arrays.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that errors on the fit were calculated.</p>
</dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the number of samples used for each
fit should be returned.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the total weight sum of all samples used
in each fit should be returned.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the distance weight sum of all samples
used in each fit should be returned.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the reduced chi-squared statistic for
each fit should be returned.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that the offset variance of the fit from the
sample distribution should be returned.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>For consistency with ResampleBase only (not used).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">7-tuple of numpy.ndarray</span></dt><dd><p>results[0] = fitted values
results[1] = error on the fit
results[2] = counts
results[3] = total weight sums
results[4] = total distance weight sums
results[5] = reduced chi-squared statistic
results[6] = offset variance</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The return value is always an 8-tuple, and the get_* keywords indicate
whether the calculated values in the block reductions are valid.  If
<cite>False</cite>, the corresponding output array will have the correct number of
axes, but be of zero size.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.degrees">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">degrees</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.degrees" title="Link to this definition">¶</a></dt>
<dd><p>Return the degrees of the spline fit to the kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray (int)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.estimate_feature_windows">
<span class="sig-name descname"><span class="pre">estimate_feature_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.estimate_feature_windows"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.estimate_feature_windows" title="Link to this definition">¶</a></dt>
<dd><p>Estimates the radius of the fitting window for each feature.</p>
<p>The window for the resampling algorithm will be set to encompass the
kernel extent over all dimensions.  Unlike the standard resampling
algorithm, the coordinates of the data samples are irrelevant.</p>
<p>The window radius is based on the kernel extent in this implementation.</p>
<p>Since the resampling algorithm uses an ellipsoid window to determine
possible candidates for fitting, the window is determined as an
ellipsoid which circumscribes the cuboid kernel array.  Although there
are an infinite number of possible ellipsoids, this particular method
uses the constraints that principle axes of the ellipsoid and cuboid
widths are at a constant ratio.  For example, in two dimensions where
a and b are the principle axes of an ellipsoid, and w and h are the
widths of the kernel:</p>
<p>a/w = b/h; (w / 2a)^2 + (h / 2b)^2 = 1.</p>
<p>This leads to us setting the principle axes as:</p>
<p>a_i = sqrt(n / 4) * w_i + delta</p>
<p>where w_i is the width of the kernel in dimension i in n-dimensions,
and delta = spacing/1e6 so that any edge cases can be included safely.
This is also valid in one dimension (a_i = w_i / 2).  Note that kernels
are assumed to be exactly centered, so the width of a kernel in any
dimension will be:</p>
<p>w_i = spacing_i * (kernel.shape[i] - 1)</p>
<p>Note that this implementation takes the width as 2 * the maximum
absolute offset of the kernel for each dimension, so that irregular
kernels may be safely used.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">numpy.ndarray (n_features,)</span></dt><dd><p>The principle axes of an ellipsoid used to create a fitting
region around each resampling point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.exit_code">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exit_code</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.exit_code" title="Link to this definition">¶</a></dt>
<dd><p>Return the exit code of the spline fit.</p>
<p>Please see the <code class="xref py py-class docutils literal notranslate"><span class="pre">Spline</span></code> class for further details on
the meanings of each code.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.exit_message">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exit_message</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.exit_message" title="Link to this definition">¶</a></dt>
<dd><p>Return the spline exit message.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>str</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.kernel">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.kernel" title="Link to this definition">¶</a></dt>
<dd><p>Return the resampling kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray (float)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.kernel_offsets">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_offsets</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.kernel_offsets" title="Link to this definition">¶</a></dt>
<dd><p>Return the coordinate offsets for the kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray (float)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.kernel_spacing">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_spacing</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.kernel_spacing" title="Link to this definition">¶</a></dt>
<dd><p>Return the spacing between kernel grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray (float)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.process_block">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">process_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.process_block"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.process_block" title="Link to this definition">¶</a></dt>
<dd><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p>
<p>Utility function that parses the settings and tree objects to something
usable by the numba JIT compiled resampling functions.  This is not
meant to be called directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">2-tuple</span></dt><dd><p>A tuple of form (filename, iteration) where the filename is a
string pointing towards a previously saved pickle file containing
the relevant information for the reduction if required.  If set to
<cite>None</cite>, the arguments are retrieved from the
<cite>_global_resampling_values</cite> global parameter.</p>
</dd>
<dt><strong>block</strong><span class="classifier">int</span></dt><dd><p>The block index to process.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">9-tuple of numpy.ndarray</span></dt><dd><p>The first element contains the fit point indices to be fit.  For
the remaining elements, please see <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> return
values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.reduction_settings">
<span class="sig-name descname"><span class="pre">reduction_settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distribution'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_threading</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.reduction_settings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.reduction_settings" title="Link to this definition">¶</a></dt>
<dd><p>Define a set of reduction instructions based on user input.</p>
<p>This method is responsible for determining, formatting, and checking
a number variables required for the resampling algorithm based on
user input.  For detailed descriptions of user options, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite> (default), weight polynomial fitting by the <cite>error</cite>
values of each sample.</p>
</dd>
<dt><strong>absolute_weight</strong><span class="classifier">bool, optional</span></dt><dd><p>If the kernel weights are negative, can lead to almost zero-like
divisions in many of the algorithms.  If set to <cite>True</cite>, the sum of
the absolute weights are used for normalization.</p>
</dd>
<dt><strong>fit_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Not implemented for kernel fitting.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>During fitting, any fit that does not meet the <cite>order_algorithm</cite>
requirement will be set to this value. This will be NaN by default.</p>
</dd>
<dt><strong>edge_threshold</strong><span class="classifier">float or array_like or float</span></dt><dd><p>If set to a value &gt; 0, edges of the fit will be masked out
according to <cite>edge_algorithm</cite>. Values close to zero will result in
a low degree of edge clipping, while values close to 1 clip edges
to a greater extent.  The exact definition of <cite>edge_threshold</cite>
depends on the algorithm.  For further details, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">resampling.resample_utils.check_edges()</span></code>.</p>
</dd>
<dt><strong>edge_algorithm</strong><span class="classifier">str, optional</span></dt><dd><p>Describes how to clip edges if edge_threshold is non-zero. The
available algorithms are:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘distribution’ (default): Statistics on sample distributions
are calculated, and if the resampling point is &gt; 1/threshold
standard deviations away from the sample mean, it will be
clipped.</p></li>
<li><p>‘ellipsoid’: If the samples used to fit a
resampling point deviate from the resampling point
location by more than this amount, it will be clipped.</p></li>
<li><p>‘box’: If the flattened 1-dimensional distribution
of samples center-of-mass deviates from the resampling
point location in any dimension, it will be clipped.</p></li>
<li><p>‘range’: Over each dimension, check the distribution of
points is greater than edge_threshold to the “left” and
“right” of the resampling point.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the input data is treated as a covariance instead of
a flux, and is propagated as if through a weighted mean.</p>
</dd>
<dt><strong>jobs</strong><span class="classifier">int, optional</span></dt><dd><p>Specifies the maximum number of concurrently running jobs.  An
attempt will be made to parallel process using a thread-pool if
available, but will otherwise revert to the “loky” backend.
Values of 0 or 1 will result in serial processing.  A negative
value sets jobs to <cite>n_cpus + 1 + jobs</cite> such that -1 would use
all cpus, and -2 would use all but one cpu.</p>
</dd>
<dt><strong>use_threading</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of threads during multiprocessing.</p>
</dd>
<dt><strong>use_processes</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of sub-processes during multiprocessing.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Optional keyword arguments to the reduction settings.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>The reduction settings.  Also, stored as
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.fit_settings()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.set_kernel">
<span class="sig-name descname"><span class="pre">set_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knot_estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_knots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imperfect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.set_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.set_kernel" title="Link to this definition">¶</a></dt>
<dd><p>Set the kernel for subsequent fitting.</p>
<p>During this process, a spline will be fit to describe the kernel at
all intermediate points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kernel</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The kernel to set.  Must have n_features dimensions.</p>
</dd>
<dt><strong>kernel_spacing</strong><span class="classifier">float or numpy.ndarray (float), optional</span></dt><dd><p>The spacing between each kernel element in units of the
coordinates. Either supplied as a single value for all features,
or as an array of shape (n_features,) giving the kernel spacing
for each feature.</p>
</dd>
<dt><strong>kernel_offsets</strong><span class="classifier">tuple or array_like, optional</span></dt><dd><p>If the kernel is regular, should be an n-dimensional tuple
containing the grid indices in each dimension.  Otherwise, should
be an array of shape (n_dimensions, kernel.size).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>Optional weights to supply to the spline fit for each data point.
Should be the same shape as the supplied kernel.</p>
</dd>
<dt><strong>limits</strong><span class="classifier">numpy.ndarray (float), optional</span></dt><dd><p>An array of shape (n_dimensions, 2) that may be supplied to set the
minimum and maximum coordinate values used during the spline fit.
For example, limits[1, 0] sets the minimum knot value in the second
dimensions and limits[1, 1] sets the maximum knot value in the
second dimension.  By default this is set to the minimum and
maximum values of the coordinates in each dimension.</p>
</dd>
<dt><strong>degrees</strong><span class="classifier">int or numpy.ndarray (int), optional</span></dt><dd><p>The degree of spline to fit in each dimension.  Either a scalar can
be supplied pertaining to all dimensions, or an array of shape
(n_dimensions,) can be used.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">float, optional</span></dt><dd><p>Used to specify the smoothing factor.  If set to <cite>None</cite>, the
smoothing will be determined based on user settings or input data.
If <cite>exact</cite> is <cite>True</cite>, smoothing will be disabled (zero).  If
<cite>exact</cite> is <cite>False</cite>, smoothing will be set to n - sqrt(2 * n)
where n is the number of data values.  If supplied, smoothing
must be greater than zero.  See above for further details.  Note
that if smoothing is zero, and the degrees are not equal over
each dimension, smoothing will be set to <cite>eps</cite> due to numerical
instabilities.</p>
</dd>
<dt><strong>knots</strong><span class="classifier">list or tuple or numpy.ndarray, optional</span></dt><dd><p>A set of starting knot coordinates for each dimension.  If a list
or tuple is supplied it should be of length n_dimensions where
element i is an array of shape (n_knots[i]) for dimension i.  If
an array is supplied, it should be of shape
(n_dimension, max(n_knots)). Note that there must be at least
2 * (degree + 1) knots for each dimension.  Unused or invalid
knots may be set to NaN, at the end of each array.  Knot
coordinates must also be monotonically increasing in each
dimension.</p>
</dd>
<dt><strong>knot_estimate</strong><span class="classifier">numpy.ndarray (int), optional</span></dt><dd><p>The maximum number of knots required for the spline fit in each
dimension and of shape (n_dimensions,).  If not supplied, the knot
estimate will be set to
int((n / n_dimensions) ** n_dimensions^(-1)) or n_knots if
knots were supplied and fixed.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>A value where 0 &lt; eps &lt; 1.  This defines the magnitude used to
identify singular values in the spline observation matrix (A).  If
any row of A[:, 0] &lt; (eps * max(A[:,0])) it will be considered
singular.</p>
</dd>
<dt><strong>fix_knots</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, do not attempt to modify or add knots to the spline fit.
Only the initial supplied user knots will be used.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>A value in the range 0 &lt; tolerance &lt; 1 used to determine the exit
criteria for the spline fit.  See above for further details.</p>
</dd>
<dt><strong>max_iteration</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum number of iterations to perform when solving for the
spline fit.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, the initial knots used will coincide with the actual
input coordinates and smoothing will be set to zero.  No knots
should be supplied by the user in this instance.</p>
</dd>
<dt><strong>reduce_degrees</strong><span class="classifier">bool, optional</span></dt><dd><p>Only relevant if <cite>exact</cite> is <cite>True</cite>.  If set to <cite>True</cite>, the maximum
allowable degree in each dimension will be limited to
(len(unique(x)) // 2) - 1 where x are the coordinate values in any
dimension.</p>
</dd>
<dt><strong>imperfect</strong><span class="classifier">bool, optional</span></dt><dd><p>If a spline fit to the kernel is allowed to be imperfect (<cite>True</cite>),
will only raise an error on spline fitting if a major error was
encountered.  Otherwise, fits will be permitted so long as a
solution was reached, even if that solution did not meet
expectations.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.set_sample_tree">
<span class="sig-name descname"><span class="pre">set_sample_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel.html#ResampleKernel.set_sample_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.set_sample_tree" title="Link to this definition">¶</a></dt>
<dd><p>Build the sample tree from input coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The input coordinates of shape (n_features, n_samples).</p>
</dd>
<dt><strong>leaf_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points at which to switch to brute-force during the
ball tree query algorithm.  See <cite>sklearn.neighbours.BallTree</cite>
for further details.</p>
</dd>
<dt><strong>large_data</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that this resampling algorithm will run on
a large set of data, and the ball tree should be created on
subsets of the data.</p>
</dd>
<dt><strong>distance_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keyword arguments passed into
<code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.neighbors.DistanceMetric()</span></code>.  The default is to use
the “minkowski” definition with <cite>p=2</cite>, i.e., the Euclidean
definition.  This is important in determining which samples lie
inside the window region of a resampling point, and when deriving
distance weighting factors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_kernel.ResampleKernel.spline">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spline</span></span><a class="headerlink" href="#grig.resample_kernel.ResampleKernel.spline" title="Link to this definition">¶</a></dt>
<dd><p>Return the spline object for the kernel fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Spline</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-grig.resample_kernel_utils">
<span id="grig-resample-kernel-utils-module"></span><h3>grig.resample_kernel_utils module<a class="headerlink" href="#module-grig.resample_kernel_utils" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_kernel_utils.apply_mask_to_kernel_set_arrays">
<span class="sig-prename descclassname"><span class="pre">grig.resample_kernel_utils.</span></span><span class="sig-name descname"><span class="pre">apply_mask_to_kernel_set_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel_utils.html#apply_mask_to_kernel_set_arrays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel_utils.apply_mask_to_kernel_set_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Set certain arrays to a fixed size based on a mask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (N,)</span></dt><dd><p>Mask where <cite>True</cite> values indicate the associated element should be
kept, and <cite>False</cite> will result in exclusion from the output arrays.</p>
</dd>
<dt><strong>data</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The data array.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (N,).  If an array of size 1 is supplied,
it will be expanded to an array of <cite>counts</cite> size.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (N,).  If an array of size 1 is supplied,
it will be expanded to an array of <cite>counts</cite> size.</p>
</dd>
<dt><strong>counts</strong><span class="classifier">int, optional</span></dt><dd><p>The number of <cite>True</cite> values in the mask, optionally passed in for
speed.  Determines the output size of all arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data_out, error_out, weight_out</strong><span class="classifier">3-tuple of numpy.ndarray.</span></dt><dd><p>Resized arrays in which the last axis is of size <cite>counts</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_kernel_utils.calculate_kernel_weights">
<span class="sig-prename descclassname"><span class="pre">grig.resample_kernel_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_kernel_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_knots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">panel_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">panel_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knot_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel_utils.html#calculate_kernel_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel_utils.calculate_kernel_weights" title="Link to this definition">¶</a></dt>
<dd><p>Calculate values of a kernel centered on a reference for given coordinates.</p>
<p>The kernel must have been transformed into a spline representation.  A
value of zero on the spline knots represents the center of the kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The coordinates for which to calculate weights of shape
(n_dimensions, n).</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The location of the kernel center of shape (n_dimensions,).</p>
</dd>
<dt><strong>knots</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The kernel spline knots of shape (n_dimensions, &gt;max(n_knots)).</p>
</dd>
<dt><strong>n_knots</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The number of spline knots in each dimension of shape (n_dimensions,).</p>
</dd>
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The spline coefficients of shape (n_coefficients,).</p>
</dd>
<dt><strong>degrees</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The spline degrees in each dimension of shape (n_dimensions,).</p>
</dd>
<dt><strong>panel_mapping</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array containing the panel mapping (flat to n-D) indices.  This is
created by passing the panel shape (n_knots - (2 * degrees) - 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.  Should be an array of shape
(n_dimensions, n_panels).</p>
</dd>
<dt><strong>panel_steps</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The flat index mapping steps in panel-space of shape (n_dimensions,).
These are returned by passing the shape <cite>Spline.panel_shape</cite> into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.</p>
</dd>
<dt><strong>knot_steps</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The flat index mapping steps in knot-space of shape (n_dimensions,).
These are returned by passing the shape (n_knots - degrees - 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.</p>
</dd>
<dt><strong>nk1</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array of shape (n_dimensions,) containing the values n_knots - k1
where n_knots are the number of knots in each dimension, and k1 are the
spline degrees + 1 in each dimension.</p>
</dd>
<dt><strong>spline_mapping</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array containing the spline mapping (flat to n-D) indices.  This is
created by passing the spline shape (degrees + 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.  Should be an array of shape
(n_dimensions, n_spline_coefficients).</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Due to rounding errors, sometimes a value is flagged as invalid if it
is exactly on the edge of the kernel.  This value allows a certain
tolerance to those incorrect results.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The interpolated weights of shape (n,).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_kernel_utils.solve_kernel_fit">
<span class="sig-prename descclassname"><span class="pre">grig.resample_kernel_utils.</span></span><span class="sig-name descname"><span class="pre">solve_kernel_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_coordinate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel_utils.html#solve_kernel_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel_utils.solve_kernel_fit" title="Link to this definition">¶</a></dt>
<dd><p>Solve for a kernel convolution at a single coordinate.</p>
<p>Generally, the kernel convolution value is of the form:</p>
<div class="math notranslate nohighlight">
\[f(x) = \sum_{j}{d_j k_j} / \sum_{j}{k_j}\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the coordinate at the fit point, <span class="math notranslate nohighlight">\(j\)</span> are the
indices of all samples within the fitting window, <span class="math notranslate nohighlight">\(d\)</span> are the sample
values, and <span class="math notranslate nohighlight">\(k\)</span> are the kernel weights.</p>
<p>EDGE CHECKING</p>
<p>The first of the on-the-fly calculation is the “edge check”.  Generally,
polynomial fits are not well-defined away from the sample distribution
from which they were derived.  This is especially true for higher order
fits that may fit the sample distribution well, but start to deviate wildly
when evaluated outside of the distribution.  The edge check step defines a
border around the distribution, outside of which the fit will be aborted.
There are a number of algorithms available which vary in robustness and
speed.  Please see <code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code> for details on available algorithms.</p>
<p>FITTING</p>
<p>If the above checks pass, a fit can be attempted.  There are two types of
fit that may be performed.  The first is the standard kernel fit described
above.  However, if <cite>is_covar</cite> was set to <cite>True</cite>, the <cite>window_values</cite> are
considered covariances to propagate, and a fit will derived by propagating
a weighted variance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The independent coordinates within the window region of the fitting
coordinate.</p>
</dd>
<dt><strong>window_values</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The dependent values of the samples.</p>
</dd>
<dt><strong>window_error</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The associated 1-sigma error values for each sample in each set.  The
user may also supply an array of shape (1,) in which case all
samples in a set will share the same associated error value.  If the
shape is set to (0,) this indicates that no error values are available
for the samples.</p>
</dd>
<dt><strong>window_mask</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> indicates that the associated sample should be
excluded from the fit.</p>
</dd>
<dt><strong>kernel_weights</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The kernel weighting factors applied to each sample in the fit.</p>
</dd>
<dt><strong>fit_coordinate</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The coordinate of the fitting point.</p>
</dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that <cite>window_values</cite> contains covariance values
that should be propagated through algorithm.  If this is the case,
polynomial fitting is disabled, and a weighted variance is calculated
instead.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>In a case that a fit is unable to be calculated at certain location,
<cite>cval</cite> determines the returned fit value.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, weight the samples in the fit by the inverse variance
(1 / window_error^2) in addition to distance weighting.</p>
</dd>
<dt><strong>absolute_weight</strong><span class="classifier">bool, optional</span></dt><dd><p>If the kernel weights are negative, can lead to almost zero-like
divisions in many of the algorithms.  If set to <cite>True</cite>, the sum of the
absolute weights are used for normalization.</p>
</dd>
<dt><strong>edge_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>Integer specifying the algorithm used to determine whether a fit should
be attempted with respect to the sample distribution.  Please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code> for further information.  The default (1), is
always the most robust of the available algorithms.</p>
</dd>
<dt><strong>edge_threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A threshold parameter determining how close an edge should be to the
center of the distribution during <code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code>.  Higher values
result in an edge closer to the sample mean.  A value should be
provided for each dimension.  A zero value in any dimension will result
in an infinite edge for that dimension.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the error on the fit.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of all sample weights used in determining the
fit.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of only the distance weights used in
determining the fit.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the reduced chi-squared statistic for each of
the fits.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool optional</span></dt><dd><p>If <cite>True</cite>, return the offset of the fitting point from the sample
distribution.  See <code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code> for further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_result</strong><span class="classifier">7-tuple</span></dt><dd><dl class="simple">
<dt>fit_result[0]: Fitted value (float).</dt><dd><p>Set to <cite>cval</cite> on fit failure.</p>
</dd>
<dt>fit_result[1]: Error on the fit (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
<dt>fit_result[2]: Number of samples included in the fit (int).</dt><dd><p>Set to 0 on fit failure.</p>
</dd>
<dt>fit_result[3]: Weight sum (float).</dt><dd><p>Set to 0.0 on fit failure.</p>
</dd>
<dt>fit_result[4]: Distance weight sum (float).</dt><dd><p>Set to 0.0 on fit failure.</p>
</dd>
<dt>fit_result[5]: Reduced chi-squared statistic (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
<dt>fit_result[6]: Offset variance from the distribution center (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_kernel_utils.solve_kernel_fits">
<span class="sig-prename descclassname"><span class="pre">grig.resample_kernel_utils.</span></span><span class="sig-name descname"><span class="pre">solve_kernel_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">panel_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">panel_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knot_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nk1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline_mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_knots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absolute_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_kernel_utils.html#solve_kernel_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_kernel_utils.solve_kernel_fits" title="Link to this definition">¶</a></dt>
<dd><p>Solve all fits within one intersection block.</p>
<p>This function is a wrapper for <a class="reference internal" href="#grig.resample_kernel_utils.solve_kernel_fit" title="grig.resample_kernel_utils.solve_kernel_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_kernel_fit()</span></code></a> over all data sets
and fit points.  The main computations here involve:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Creating and populating the output arrays.</p></li>
<li><p>Selecting the correct samples within the region of each fitting
window.</p></li>
<li><p>Calculating the full weighting factors for the fits.</p></li>
</ol>
</div></blockquote>
<p>For further details on the actual fitting, please see
<a class="reference internal" href="#grig.resample_kernel_utils.solve_kernel_fit" title="grig.resample_kernel_utils.solve_kernel_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_kernel_fit()</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_indices</strong><span class="classifier">numba.typed.List</span></dt><dd><p>A list of 1-dimensional numpy.ndarray (dtype=int) of length n_fits.
Each list element <cite>sample_indices[i]</cite>, contains the indices of samples
within the “window” region of <cite>fit_indices[i]</cite>.</p>
</dd>
<dt><strong>sample_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The independent coordinates for each sample in n_dimensions</p>
</dd>
<dt><strong>sample_data</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>The dependent values of the samples for n_sets, each containing
n_samples.</p>
</dd>
<dt><strong>sample_error</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>The associated 1-sigma error values for each sample in each set.  The
user may also supply an array of shape (n_sets, 1) in which case all
samples in a set will share the same associated error value.  If
the shape is set to (n_sets, 0), this indicates that no error values
are available for the samples.</p>
</dd>
<dt><strong>sample_mask</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>A mask where <cite>False</cite> indicates that the associated sample should be
excluded from all fits.</p>
</dd>
<dt><strong>fit_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_fits)</span></dt><dd><p>The independent variables at each fit coordinate in d_dimensions.</p>
</dd>
<dt><strong>knots</strong><span class="classifier">list or tuple or numpy.ndarray, optional</span></dt><dd><p>A set of starting knot coordinates for each dimension.  If a list or
tuple is supplied it should be of length n_dimensions where element
i is an array of shape (n_knots[i]) for dimension i.  If an array
is supplied, it should be of shape (n_dimension, max(n_knots)).
Note that there must be at least 2 * (degree + 1) knots for each
dimension.  Unused or invalid knots may be set to NaN, at the end
of each array.  Knot coordinates must also be monotonically
increasing in each dimension.</p>
</dd>
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The spline coefficients of shape (n_coefficients,).</p>
</dd>
<dt><strong>degrees</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The degrees of the spline in each dimension (n_dimensions,).</p>
</dd>
<dt><strong>panel_mapping</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array containing the panel mapping (flat to n-D) indices.  This is
created by passing the panel shape (n_knots - (2 * degrees) - 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.  Should be an array of shape
(n_dimensions, n_panels).</p>
</dd>
<dt><strong>panel_steps</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The flat index mapping steps in panel-space of shape (n_dimensions,).
These are returned by passing the shape <cite>Spline.panel_shape</cite> into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.</p>
</dd>
<dt><strong>knot_steps</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The flat index mapping steps in knot-space of shape (n_dimensions,).
These are returned by passing the shape (n_knots - degrees - 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.</p>
</dd>
<dt><strong>nk1</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array of shape (n_dimensions,) containing the values n_knots - k1
where n_knots are the number of knots in each dimension, and k1 are the
spline degrees + 1 in each dimension.</p>
</dd>
<dt><strong>spline_mapping</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>An array containing the spline mapping (flat to n-D) indices.  This is
created by passing the spline shape (degrees + 1) into
<code class="xref py py-func docutils literal notranslate"><span class="pre">flat_index_mapping()</span></code>.  Should be an array of shape
(n_dimensions, n_spline_coefficients).</p>
</dd>
<dt><strong>n_knots</strong><span class="classifier">numpy.ndarray (int)</span></dt><dd><p>The number of knots in each dimension (n_dimensions,).</p>
</dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that <cite>sample_data</cite> contains covariance values
that should be propagated through algorithm.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>In a case that a fit is unable to be calculated at certain location,
<cite>cval</cite> determines the fill value for the output <cite>fit</cite> array at those
locations.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, weight the samples in the fit by the inverse variance
(1 / sample_error^2) in addition to distance weighting.</p>
</dd>
<dt><strong>absolute_weight</strong><span class="classifier">bool, optional</span></dt><dd><p>If the kernel weights are negative, can lead to almost zero-like
divisions in many of the algorithms.  If set to <cite>True</cite>, the sum of the
absolute weights are used for normalization.</p>
</dd>
<dt><strong>edge_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>Integer specifying the algorithm used to determine whether a fit should
be attempted with respect to the sample distribution.  Please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code> for further information.  The default (1), is
always the most robust of the available algorithms.</p>
</dd>
<dt><strong>edge_threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A threshold parameter determining how close an edge should be to the
center of the distribution during <code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code>.  Higher values
result in an edge closer to the sample mean.  A value should be
provided for each dimension.  A zero value in any dimension will result
in an infinite edge for that dimension.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the error on the fit.</p>
</dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the number of samples used when determining the fit
at each fitting point.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of all sample weights used in determining the
fit at each point.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of only the distance weights used in
determining the fit at each point.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the reduced chi-squared statistic for each of the
fitted points.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool optional</span></dt><dd><p>If <cite>True</cite>, return the offset of the fitting point from the sample
distribution.  See <code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code> for further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fit_results</strong><span class="classifier">7-tuple of numpy.ndarray</span></dt><dd><p>fit_results[0]: Fitted values.
fit_results[1]: Error on the fit.
fit_results[2]: Number of samples in each fit.
fit_results[3]: Weight sums.
fit_results[4]: Distance weight sums.
fit_results[5]: Reduced chi-squared statistic.
fit_results[6]: Offset variances from the sample distribution center.</p>
<p>All arrays have the shape (n_sets, n_fits) or (0, 0) depending on
whether <cite>get_&lt;name&gt;</cite> is <cite>True</cite> or <cite>False</cite> respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-grig.resample_polynomial">
<span id="grig-resample-polynomial-module"></span><h3>grig.resample_polynomial module<a class="headerlink" href="#module-grig.resample_polynomial" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">grig.resample_polynomial.</span></span><span class="sig-name descname"><span class="pre">ResamplePolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#grig.resample_base.ResampleBase" title="grig.resample_base.ResampleBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResampleBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>int : number of data features (dimensions)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_settings</span></code></dt><dd><p>dict : Fit reduction settings applied during last call</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.fit_tree" title="grig.resample_polynomial.ResamplePolynomial.fit_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_tree</span></code></a></dt><dd><p>Return the fitting tree representative of points to fit.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_class</span></code></dt><dd><p>Return the grid class of the resampler</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_set</span></code></dt><dd><p>bool : True if solving for multiple data sets</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_samples</span></code></dt><dd><p>int : The number of samples in each data set.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_sets</span></code></dt><dd><p>int : The number of data sets to fit.</p>
</dd>
<dt><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.order" title="grig.resample_polynomial.ResamplePolynomial.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></dt><dd><p>Return the order of polynomial fit.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">window</span></code></dt><dd><p>numpy.ndarray (n_features,) : Window radius in each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*args[, smoothing, ...])</p></td>
<td><p>Resample data defined during initialization to new coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_loop</span></code>(sample_values, error, mask, ...)</p></td>
<td><p>Perform resampling reduction in parallel or series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.calculate_adaptive_smoothing" title="grig.resample_polynomial.ResamplePolynomial.calculate_adaptive_smoothing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_adaptive_smoothing</span></code></a>(settings)</p></td>
<td><p>Calculate the adaptive distance weighting kernel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.calculate_minimum_points" title="grig.resample_polynomial.ResamplePolynomial.calculate_minimum_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_minimum_points</span></code></a>()</p></td>
<td><p>Return the minimum number of points for a polynomial fit.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.check_order" title="grig.resample_polynomial.ResamplePolynomial.check_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_order</span></code></a>(order, n_features, n_samples)</p></td>
<td><p>Check the order is of correct format and enough samples exist.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_blocks</span></code>(blocks, n_sets, n_fits, ...)</p></td>
<td><p>Combines the results from multiple reductions into one set.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_feature_windows</span></code>(coordinates[, ...])</p></td>
<td><p>Estimates the radius of the fitting window for each feature.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_max_bytes</span></code>(coordinates[, window, ...])</p></td>
<td><p>Estimate the maximum number of bytes required by a reduction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grid_class</span></code>()</p></td>
<td><p>Return the appropriate grid class for the resampler.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_resampling_values</span></code>()</p></td>
<td><p>Return the global resampling values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.pre_fit" title="grig.resample_polynomial.ResamplePolynomial.pre_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pre_fit</span></code></a>(settings, *args[, ...])</p></td>
<td><p>Perform pre-fitting steps and build the fitting tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.process_block" title="grig.resample_polynomial.ResamplePolynomial.process_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_block</span></code></a>(args, block)</p></td>
<td><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_blocks</span></code>(args, kwargs, settings, ...)</p></td>
<td><p>Wrapper for handling block resampling in a multiprocessing environment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.reduction_settings" title="grig.resample_polynomial.ResamplePolynomial.reduction_settings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduction_settings</span></code></a>([smoothing, ...])</p></td>
<td><p>Define a set of reduction instructions based on user input.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.set_sample_tree" title="grig.resample_polynomial.ResamplePolynomial.set_sample_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sample_tree</span></code></a>(coordinates[, radius, ...])</p></td>
<td><p>Build the sample tree from input coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sufficient_memory_for</span></code>(memory)</p></td>
<td><p>Return whether there is sufficient available memory for the task.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.calculate_adaptive_smoothing">
<span class="sig-name descname"><span class="pre">calculate_adaptive_smoothing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.calculate_adaptive_smoothing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.calculate_adaptive_smoothing" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the adaptive distance weighting kernel.</p>
<p>Calculates a weighting kernel for each sample in the reduction.  i.e,
each sample will have a different weighting factor based on its
distance (and optionally, direction) from each point at which a fit
is required.  This is done by performing a fit centered on each sample,
and measuring how that fit deviates from the actual observed sample
value.  The first step is to decide upon the distance weighting factor
used to perform the initial fit.</p>
<p>It is assumed that the coordinate error is known (or approximately
known), and supplied as a <span class="math notranslate nohighlight">\(1 \sigma\)</span> error as the ‘alpha’
keyword in <cite>settings</cite>.  For example, the error in astronomical
observations taken using a Gaussian beam with known FWHM is:</p>
<div class="math notranslate nohighlight">
\[\sigma = \frac{\text{FWHM}}{2 \sqrt{2 \ln{2}}}\]</div>
<p>However, adaptive weighting may be calculated over select dimensions,
leaving some fixed.  In this case, the <cite>alpha</cite> keyword will always
apply a weighting factor in a “fixed” dimension <span class="math notranslate nohighlight">\(k\)</span> as:</p>
<div class="math notranslate nohighlight">
\[w_k = exp \left(
      \frac{-\Delta x_k^2}{\alpha_{fixed, k} \Omega_k^2}
      \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta x_k\)</span> is the distance from the resampling point to
the sample in question, and <span class="math notranslate nohighlight">\(\Omega_k\)</span> is the window principle
axis in dimension <span class="math notranslate nohighlight">\(k\)</span>.  Note that in the weighting function,
<span class="math notranslate nohighlight">\(\sigma\)</span> is related to <span class="math notranslate nohighlight">\(\alpha\)</span> by:</p>
<div class="math notranslate nohighlight">
\[\alpha_k = 2 \sigma_k^2\]</div>
<p>and weighting is applied using the definition of <span class="math notranslate nohighlight">\(w_k\)</span> above.  To
signify that <span class="math notranslate nohighlight">\(\alpha_{fixed, k}\)</span> should be used instead of
<span class="math notranslate nohighlight">\(\sigma\)</span> for dimension <span class="math notranslate nohighlight">\(k\)</span>, the “adaptive_threshold” array
in <cite>settings</cite> should be set to zero for the corresponding dimension.
For example, if we had:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="n">settings</span><span class="p">[</span><span class="s1">&#39;adaptive_threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>the first dimension would have <span class="math notranslate nohighlight">\(\alpha_0=0.18\)</span>
(<span class="math notranslate nohighlight">\(2 \times 0.3^2\)</span>), and the second would have
<span class="math notranslate nohighlight">\(\alpha_1=0.3\)</span>.  In this example, <span class="math notranslate nohighlight">\(\alpha_0\)</span> would be
allowed to vary per sample, while <span class="math notranslate nohighlight">\(\alpha_1\)</span> would be fixed for
each sample at 0.3.  An initial fit is then performed at each sample
coordinate using a test distance weighting parameter:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\sigma_{test, k} = \frac{\pi \sigma_k}{\sqrt{2 ln{2}}}\\\alpha_{test, k} = 2 \sigma_{test, k}^2\end{aligned}\end{align} \]</div>
<p>Using this initial weighting parameter, the adaptive kernels are
derived using either
<code class="xref py py-func docutils literal notranslate"><span class="pre">resample_utils.shaped_adaptive_weight_matrix()</span></code> or
<code class="xref py py-func docutils literal notranslate"><span class="pre">resample_utils.scaled_adaptive_weight_matrix()</span></code> depending on
whether the “shaped” keyword in <cite>settings</cite> is set to <cite>True</cite> or <cite>False</cite>
respectively.</p>
<p>The weighting kernels are stored in the “adaptive_alpha” keyword value
in <cite>settings</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>Reduction settings, as returned by
<a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.reduction_settings" title="grig.resample_polynomial.ResamplePolynomial.reduction_settings"><code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.reduction_settings()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.calculate_minimum_points">
<span class="sig-name descname"><span class="pre">calculate_minimum_points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.calculate_minimum_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.calculate_minimum_points" title="Link to this definition">¶</a></dt>
<dd><p>Return the minimum number of points for a polynomial fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minimum_points</strong><span class="classifier">int</span></dt><dd><p>The minimum number of points for a polynomial fit</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.check_order">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.check_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.check_order" title="Link to this definition">¶</a></dt>
<dd><p>Check the order is of correct format and enough samples exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int or array_like of int (n_features,)</span></dt><dd><p>The polynomial order to fit, either supplied as an integer to be
applied over all dimensions, or as an array to give the order
in each dimension.</p>
</dd>
<dt><strong>n_features</strong><span class="classifier">int</span></dt><dd><p>The number of features (dimensions) of the sample coordinates.</p>
</dd>
<dt><strong>n_samples</strong><span class="classifier">int</span></dt><dd><p>The number of samples.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int or numpy.ndarray of int (n_features,)</span></dt><dd><p>The formatted polynomial order.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If there are too few samples for the desired order, or <cite>order</cite> is
not formatted correctly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.fit_tree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fit_tree</span></span><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.fit_tree" title="Link to this definition">¶</a></dt>
<dd><p>Return the fitting tree representative of points to fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>PolynomialTree</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.order">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">order</span></span><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.order" title="Link to this definition">¶</a></dt>
<dd><p>Return the order of polynomial fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int or numpy.ndarray (int)</span></dt><dd><p>A symmetrical order, or the order for each feature.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.pre_fit">
<span class="sig-name descname"><span class="pre">pre_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_region_coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.pre_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.pre_fit" title="Link to this definition">¶</a></dt>
<dd><p>Perform pre-fitting steps and build the fitting tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>Settings calculated via <cite>reduction_settings</cite> to be applied
if necessary.</p>
</dd>
<dt><strong>args</strong><span class="classifier">n-tuple</span></dt><dd><p>The call input arguments.</p>
</dd>
<dt><strong>adaptive_region_coordinates</strong><span class="classifier">numpy.ndarray (float), optional</span></dt><dd><p>The coordinates determined from a previous adaptive smoothing
algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.process_block">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">process_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.process_block"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.process_block" title="Link to this definition">¶</a></dt>
<dd><p>Run <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> on each block.</p>
<p>Utility function that parses the settings and tree objects to something
usable by the numba JIT compiled resampling functions.  This is not
meant to be called directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">2-tuple</span></dt><dd><p>A tuple of form (filename, iteration) where the filename is a
string pointing towards a previously saved pickle file containing
the relevant information for the reduction if required.  If set to
<cite>None</cite>, the arguments are retrieved from the
<cite>_global_resampling_values</cite> global parameter.</p>
</dd>
<dt><strong>block</strong><span class="classifier">int</span></dt><dd><p>The block index to process.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>results</strong><span class="classifier">9-tuple of numpy.ndarray</span></dt><dd><p>The first element contains the fit point indices to be fit.  For
the remaining elements, please see <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fits()</span></code> return
values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.reduction_settings">
<span class="sig-name descname"><span class="pre">reduction_settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distribution'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bounded'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_region_coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_threading</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.reduction_settings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.reduction_settings" title="Link to this definition">¶</a></dt>
<dd><p>Define a set of reduction instructions based on user input.</p>
<p>This method is responsible for determining, formatting, and checking
a number variables required for the resampling algorithm based on
user input.  For detailed descriptions of user options, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>smoothing</strong><span class="classifier">float or array_like (n_features,), optional</span></dt><dd></dd>
<dt><strong>relative_smooth</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>adaptive_threshold</strong><span class="classifier">float or array_like (n_features,), optional</span></dt><dd></dd>
<dt><strong>adaptive_algorithm</strong><span class="classifier">str, optional</span></dt><dd></dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>fit_threshold</strong><span class="classifier">float, optional</span></dt><dd></dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd></dd>
<dt><strong>edge_threshold</strong><span class="classifier">float or array_like (n_features,), optional</span></dt><dd></dd>
<dt><strong>edge_algorithm</strong><span class="classifier">str, optional</span></dt><dd></dd>
<dt><strong>order_algorithm</strong><span class="classifier">str, optional</span></dt><dd></dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>estimate_covariance</strong><span class="classifier">bool, optional</span></dt><dd></dd>
<dt><strong>jobs</strong><span class="classifier">int, optional</span></dt><dd></dd>
<dt><strong>adaptive_region_coordinates</strong><span class="classifier">array_like, optional</span></dt><dd></dd>
<dt><strong>use_threading</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of threads during multiprocessing.</p>
</dd>
<dt><strong>use_processes</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, force use of sub-processes during multiprocessing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>settings</strong><span class="classifier">dict</span></dt><dd><p>The reduction settings.  Also, stored as
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.fit_settings()</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grig.resample_polynomial.ResamplePolynomial.set_sample_tree">
<span class="sig-name descname"><span class="pre">set_sample_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#ResamplePolynomial.set_sample_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.ResamplePolynomial.set_sample_tree" title="Link to this definition">¶</a></dt>
<dd><p>Build the sample tree from input coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (float)</span></dt><dd><p>The input coordinates of shape (n_features, n_samples).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float or sequence (float), optional</span></dt><dd><p>The radius of the window around each fitting point used to
determine sample selection for fit.  If not supplied, will be
estimated using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_bins</strong><span class="classifier">int, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_percentile</strong><span class="classifier">int or float, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>window_estimate_oversample</strong><span class="classifier">int or float, optional</span></dt><dd><p>Used to estimate the <cite>window</cite> if not supplied using
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.estimate_feature_windows()</span></code>.</p>
</dd>
<dt><strong>leaf_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points at which to switch to brute-force during the
ball tree query algorithm.  See <cite>sklearn.neighbours.BallTree</cite>
for further details.</p>
</dd>
<dt><strong>large_data</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that this resampling algorithm will run on
a large set of data, and the ball tree should be created on
subsets of the data.</p>
</dd>
<dt><strong>check_memory</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, check the memory requirements for resampling the
supplied data.</p>
</dd>
<dt><strong>memory_buffer</strong><span class="classifier">float, optional</span></dt><dd><p>A fraction (positive or negative) with which to modify the memory
estimates for the process memory requirements.  Memory estimates
are scaled by the factor 1 + memory_buffer.</p>
</dd>
<dt><strong>distance_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keyword arguments passed into
<code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.neighbors.DistanceMetric()</span></code>.  The default is to use
the “minkowski” definition with <cite>p=2</cite>, i.e., the Euclidean
definition.  This is important in determining which samples lie
inside the window region of a resampling point, and when deriving
distance weighting factors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_polynomial.resamp">
<span class="sig-prename descclassname"><span class="pre">grig.resample_polynomial.</span></span><span class="sig-name descname"><span class="pre">resamp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">locations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negthresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_estimate_oversample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scaled'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distribution'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bounded'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">distance_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_polynomial.html#resamp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_polynomial.resamp" title="Link to this definition">¶</a></dt>
<dd><p>ResamplePolynomial data using local polynomial fitting.</p>
<p>Initializes and then calls the <a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial" title="grig.resample_polynomial.ResamplePolynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResamplePolynomial</span></code></a> class.  For
further details on all available parameters, please see
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__init__()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">ResamplePolynomial.__call__()</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong></dt><dd></dd>
<dt><strong>data</strong></dt><dd></dd>
<dt><strong>locations</strong></dt><dd></dd>
<dt><strong>error</strong></dt><dd></dd>
<dt><strong>mask</strong></dt><dd></dd>
<dt><strong>window</strong></dt><dd></dd>
<dt><strong>order</strong></dt><dd></dd>
<dt><strong>fix_order</strong></dt><dd></dd>
<dt><strong>robust</strong></dt><dd></dd>
<dt><strong>negthresh</strong></dt><dd></dd>
<dt><strong>window_estimate_bins</strong></dt><dd></dd>
<dt><strong>window_estimate_percentile</strong></dt><dd></dd>
<dt><strong>window_estimate_oversample</strong></dt><dd></dd>
<dt><strong>leaf_size</strong></dt><dd></dd>
<dt><strong>large_data</strong></dt><dd></dd>
<dt><strong>smoothing</strong></dt><dd></dd>
<dt><strong>relative_smooth</strong></dt><dd></dd>
<dt><strong>adaptive_threshold</strong></dt><dd></dd>
<dt><strong>adaptive_algorithm</strong></dt><dd></dd>
<dt><strong>fit_threshold</strong></dt><dd></dd>
<dt><strong>cval</strong></dt><dd></dd>
<dt><strong>edge_threshold</strong></dt><dd></dd>
<dt><strong>edge_algorithm</strong></dt><dd></dd>
<dt><strong>order_algorithm</strong></dt><dd></dd>
<dt><strong>error_weighting</strong></dt><dd></dd>
<dt><strong>estimate_covariance</strong></dt><dd></dd>
<dt><strong>is_covar</strong></dt><dd></dd>
<dt><strong>jobs</strong></dt><dd></dd>
<dt><strong>get_error</strong></dt><dd></dd>
<dt><strong>get_counts</strong></dt><dd></dd>
<dt><strong>get_weights</strong></dt><dd></dd>
<dt><strong>get_distance_weights</strong></dt><dd></dd>
<dt><strong>get_rchi2</strong></dt><dd></dd>
<dt><strong>get_cross_derivatives</strong></dt><dd></dd>
<dt><strong>get_offset_variance</strong></dt><dd></dd>
<dt><strong>distance_kwargs</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier">float or numpy.ndarray or n-tuple of (float or numpy.ndarray)</span></dt><dd><p>If a fit is performed at a single location, the output will consist
of int or float scalar values.  Multiple fits result in numpy arrays.
The exact output shape depends on the number of data sets, number of
fitted points, dimensions of the fit locations.  Assuming that all
get_* keywords are set to <cite>True</cite>, the output order is:</p>
<blockquote>
<div><p>results[0] = fitted values
results[1] = error on the fit
results[2] = sample counts for each fit
results[3] = total weight of all samples in fit
results[4] = total distance weight sum of all samples in fit
results[5] = reduced chi-squared statistic of the fit
results[6] = derivative mean squared cross products
results[7] = offset variance of fit from sample distribution</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-grig.resample_utils">
<span id="grig-resample-utils-module"></span><h3>grig.resample_utils module<a class="headerlink" href="#module-grig.resample_utils" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.apply_mask_to_set_arrays">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">apply_mask_to_set_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#apply_mask_to_set_arrays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.apply_mask_to_set_arrays" title="Link to this definition">¶</a></dt>
<dd><p>Set certain arrays to a fixed size based on a mask array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (N,)</span></dt><dd><p>Mask where <cite>True</cite> values indicate the associated element should be
kept, and <cite>False</cite> will result in exclusion from the output arrays.</p>
</dd>
<dt><strong>data</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The data array.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (n_terms, N)</span></dt><dd><p>The polynomial terms of the fit equation.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (N,).  If an array of size 1 is supplied,
it will be expanded to an array of <cite>counts</cite> size.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (N,).  If an array of size 1 is supplied,
it will be expanded to an array of <cite>counts</cite> size.</p>
</dd>
<dt><strong>counts</strong><span class="classifier">int</span></dt><dd><p>The number of <cite>True</cite> values in the mask.  Determines the output
size of all arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data_out, phi_out, error_out, weight_out</strong><span class="classifier">4-tuple of numpy.ndarray.</span></dt><dd><p>Resized arrays in which the last axis is of size <cite>counts</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.array_sum">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">array_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#array_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.array_sum" title="Link to this definition">¶</a></dt>
<dd><p>Return the sum of an array.</p>
<p>Utility function for fast <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> calculation of the sum of a 1-D
numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int or float</span></dt><dd><p>The sum of values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.calculate_adaptive_distance_weights_scaled">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_adaptive_distance_weights_scaled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_alpha</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#calculate_adaptive_distance_weights_scaled"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.calculate_adaptive_distance_weights_scaled" title="Link to this definition">¶</a></dt>
<dd><p>Returns distance weights based on offsets and scaled adaptive weighting.</p>
<p>Given a set of <span class="math notranslate nohighlight">\(K\)</span> dimensional <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(x\)</span>), a single
<cite>reference</cite> position (<span class="math notranslate nohighlight">\(x_{ref}\)</span>), and scaling factors
<cite>adaptive_alpha</cite> (<span class="math notranslate nohighlight">\(A\)</span>), returns the weighting factor:</p>
<div class="math notranslate nohighlight">
\[w(x) = exp
    \left(
    -\sum_{i=1}^{K} \sum_{j=1}^{K} {{\Delta x}_i A_{i,j} {\Delta x}_j}
    \right)\]</div>
<p>where <span class="math notranslate nohighlight">\({\Delta x}_k = x_{ref, k} - x_k\)</span> for dimension <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>Unlike <a class="reference internal" href="#grig.resample_utils.calculate_distance_weights_from_matrix" title="grig.resample_utils.calculate_distance_weights_from_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_distance_weights_from_matrix()</span></code></a>, this function
applies the function over multiple sets.  In this context, a single set
will contain the same independent values (coordinates) as all other sets
in a reduction, but the dependent data values may vary between sets.
Therefore, it is necessary for the adaptive weighting values to also vary
between sets.</p>
<p>The algorithm is equivalent to
<a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_shaped" title="grig.resample_utils.calculate_adaptive_distance_weights_shaped"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_shaped()</span></code></a> except when no rotation
is applied, and therefore only a 1-dimensional array, rather than a matrix,
is required to perform the transform.  The third axis of <cite>adaptive_alpha</cite>
is set to one to allow <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> to compile the function successfully,
also indicating that there is no need to store the off-diagonal elements
since they are all zero.  All stretching will therefore occur along the
dimensional axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd></dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd></dd>
<dt><strong>adaptive_alpha</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(n_coordinates, n_sets, 1, n_dimensions) array containing the scaled
adaptive weighting factors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The distance weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.calculate_adaptive_distance_weights_shaped">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_adaptive_distance_weights_shaped</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape_matrices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#calculate_adaptive_distance_weights_shaped"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.calculate_adaptive_distance_weights_shaped" title="Link to this definition">¶</a></dt>
<dd><p>Returns distance weights based on offsets and shaped adaptive weighting.</p>
<p>Given a set of <span class="math notranslate nohighlight">\(K\)</span> dimensional <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(x\)</span>), a single
<cite>reference</cite> position (<span class="math notranslate nohighlight">\(o\)</span>), and the symmetric matrix <cite>shape_matrices</cite>
(<span class="math notranslate nohighlight">\(A\)</span>), returns the weighting factor:</p>
<div class="math notranslate nohighlight">
\[w(x) = exp(-\Delta x^T A^{-1} \Delta x)\]</div>
<p>where <span class="math notranslate nohighlight">\({\Delta x}_k = o_k - x_k\)</span> for dimension <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>This function is applied to multiple coordinates over multiple sets.  In
this context, a single set will contain the same independent values
(coordinates) as all other sets in a reduction, but the dependent data
values may vary between sets.  Therefore, it is necessary for the adaptive
weighting values to also vary between sets.</p>
<p>Unlike <a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_scaled" title="grig.resample_utils.calculate_adaptive_distance_weights_scaled"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_scaled()</span></code></a>, the matrix
<span class="math notranslate nohighlight">\(A\)</span> allows for the kernel weighting function to be stretched along
arbitrarily rotated orthogonal axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd></dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd></dd>
<dt><strong>shape_matrices</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(n_coordinates, n_sets, n_dimensions, n_dimensions) array containing
the shaped adaptive weighting matrix for all coordinates and sets.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The distance weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.calculate_distance_weights">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_distance_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#calculate_distance_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.calculate_distance_weights" title="Link to this definition">¶</a></dt>
<dd><p>Returns a distance weighting based on coordinate offsets.</p>
<p>Given a set of <span class="math notranslate nohighlight">\(K\)</span> dimensional <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(x\)</span>), a single
<cite>reference</cite> position (<span class="math notranslate nohighlight">\(x_{ref}\)</span>), and the scaling factor <cite>alpha</cite>
(<span class="math notranslate nohighlight">\(\alpha\)</span>), returns the weighting factor:</p>
<div class="math notranslate nohighlight">
\[w(x) = exp \left(
           \sum_{k=1}^{K}{\frac{-(x_{ref, k} - x_k)^2}{\alpha_k}}
           \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, N)</span></dt><dd><p>An array of N coordinates in n_dimensions.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference position from which to determine distance offsets for the
weighting function.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">numpy.ndarray (1 or n_dimensions,)</span></dt><dd><p>The distance scaling factor.  If an array of size 1 is supplied, it
will be applied over all dimensions.  Otherwise, a value must be
provided for each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The distance weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>alpha</cite> relates to the standard deviation (<span class="math notranslate nohighlight">\(\sigma\)</span>) in a normal
distribution as <span class="math notranslate nohighlight">\(\alpha = 2\sigma^2\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.calculate_distance_weights_from_matrix">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_distance_weights_from_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#calculate_distance_weights_from_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.calculate_distance_weights_from_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Returns distance weights based on coordinate offsets and matrix operation.</p>
<p>Given a set of <span class="math notranslate nohighlight">\(K\)</span> dimensional <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(x\)</span>), a single
<cite>reference</cite> position (<span class="math notranslate nohighlight">\(o\)</span>), and the symmetric matrix <cite>alpha_matrix</cite>
(<span class="math notranslate nohighlight">\(A\)</span>), returns the weighting factor:</p>
<div class="math notranslate nohighlight">
\[w(x) = exp(-\Delta x^T A \Delta x)\]</div>
<p>where <span class="math notranslate nohighlight">\({\Delta x}_k = o_k - x_k\)</span> for dimension <span class="math notranslate nohighlight">\(k\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>An array of N coordinates in n_dimensions.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference position from which to determine distance offsets for the
weighting function.</p>
</dd>
<dt><strong>alpha_matrix</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>Defines the matrix operation to perform on the coordinate offsets.
Note that in this implementation, it should be a symmetric matrix
such that <span class="math notranslate nohighlight">\(A = A^T\)</span>.  As such, only the upper triangle is
iterated over and any off-diagonal elements in the lower triangle are
ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The distance weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.calculate_fitting_weights">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">calculate_fitting_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">errors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#calculate_fitting_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.calculate_fitting_weights" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the final weighting factor based on errors and other weights.</p>
<p>If <cite>error_weighting</cite> is applied, the return value is <cite>weights</cite> / <cite>error`^2.
Otherwise, simply returns `weights</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>errors</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>1-sigma error values to apply to weighting.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>Other weighting factors, not including any type of error weighting.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool</span></dt><dd><p>If False, returns <cite>weights</cite>, otherwise returns weights / errors^2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_weighting</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The final fitting weights.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The square root of the weight is used in the polynomial system of
equations rather than the actual weight due to how the least-squares
solution is derived.</p>
<p>For the linear system of equations A.x = B, we are solving
(A^T.W.A).C = A^T.W.B, where C are the coefficients we wish to find.
If we set X = sqrt(W).A, and Y = sqrt(W).B, this is the same as
(X^T.X).C = X^T.Y, which can be solved easily.  Another way of thinking
about it is that we are minimizing the squared residuals (y - f(x))^2.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_edge_with_box">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_edge_with_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_edge_with_box"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_edge_with_box" title="Link to this definition">¶</a></dt>
<dd><p>Defines a hyperrectangle edge around a coordinate distribution.</p>
<p>Given a distribution (<span class="math notranslate nohighlight">\(X\)</span>) of <span class="math notranslate nohighlight">\(N\)</span> samples in <span class="math notranslate nohighlight">\(K\)</span>
dimensions, the center of mass for dimension <span class="math notranslate nohighlight">\(k\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\bar{X}_{k} = \frac{1}{N} \sum_{i=1}^{N}{X_{ik}}\]</div>
<p>The hypercube center is at <span class="math notranslate nohighlight">\(\bar{X}\)</span> and its width in each
dimension <span class="math notranslate nohighlight">\(k\)</span> is <span class="math notranslate nohighlight">\(2\beta_k\)</span> where
<span class="math notranslate nohighlight">\(\beta = 1 - \text{threshold}\)</span>.  Note that the resampling algorithm
scales all coordinates to a window parameter such that
<span class="math notranslate nohighlight">\(|X_k| \leq 1\)</span>, and the <cite>threshold</cite> parameter therefore defines a
fraction of the window in the range <span class="math notranslate nohighlight">\(0 &lt; \text{threshold} &lt; 1\)</span>.  If
threshold[k] = 0 or 1, then no edge will be defined for dimension
<span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>If this definition the “edge” for dimension <span class="math notranslate nohighlight">\(k\)</span> is at
<span class="math notranslate nohighlight">\(\bar{X}_k \pm \beta_k\)</span> and <cite>reference</cite> (<span class="math notranslate nohighlight">\(X_{ref}\)</span>) is
considered inside the edge if:</p>
<div class="math notranslate nohighlight">
\[| \bar{X}_k - X_{ref, k} | \leq \beta_k, \, \forall k\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> values exclude the corresponding sample from the
center-of-mass calculation.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>Defines the half-width dimensions (1 - threshold) of the hyperrectangle
centered on the coordinate center of mass in units of the resampling
window parameter.  Must be in the range 0 &lt; threshold &lt; 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inside</strong><span class="classifier">bool</span></dt><dd><p><cite>True</cite> if <cite>reference</cite> is inside the distribution “edge” and <cite>False</cite>
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_edge_with_distribution">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_edge_with_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_edge_with_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_edge_with_distribution" title="Link to this definition">¶</a></dt>
<dd><p>Defines an edge based on statistical deviation from a sample distribution.</p>
<p>Given a sample distribution (<span class="math notranslate nohighlight">\(X\)</span>) of <cite>coordinates</cite>, the deviation of
a <cite>reference</cite> coordinate <span class="math notranslate nohighlight">\(X_{ref}\)</span> from the mean sample distribution
<span class="math notranslate nohighlight">\(\bar{X}\)</span> is given as:</p>
<div class="math notranslate nohighlight">
\[\sigma_{ref} = \sqrt{(X_{ref} - \bar{X})^{T} \Sigma^{-1}
                     (X_{ref} - \bar{X})}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sigma\)</span> is the sample covariance of <span class="math notranslate nohighlight">\(X\)</span>.  In this
definition, the “edge” of the distribution is defined at
<span class="math notranslate nohighlight">\(\beta = 1 / threshold\)</span> so that reference locations where
<span class="math notranslate nohighlight">\(\sigma_{ref} \leq \beta\)</span> are considered inside the distribution
edge.  For example, setting <cite>threshold</cite> = 2 will return a <cite>False</cite> value if
<span class="math notranslate nohighlight">\(\sigma_{ref} &gt; 0.5\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> values exclude the corresponding sample from any
distribution statistics.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int or float</span></dt><dd><p>The “edge” of the distribution is given by 1 / threshold.  If the
deviation of the reference coordinate from the distribution mean is
greater than the edge, a <cite>False</cite> value will be returned.  Setting
threshold to zero results in an edge at infinity, i.e., all reference
coordinates will be considered inside the distribution edge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inside</strong><span class="classifier">bool</span></dt><dd><p><cite>True</cite> if <cite>reference</cite> is inside the distribution “edge” and <cite>False</cite>
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_edge_with_ellipsoid">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_edge_with_ellipsoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_edge_with_ellipsoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_edge_with_ellipsoid" title="Link to this definition">¶</a></dt>
<dd><p>Defines an ellipsoid edge around a coordinate distribution.</p>
<p>Given a distribution (<span class="math notranslate nohighlight">\(X\)</span>) of <span class="math notranslate nohighlight">\(N\)</span> samples in <span class="math notranslate nohighlight">\(K\)</span>
dimensions, the center of mass for dimension <span class="math notranslate nohighlight">\(k\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\bar{X}_{k} = \frac{1}{N} \sum_{i=1}^{N}{X_{ik}}\]</div>
<p>The ellipsoid center is at <span class="math notranslate nohighlight">\(\bar{X}\)</span> with principle axes given by
<span class="math notranslate nohighlight">\(\beta\)</span>, where <span class="math notranslate nohighlight">\(\beta = 1 - \text{threshold}\)</span>.  Note that
the resampling algorithm scales all coordinates to a window parameter such
that <span class="math notranslate nohighlight">\(|X_k| \leq 1\)</span>, and the <cite>threshold</cite> parameter therefore defines
a fraction of the window in the range <span class="math notranslate nohighlight">\(0 &lt; \text{threshold} &lt; 1\)</span>.  If
threshold[k] = 0 or 1, then no edge will be defined for dimension
<span class="math notranslate nohighlight">\(k\)</span>, and the ellipsoid definition will only apply over remaining
dimensions (dimension <span class="math notranslate nohighlight">\(k\)</span> will be ignored in all calculations).</p>
<p>A reference coordinate (<span class="math notranslate nohighlight">\(X_{ref}\)</span>) is considered inside the ellipsoid
edge if:</p>
<div class="math notranslate nohighlight">
\[\sum_{k=1}^{K}{\frac{(X_{ref, k} - \bar{X}_k)^2}{\beta_k^2}} \leq 1\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> values exclude the corresponding sample from the
center-of-mass calculation.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>Defines the principle axes (1 - threshold) of an ellipsoid centered on
the coordinate center of mass in units of the resampling window
parameter.  Must be in the range 0 &lt; threshold &lt; 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inside</strong><span class="classifier">bool</span></dt><dd><p><cite>True</cite> if <cite>reference</cite> is inside the distribution “edge” and <cite>False</cite>
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_edge_with_range">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_edge_with_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_edge_with_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_edge_with_range" title="Link to this definition">¶</a></dt>
<dd><p>Defines an edge based on the range of coordinates in each dimension.</p>
<p>Given a distribution of sample <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(X\)</span>), and a <cite>reference</cite>
position (<span class="math notranslate nohighlight">\(X_{ref}\)</span>) in <span class="math notranslate nohighlight">\(K\)</span> dimensions, check for each
dimension <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="math notranslate nohighlight">
\[\{-\beta_k, \beta_k\} \in
[min(X_k - X_{ref, k}), max(X_k - X_{ref, k})]
, \, \forall k\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta = 1 - \text{threshold}\)</span>.  In order words, in each
dimension <span class="math notranslate nohighlight">\(k\)</span>, there must be at least one member of <span class="math notranslate nohighlight">\(X_k\)</span> at
a distance of <span class="math notranslate nohighlight">\(\beta_k\)</span> from <span class="math notranslate nohighlight">\(X_{ref, k}\)</span> for both the
positive and negative directions along <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>Note that the resampling algorithm scales all coordinates to a window
parameter such that <span class="math notranslate nohighlight">\(|X_k| \leq 1\)</span>, and the <cite>threshold</cite> parameter
therefore defines a fraction of the window in the range
<span class="math notranslate nohighlight">\(0 &lt; \text{threshold} &lt; 1\)</span>.  If threshold[k] &lt; 0 or theshold &gt; 1,
then no check will be performed for dimension <span class="math notranslate nohighlight">\(k\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> values exclude the corresponding sample from the
range check.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>Defines the threshold.  Must be in the range 0 &lt; threshold &lt; 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inside</strong><span class="classifier">bool</span></dt><dd><p><cite>True</cite> if <cite>reference</cite> is inside the distribution “edge” and <cite>False</cite>
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_edges">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_edges" title="Link to this definition">¶</a></dt>
<dd><p>Determine whether a reference position is within a distribution “edge”.</p>
<p>The purpose of this function is to allow the resampling algorithm to
determine whether a fit should be performed at a <cite>reference</cite> location
given a sample distribution of <cite>coordinates</cite>.  If a fit is attempted too
far from the mean sample distribution, it will lead to a misleading result
which becomes more pronounced at higher fit orders.</p>
<p>Therefore, the sample distribution is assigned an “edge” based on one of
four definitions.  If the <cite>reference</cite> position is outside of this edge, a
<cite>False</cite> value will be returned, and no fitting will occur.</p>
<p>For all edge definition algorithms, the <cite>threshold</cite> parameter will
determine the distance of the edge from the sample mean.  As <cite>threshold</cite>
is increased, the edge approaches the sample mean resulting in a more
severe clipping of fit locations away from the center of a distribution.
If <cite>threshold</cite> = 0, no edge clipping will occur.</p>
<p>Since the main engine of the resampling algorithm relies on <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code>,
the edge <cite>algorithm</cite> should be supplied as an integer.  Please see the
relevant function listed below for further details on how the “edge” is
defined.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>algorithm</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_edge_with_distribution" title="grig.resample_utils.check_edge_with_distribution"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_distribution()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_edge_with_ellipsoid" title="grig.resample_utils.check_edge_with_ellipsoid"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_ellipsoid()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_edge_with_box" title="grig.resample_utils.check_edge_with_box"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_box()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_edge_with_range" title="grig.resample_utils.check_edge_with_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_range()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>Generally, algorithms are ordered from most to least robust, and slowest to
fastest, so, the default (1) is considered the most robust (although
slowest) of the available algorithms.</p>
<p>When dealing with more than one dimension, the
<a class="reference internal" href="#grig.resample_utils.check_edge_with_distribution" title="grig.resample_utils.check_edge_with_distribution"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_distribution()</span></code></a> algorithm is recommended as it
accounts for the shape of the distribution.  If the sample distribution is
unknown (as opposed to a set of uniformly spaced coordinates), there is a
chance for some samples to be (or to approach) a collinear distribution.
Attempting a fit at any location in a tangential direction away from the
distribution would likely result in a very poor fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate to test.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,)</span></dt><dd><p>A mask where <cite>True</cite> values indicate a sample should be included in
the edge determination.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A threshold parameter determining how close an edge should be to the
center of the distribution.  Higher values result in an edge closer to
the sample mean.  A value should be provided for each dimension.  A
zero value in any dimension will result in an infinite edge for that
dimension.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">int, optional</span></dt><dd><p>Integer specifying which edge definition to use.  Please see above for
the associated functions.  Invalid choices will disable edge checking.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inside</strong><span class="classifier">bool</span></dt><dd><p><cite>True</cite> if the reference coordinate is inside the edge of the sample
distribution, and <cite>False</cite> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_orders">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_orders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_orders"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_orders" title="Link to this definition">¶</a></dt>
<dd><p>Checks the sample distribution is suitable for a polynomial fit order.</p>
<p>For a polynomial fit to be successful at a given order, one needs to
ensure that the sample distribution is suitable for such a fit.  At a
minimum, there need to be enough samples to derive a fit.  However, unless
the samples are known to be distributed in such a way where a fit is always
possible (such as regularly spaced samples), there is the possibility that
the fit may be under-determined.  For example, it is not possible to
perform any other fit than the mean of sample values (order 0) if the
samples all share the same coordinate.</p>
<p>This problem is compounded by the use of <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> which does not allow
any exception handling.  If a fit fails at a single reference position,
the whole algorithm will fail.</p>
<p>There are several algorithms available, ordered in decreasing robustness,
but increasing speed.  The chosen algorithm must be supplied using an
integer label (because <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code>).  Please see the relevant function
listed in the table below for a more detailed description of each.  The
<cite>order_algorithm</cite> parameter is supplied to the main resampling algorithm
during <cite>__init__</cite> and is used to select the relevant algorithm.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>algorithm</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>order_algorithm</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_orders_with_bounds" title="grig.resample_utils.check_orders_with_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_bounds()</span></code></a></p></td>
<td><p>‘bounded’</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_orders_without_bounds" title="grig.resample_utils.check_orders_without_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_without_bounds()</span></code></a></p></td>
<td><p>‘extrapolate’</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><a class="reference internal" href="#grig.resample_utils.check_orders_with_counts" title="grig.resample_utils.check_orders_with_counts"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_counts()</span></code></a></p></td>
<td><p>‘counts’</p></td>
</tr>
</tbody>
</table>
<p>Generally, <a class="reference internal" href="#grig.resample_utils.check_orders_with_bounds" title="grig.resample_utils.check_orders_with_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_bounds()</span></code></a> is the most robust and ensures
that a fit will not only succeed, but is not likely to deviate widely from
the expected result.  The <a class="reference internal" href="#grig.resample_utils.check_orders_without_bounds" title="grig.resample_utils.check_orders_without_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_without_bounds()</span></code></a> function
should also allow fits to succeed, but allow fits to be generated away from
the sample distribution.  This may be desirable, for example, if one is
resampling an image and wishes to perform fits close to the edge.
Finally, <a class="reference internal" href="#grig.resample_utils.check_orders_with_counts" title="grig.resample_utils.check_orders_with_counts"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_counts()</span></code></a> is fast, but there is a decent
possibility that the fit will fail if the user cannot guarantee that the
samples are distributed appropriately.</p>
<p>In rare cases, a distribution of collinear samples, not aligned along any
dimensional axis may pass the <cite>check_orders</cite> test causing resampling
algorithm to fail.  In this case, please consider using
<a class="reference internal" href="#grig.resample_utils.check_edge_with_distribution" title="grig.resample_utils.check_edge_with_distribution"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edge_with_distribution()</span></code></a> to perform such a check.  This may
be invoked by supplying <cite>edge_algorithm=’distribution’</cite> during the
initialization of the main resampling algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>algorithm</strong><span class="classifier">int</span></dt><dd><p>An integer specifying the order checking algorithm to use.  If an
invalid option is supplied (not listed in the table above), the return
value of -1 will abort any subsequent fitting.</p>
</dd>
<dt><strong>orders</strong><span class="classifier">numpy.ndarray of int</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.  This serves as an upper limit for the check.  If the
samples are distributed in a way that allows for a fit to be performed
using <cite>orders</cite>, the return value will also be <cite>orders</cite>.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.  Not used by the <cite>counts</cite>
algorithm, but must still be supplied as an array with the correct
dimensions.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The coordinates of the point at which to perform a fit.  Only required
by the ‘bounded’ algorithm, but a value of the correct array shape must
still be supplied.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,), optional</span></dt><dd><p>An optional mask where <cite>False</cite> values indicate the associated sample
should not be included in determining the maximum order.</p>
</dd>
<dt><strong>minimum_points</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of points required to perform a fit of the desired
order, optionally passed in for speed if pre-calculated.  Only used by
the ‘counts’ algorithm.</p>
</dd>
<dt><strong>required</strong><span class="classifier">bool, optional</span></dt><dd><p>If required is <cite>False</cite>, the maximum available order given the
distribution will be returned (up to a maximum of <cite>orders</cite>).  If
required is <cite>True</cite>, and the maximum available order is less than
<cite>orders</cite>, the first element of the return value will be set to -1,
indicating the criteria was not met.</p>
</dd>
<dt><strong>counts</strong><span class="classifier">int, optional</span></dt><dd><p>This is required by the ‘counts’ algorithm.  If <cite>counts</cite> &lt; 0, it will
be determined by sum(mask).  If counts is less than zero, and a mask
is not supplied, not fit will be performed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maximum_orders</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (n_dimensions,) based on whether a single
<cite>orders</cite> was passed in for all dimensions, or each dimension has a
separate order requirement.  If <cite>required</cite> was set to <cite>True</cite>, and the
sample distribution did not allow for the requested order, the first
element will be set to -1.  Otherwise, if <cite>required</cite> was <cite>False</cite>, the
maximum order for each dimension will be returned.  If a single <cite>orders</cite>
was to be applied over all dimensions, the return value will also be
of size 1, but contains the min(maximum_order) over all dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_orders_with_bounds">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_orders_with_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_orders_with_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_orders_with_bounds" title="Link to this definition">¶</a></dt>
<dd><p>Checks maximum order for sample coordinates bounding a reference.</p>
<p>Given the <cite>coordinates</cite> of a sample distribution (<span class="math notranslate nohighlight">\(X\)</span>), a <cite>reference</cite>
position (<span class="math notranslate nohighlight">\(X_{ref}\)</span>), and the desired <cite>orders</cite> of fit (<span class="math notranslate nohighlight">\(o\)</span>),
returns the maximum available order of fit.</p>
<p>For dimension <span class="math notranslate nohighlight">\(k\)</span> define the sets of unique values:</p>
<div class="math notranslate nohighlight">
\[\begin{split}s_k^- = \{ x \in X_k |\, x &lt; X_{ref, k} \} \\
s_k^+ = \{ x \in X_k |\, x &gt; X_{ref, k} \}\end{split}\]</div>
<p>The maximum order is then given as:</p>
<div class="math notranslate nohighlight">
\[o_k^{max} = min\{ |s_k^-|, |s_k^+|, o_k \}\]</div>
<p>where <span class="math notranslate nohighlight">\(|.|\)</span> represents the cardinality (size) of the set.</p>
<p>For example, consider a 1-dimensional set of coordinates:</p>
<div class="math notranslate nohighlight">
\[X = [1, 1, 1, 2, 3, 4, 5, 5, 5, 5, 6]\]</div>
<p>and we wish to perform an order=3 polynomial fit at <span class="math notranslate nohighlight">\(X_{ref}=2.5\)</span>.
There are 4 unique values of <span class="math notranslate nohighlight">\(X &gt; X_{ref}\)</span> (<span class="math notranslate nohighlight">\(\{3, 4, 5, 6\}\)</span>),
but only 2 unique values of <span class="math notranslate nohighlight">\(X &lt; X_{ref}\)</span> (<span class="math notranslate nohighlight">\(\{1, 2\}\)</span>).  The
return value will be 2, indicating that only a 2nd order polynomial fit
should be attempted.  If a 1st order polynomial fit was requested, the
return value would be 1 since there are enough points less than and greater
than the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orders</strong><span class="classifier">numpy.ndarray of int</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.  This serves as an upper limit for the check.  If the
samples are distributed in a way that allows for a fit to be performed
using <cite>orders</cite>, the return value will also be <cite>orders</cite>.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_coordinates,), optional</span></dt><dd><p>An optional mask where <cite>False</cite> values indicate the associated sample
should not be included in determining the maximum order.</p>
</dd>
<dt><strong>required</strong><span class="classifier">bool, optional</span></dt><dd><p>If required is <cite>False</cite>, the maximum available order given the
distribution will be returned (up to a maximum of <cite>orders</cite>).  If
required is <cite>True</cite>, and the maximum available order is less than
<cite>orders</cite>, the first element of the return value will be set to -1,
indicating the criteria was not met.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maximum_orders</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (n_dimensions,) based on whether a single
<cite>orders</cite> was passed in for all dimensions, or each dimension has a
separate order requirement.  If <cite>required</cite> was set to <cite>True</cite>, and the
sample distribution did not allow for the requested order, the first
element will be set to -1.  Otherwise, if <cite>required</cite> was <cite>False</cite>, the
maximum order for each dimension will be returned.  If a single <cite>orders</cite>
was to be applied over all dimensions, the return value will also be
of size 1, but contains the min(maximum_order) over all dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_orders_with_counts">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_orders_with_counts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dimensions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_orders_with_counts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_orders_with_counts" title="Link to this definition">¶</a></dt>
<dd><p>Checks maximum order based only on the number of samples.</p>
<p>For <span class="math notranslate nohighlight">\(N\)</span> samples of <span class="math notranslate nohighlight">\(K\)</span> dimensional data, the minimum number of
samples required to perform a polynomial fit with <cite>orders</cite> <span class="math notranslate nohighlight">\(o\)</span> is:</p>
<div class="math notranslate nohighlight">
\[N_{min} = \prod_{k=1}^{K}{(o_k + 1)}\]</div>
<p>if <span class="math notranslate nohighlight">\(o_k = o_0, \, \forall k\)</span>, then it is possible to suggest a lower
order over all dimensions in the case where <span class="math notranslate nohighlight">\(N &lt; N_{min}\)</span>.  This
is given as:</p>
<div class="math notranslate nohighlight">
\[o_k^{max} = min\{ floor(N ^ {1 / K} - 1), o_k \}\]</div>
<p>The suggested maximum order is returned by setting the <cite>required</cite> keyword
to <cite>False</cite>.  If the orders vary between dimensions or <cite>required</cite> is <cite>True</cite>,
the value of <span class="math notranslate nohighlight">\(o_0\)</span> is set to -1 indicating a polynomial fit of the
desired order is not possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orders</strong><span class="classifier">numpy.ndarray of int</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.  This serves as an upper limit for the check.  If the
samples are distributed in a way that allows for a fit to be performed
using <cite>orders</cite>, the return value will also be <cite>orders</cite>.</p>
</dd>
<dt><strong>counts</strong><span class="classifier">int</span></dt><dd><p>The number of samples available for the fit.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_coordinates,), optional</span></dt><dd><p>An optional mask where <cite>False</cite> values indicate the associated sample
should not be included in determining the maximum order.  The <cite>counts</cite>
parameter will be ignored in favor of sum(mask).</p>
</dd>
<dt><strong>minimum_points</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of points required to perform a fit of the desired
order, optionally passed in for speed.</p>
</dd>
<dt><strong>n_dimensions</strong><span class="classifier">int, optional</span></dt><dd><p>If <cite>orders</cite> was supplied as an array of size 1, but should be applied
over multiple dimensions, the number of dimensions should be supplied.
Otherwise, the number of dimensions is taken to be equal to the number
of orders.</p>
</dd>
<dt><strong>required</strong><span class="classifier">bool, optional</span></dt><dd><p>If required is <cite>False</cite>, the maximum available order given the
distribution will be returned (up to a maximum of <cite>orders</cite>).  If
required is <cite>True</cite>, and the maximum available order is less than
<cite>orders</cite>, the first element of the return value will be set to -1,
indicating the criteria was not met.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maximum_orders</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (n_dimensions,) based on whether a single
<cite>orders</cite> was passed in for all dimensions, or each dimension has a
separate order requirement.  If <cite>required</cite> was set to <cite>True</cite>, and the
sample distribution did not allow for the requested order, the first
element will be set to -1.  Unlike <a class="reference internal" href="#grig.resample_utils.check_orders_with_bounds" title="grig.resample_utils.check_orders_with_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_bounds()</span></code></a> or
<a class="reference internal" href="#grig.resample_utils.check_orders_without_bounds" title="grig.resample_utils.check_orders_without_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_without_bounds()</span></code></a>, a suggested maximum order can only
be returned by setting <cite>required</cite> to <cite>False</cite> if <cite>orders</cite> are equal
in all dimensions.  Otherwise, it is impossible to know which dimension
the order should be reduced for.  In this case, the first element of
<cite>maximum_orders</cite> will be set to -1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.check_orders_without_bounds">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">check_orders_without_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#check_orders_without_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.check_orders_without_bounds" title="Link to this definition">¶</a></dt>
<dd><p>Checks maximum order based on unique samples, irrespective of reference.</p>
<p>Given the <cite>coordinates</cite> of a sample distribution (<span class="math notranslate nohighlight">\(X\)</span>), and the
desired <cite>orders</cite> of fit (<span class="math notranslate nohighlight">\(o\)</span>), returns the maximum available order of
fit.  Unlike <a class="reference internal" href="#grig.resample_utils.check_orders_with_bounds" title="grig.resample_utils.check_orders_with_bounds"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders_with_bounds()</span></code></a>, the location of the fit
is unimportant.  All that is required is for enough unique sample
coordinates to be available for fitting.</p>
<p>For dimension <span class="math notranslate nohighlight">\(k\)</span>, the maximum fit order is given as:</p>
<div class="math notranslate nohighlight">
\[o_k^{max} = min\{ |X_k| - 1, o_k \}\]</div>
<p>where <span class="math notranslate nohighlight">\(|.|\)</span> represents the cardinality (size) of the set.</p>
<p>For example, consider a 1-dimensional set of coordinates:</p>
<div class="math notranslate nohighlight">
\[X = [1, 1, 1, 2, 3, 4]\]</div>
<p>The maximum order of fit would be 3 since there are 4 unique values
(1, 2, 3, 4).  Therefore, when <cite>orders</cite> &gt;= 3, the return value would be 3.
For <cite>orders</cite> &lt; 3, <cite>orders</cite> would be returned.</p>
<p>If we had a 2-dimensional set of data:</p>
<div class="math notranslate nohighlight">
\[X = [(1, 0), (1, 0), (1, 0), (2, 1), (3, 1), (4, 1)]\]</div>
<p>The maximum order of fit would be 3 in the first dimension, and 1 in the
second.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orders</strong><span class="classifier">numpy.ndarray of int</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.  This serves as an upper limit for the check.  If the
samples are distributed in a way that allows for a fit to be performed
using <cite>orders</cite>, the return value will also be <cite>orders</cite>.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_coordinates,), optional</span></dt><dd><p>An optional mask where <cite>False</cite> values indicate the associated sample
should not be included in determining the maximum order.</p>
</dd>
<dt><strong>required</strong><span class="classifier">bool, optional</span></dt><dd><p>If required is <cite>False</cite>, the maximum available order given the
distribution will be returned (up to a maximum of <cite>orders</cite>).  If
required is <cite>True</cite>, and the maximum available order is less than
<cite>orders</cite>, the first element of the return value will be set to -1,
indicating the criteria was not met.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maximum_orders</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (1,) or (n_dimensions,) based on whether a single
<cite>orders</cite> was passed in for all dimensions, or each dimension has a
separate order requirement.  If <cite>required</cite> was set to <cite>True</cite>, and the
sample distribution did not allow for the requested order, the first
element will be set to -1.  Otherwise, if <cite>required</cite> was <cite>False</cite>, the
maximum order for each dimension will be returned.  If a single <cite>orders</cite>
was to be applied over all dimensions, the return value will also be
of size 1, but contains the min(maximum_order) over all dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.convert_to_numba_list">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">convert_to_numba_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#convert_to_numba_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.convert_to_numba_list" title="Link to this definition">¶</a></dt>
<dd><p>Converts a Python iterable to a Numba list for use in jitted functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>thing</strong><span class="classifier">iterable</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numba.typed.List()</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.coordinate_covariance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">coordinate_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#coordinate_covariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.coordinate_covariance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the covariance of a distribution.</p>
<p>Given the sample distribution of <span class="math notranslate nohighlight">\(N\)</span> <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(X\)</span>) in
<span class="math notranslate nohighlight">\(K\)</span> dimensions, the sample covariance is given as:</p>
<div class="math notranslate nohighlight">
\[\Sigma = E[(X - E[X])(X - E[X])^T]\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sigma\)</span> is a <span class="math notranslate nohighlight">\(K \times K\)</span> matrix and <span class="math notranslate nohighlight">\(E\)</span> denotes
the expected value.  In the general case where the expected value of
<span class="math notranslate nohighlight">\(X\)</span> is unknown and derived from the distribution itself, the
covariance of the samples between dimension <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\Sigma_{ij} = \frac{1}{N - M} \sum_{k=1}^{N}
              {(X_{ki} - \bar{X}_i)(X_{kj} - \bar{X}_j)}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is the number of degrees of freedom lost (<cite>dof</cite>) in
determining the <cite>mean</cite> (<span class="math notranslate nohighlight">\(\bar{X}\)</span>).  If the <cite>mean</cite> is not provided,
it will be calculated using <a class="reference internal" href="#grig.resample_utils.coordinate_mean" title="grig.resample_utils.coordinate_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_mean()</span></code></a> in which case the
default <cite>dof</cite> of 1 is appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinates of the distribution.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">numpy.ndarray (n_dimensions,), optional</span></dt><dd><p>The mean of the coordinate distribution in each dimension.  If not
provided, the expected value in each dimension will be calculated
using <a class="reference internal" href="#grig.resample_utils.coordinate_mean" title="grig.resample_utils.coordinate_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_mean()</span></code></a>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray (n_coordinates,), optional</span></dt><dd><p>An array of bool values where <cite>True</cite> indicates a coordinate should
be included in the calculation, and <cite>False</cite> indicates that a coordinate
should be ignored.  By default, all coordinates are included.</p>
</dd>
<dt><strong>dof</strong><span class="classifier">int or float, optional</span></dt><dd><p>The lost degrees of freedom, typically 1 to indicate that the
population mean is not known and is replaced by the sample mean.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>covariance</strong><span class="classifier">numpy.ndarray of numpy.float64 (n_dimensions, n_dimensions)</span></dt><dd><p>The covariance of the sample distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.coordinate_mean">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">coordinate_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#coordinate_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.coordinate_mean" title="Link to this definition">¶</a></dt>
<dd><p>Returns the mean coordinate of a distribution.</p>
<p>Given a distribution of <span class="math notranslate nohighlight">\(N\)</span> coordinates in <span class="math notranslate nohighlight">\(K\)</span> dimensions, the
mean coordinate in dimension <span class="math notranslate nohighlight">\(k\)</span> is given as:</p>
<div class="math notranslate nohighlight">
\[\bar{x_k} = \frac{\sum_{i=1}^{N}{w_i x_{k,i}}}{\sum_{i=1}^{N}{w_i}}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i = 0\)</span> if mask[i] is <cite>False</cite> and <span class="math notranslate nohighlight">\(w_i = 1\)</span> if
mask[i] is <cite>True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinate distribution.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_coordinates,), optional</span></dt><dd><p>An array of bool values where <cite>True</cite> indicates a coordinate should
be included in the calculation, and <cite>False</cite> indicates that a coordinate
should be ignored.  By default, all coordinates are included.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean_coordinate</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The mean coordinate of the distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.covariance_matrix_inverse">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">covariance_matrix_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#covariance_matrix_inverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.covariance_matrix_inverse" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the inverse covariance matrix inverse of the fit coefficients.</p>
<p>If the least-squares solution to a fit is given as
<span class="math notranslate nohighlight">\(y = \hat{c} \cdot \Phi\)</span> when <span class="math notranslate nohighlight">\(y = c \cdot \Phi + \epsilon\)</span>,
the inverse covariance on the estimated fit coefficients <span class="math notranslate nohighlight">\(\hat{c}\)</span> is
given as:</p>
<div class="math notranslate nohighlight">
\[\Sigma^{-1} = \frac{N}{N - M} (\Phi^T W Var(y) \Phi)^{-1}\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> are the number of samples fit, <span class="math notranslate nohighlight">\(M\)</span> are the lost
degrees of freedom, <cite>W</cite> are the fit <cite>weights</cite>, and <span class="math notranslate nohighlight">\(Var(y)\)</span> is
related to the <cite>error</cite> (<span class="math notranslate nohighlight">\(\sigma\)</span>) by:</p>
<div class="math notranslate nohighlight">
\[Var(y) = diag(1 / \sigma^2)\]</div>
<p>Note that during the fitting process, it is common for the inverse of the
covariance matrix <span class="math notranslate nohighlight">\(\Sigma\)</span> to have already been calculated (not
factoring in lost degrees of freedom) if inverse variance was included as a
weighting factor for the fit.  If so, it should be passed in as <cite>amat</cite>
(<span class="math notranslate nohighlight">\(A\)</span>), and the final covariance is simply given by:</p>
<div class="math notranslate nohighlight">
\[\Sigma^{-1} = \frac{N}{N - M}A^{-1}\]</div>
<p>If <cite>amat</cite> was not calculated, it should be supplied as an array of shape
(0, 0) (because <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amat</strong><span class="classifier">numpy.ndarray (n_terms, n_terms)</span></dt><dd><p>The matrix A as described above.  If the shape of amat is set
to (0, 0), it will be calculated using the error, weights, and
phi terms.  This should only be done if A was weighted by both
<cite>error</cite> and <cite>weights</cite>.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (n_terms, N)</span></dt><dd><p>The polynomial terms for each of the N data samples.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The 1-sigma errors.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weighting factor applied to each sample when determining the
least squares solution of the fit.  Note that this <em>must not</em>
factor in any error based weighting.  Therefore, in the case of
the resampling algorithm, it should refer to the distance
weighting factor of each sample from the resampling point, or
an array of ones (np.ones(N)) if distance weighting was not
applied.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or float, optional</span></dt><dd><p>The matrix rank of <cite>amat</cite>, optionally passed in for speed if
pre-calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverse_covariance</strong><span class="classifier">numpy.ndarray (nterms, nterms)</span></dt><dd><p>The covariance matrix inverse of fit coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.derivative_mscp">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">derivative_mscp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#derivative_mscp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.derivative_mscp" title="Link to this definition">¶</a></dt>
<dd><p>Return the weighted mean-square-cross-product (mscp) of sample derivatives.</p>
<p>Given a polynomial equation of the form:</p>
<div class="math notranslate nohighlight">
\[f(\Phi) = c \cdot \Phi\]</div>
<p>The derivative is calculated as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial X_k} = \sum_{m=1}^{M}
{h_{k, 0, m} \cdot c_{h_{k, 1, m}} \cdot \Phi_{h_{k, 2, m}}}\]</div>
<p>for an equation of <span class="math notranslate nohighlight">\(M\)</span> terms at the coordinate <span class="math notranslate nohighlight">\(X\)</span> in
dimension <span class="math notranslate nohighlight">\(k\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the <cite>derivative_map</cite> and <span class="math notranslate nohighlight">\(c\)</span>
are the <cite>coefficients</cite>.  Please see <a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a> for
a more complete description of the derivative calculation.</p>
<p>One the derivatives (<span class="math notranslate nohighlight">\(g = \frac{df}{dX}\)</span>) are calculated for all
samples, they are averaged, and the cross-product is returned as:</p>
<div class="math notranslate nohighlight">
\[\bar{g}^2 = \frac{1}{tr(W W^T)} g^T W W^T g\]</div>
<p>where <span class="math notranslate nohighlight">\(W = diag(\text{weights})\)</span>.</p>
<p>For example, for polynomial fit of 2-dimensional data <span class="math notranslate nohighlight">\(f(x, y)\)</span>, the
returned matrix will be:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\bar{g}^2 =
    \begin{bmatrix}
        \frac{\partial f}{\partial x} \frac{\partial f}{\partial x} &amp;
        \frac{\partial f}{\partial x} \frac{\partial f}{\partial y} \\
        \frac{\partial f}{\partial y} \frac{\partial f}{\partial x} &amp;
        \frac{\partial f}{\partial y} \frac{\partial f}{\partial y}
    \end{bmatrix}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The coefficients of a polynomial fit for each term.</p>
</dd>
<dt><strong>phi_samples</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>The polynomial terms of the sample coordinates.  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_exponents" title="grig.resample_utils.polynomial_exponents"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_exponents()</span></code></a> for a description of this variable.</p>
</dd>
<dt><strong>derivative_map</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (n_dimensions, 3, n_valid_terms).  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a> for an explanation of this variable.</p>
</dd>
<dt><strong>sample_weights</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The weighting to apply to each sample when determining the weighted
mean (as a multiplier).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mscp</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>An array where sscp[i, j] = derivative[i] * derivative[j].
where derivative is the weighted mean derivatives over all samples.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.distribution_variances">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">distribution_variances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#distribution_variances"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.distribution_variances" title="Link to this definition">¶</a></dt>
<dd><p>Return variance at each coordinate based on coordinate distribution.</p>
<p>Given a normal sample distribution <span class="math notranslate nohighlight">\(X\)</span>, returns the variance at each
sample coordinate.  For example, consider a population of zero mean
(<span class="math notranslate nohighlight">\(\bar{X} = 0\)</span>) and a standard deviation of one (<span class="math notranslate nohighlight">\(\sigma = 1\)</span>).
Samples located at <span class="math notranslate nohighlight">\(\bar{X} \pm \sigma\)</span> will return a variance of
1, while samples located at <span class="math notranslate nohighlight">\(\bar{X} \pm 2\sigma\)</span> will return a
variance of 4.</p>
<p>By default, the distribution variance is derived using
<a class="reference internal" href="#grig.resample_utils.coordinate_covariance" title="grig.resample_utils.coordinate_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_covariance()</span></code></a>, and the sample mean is derived using
<a class="reference internal" href="#grig.resample_utils.coordinate_mean" title="grig.resample_utils.coordinate_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_mean()</span></code></a> assuming the loss of 1 degree of freedom. However,
the expected value (<span class="math notranslate nohighlight">\(E[X]\)</span>) may be supplied with the <cite>mean</cite> optional
parameter along with the <cite>covariance</cite>, and the number of lost degrees of
freedom (<cite>dof</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The coordinates of the sample distribution.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">numpy.ndarray (n_dimensions,), optional</span></dt><dd><p>The expected mean value of the distribution.</p>
</dd>
<dt><strong>covariance</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions), optional</span></dt><dd><p>The covariance matrix (if known) for the sample distribution.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_samples,), optional</span></dt><dd><p>An array of bool values where <cite>True</cite> indicates a sample should
be included when calculating the mean and covariance, and <cite>False</cite>
indicates that a sample should be ignored.  By default, all samples
are included.  The output variance will still be calculated for all
samples.</p>
</dd>
<dt><strong>sigma_inv</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions), optional</span></dt><dd><p>The inverse of the covariance matrix, optionally passed in for speed
if the covariance is known, and it’s inverse has been pre-calculated.</p>
</dd>
<dt><strong>dof</strong><span class="classifier">int or float, optional</span></dt><dd><p>The lost degrees of freedom, typically 1 to indicate that the
population mean is not known and is replaced by the sample mean.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The variance at each sample coordinate based on the sample
distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.estimated_covariance_matrix_inverse">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">estimated_covariance_matrix_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#estimated_covariance_matrix_inverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="Link to this definition">¶</a></dt>
<dd><p>Calculates covariance matrix inverse of fit coefficients from mean error.</p>
<p>An estimate to the covariance of fit parameters is given by:</p>
<div class="math notranslate nohighlight">
\[\Sigma = \frac{N}{N - M} \bar{\sigma}^2 (\Phi^T W \Phi)^{-1}\]</div>
<p>where <cite>N</cite> are the number of samples used in the fit, <span class="math notranslate nohighlight">\(M\)</span> are the
number of lost degrees of freedom, <span class="math notranslate nohighlight">\(W\)</span> are the <cite>weights</cite> applied to
the samples during the fit, and the estimated coefficients <span class="math notranslate nohighlight">\(\hat{c}\)</span>
are used to fit <span class="math notranslate nohighlight">\(y = \hat{c} \cdot \Phi + \sigma\)</span> to the sample
population <span class="math notranslate nohighlight">\(y = c \cdot \Phi + \epsilon\)</span>.  The weighted mean of the
squared <cite>error</cite> (<span class="math notranslate nohighlight">\(\bar{\sigma}^2\)</span>) is given by:</p>
<div class="math notranslate nohighlight">
\[\bar{\sigma}^2 = \frac{\sum_{i=1}^{N}{w_i e_i^2}}
                      {\sum_{i=1}^{N}{w_i}}\]</div>
<p>The final returned matrix is <span class="math notranslate nohighlight">\(\Sigma^{-1}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (nterms, N)</span></dt><dd><p>The polynomial terms for each of the N data samples.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The 1-sigma errors or residuals to the fit.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weighting of each sample in the fit, not including any error
weighting.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or float, optional</span></dt><dd><p>The matrix rank of <span class="math notranslate nohighlight">\(\Phi^T W \Phi\)</span>, optionally passed in for
speed if pre-calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>covariance_inverse</strong><span class="classifier">numpy.ndarray (nterms, nterms)</span></dt><dd><p>The inverse covariance matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.evaluate_derivative">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">evaluate_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_map</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#evaluate_derivative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.evaluate_derivative" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the derivative of a polynomial at a single point.</p>
<p>Please see <a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a> for a full description of
how the derivatives are calculated from a polynomial equation defined by
<a class="reference internal" href="#grig.resample_utils.polynomial_exponents" title="grig.resample_utils.polynomial_exponents"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_exponents()</span></code></a>.  These also explain how one should transform
the independent variables to the “phi” (<span class="math notranslate nohighlight">\(\Phi\)</span>) terms (which may be
done using <a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a>).</p>
<p>The derivative at a point is calculated by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial X_k} = \sum_{m=1}^{M}
    {h_{k, 0, m} \cdot c_{h_{k, 1, m}} \cdot \Phi_{h_{k, 2, m}}}\]</div>
<p>for a polynomial equation consisting of <span class="math notranslate nohighlight">\(M\)</span> terms at the coordinate
<span class="math notranslate nohighlight">\(X\)</span> in dimension <span class="math notranslate nohighlight">\(k\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the derivative map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The coefficients of the polynomial equation for each term.</p>
</dd>
<dt><strong>phi_point</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The polynomial terms of the fittin equation at a single coordinate.</p>
</dd>
<dt><strong>derivative_map</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (n_dimensions, 3, n_valid_terms).  The second
dimension (of size 3) gives a constant multiplier in the first element,
the coefficient index in the second element, and the phi index in the
second element.  The third dimension will generally be of a smaller
size than the number of terms in the polynomial equation as not all
are required to calculate the derivative.  Due to the fact that some
dimensions may contain more valid terms than others, <cite>n_valid_terms</cite>
is set to the maximum number of valid terms over all dimensions.  Any
invalid terms still remaining in the mapping array will have
multipliers set to zero, and index pointers set to -1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>derivative</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The partial derivative of the polynomial equation with respect to each
dimension.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.evaluate_derivatives">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">evaluate_derivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_map</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#evaluate_derivatives"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.evaluate_derivatives" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the derivative of a polynomial at multiple points.</p>
<p>Please see <a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a> for a full description of
how the derivatives are calculated from a polynomial equation defined by
<a class="reference internal" href="#grig.resample_utils.polynomial_exponents" title="grig.resample_utils.polynomial_exponents"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_exponents()</span></code></a>.  These also explain how one should transform
the independent variables to the “phi” (<span class="math notranslate nohighlight">\(\Phi\)</span>) terms (which may be
done using <a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a>).</p>
<p>The derivative at a point is calculated by:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial X_k} = \sum_{m=1}^{M}
    {h_{k, 0, m} \cdot c_{h_{k, 1, m}} \cdot \Phi_{h_{k, 2, m}}}\]</div>
<p>for a polynomial equation consisting of <span class="math notranslate nohighlight">\(M\)</span> terms at the coordinate
<span class="math notranslate nohighlight">\(X\)</span> in dimension <span class="math notranslate nohighlight">\(k\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the derivative map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The coefficients of the polynomial equation for each term.</p>
</dd>
<dt><strong>phi_points</strong><span class="classifier">numpy.ndarray (n_terms, n_points)</span></dt><dd><p>The polynomial terms of the fitting equation at a multiple points.</p>
</dd>
<dt><strong>derivative_map</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array of shape (n_dimensions, 3, n_valid_terms).  The second
dimension (of size 3) gives a constant multiplier in the first element,
the coefficient index in the second element, and the phi index in the
second element.  The third dimension will generally be of a smaller
size than the number of terms in the polynomial equation as not all
are required to calculate the derivative.  Due to the fact that some
dimensions may contain more valid terms than others, <cite>n_valid_terms</cite>
is set to the maximum number of valid terms over all dimensions.  Any
invalid terms still remaining in the mapping array will have
multipliers set to zero, and index pointers set to -1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>derivatives</strong><span class="classifier">numpy.ndarray (n_dimensions, n_points)</span></dt><dd><p>The partial derivative of the polynomial equation with respect to each
dimension at each point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.fasttrapz">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">fasttrapz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#fasttrapz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.fasttrapz" title="Link to this definition">¶</a></dt>
<dd><p>Fast 1-D integration using Trapezium method.</p>
<p>Approximates the integration of a 1-D discrete valued function
<span class="math notranslate nohighlight">\(y_i = f(x_i)\)</span> with <span class="math notranslate nohighlight">\(N\)</span> measurements as:</p>
<div class="math notranslate nohighlight">
\[\int_a^b f(x) \approx \frac{1}{2}
    \sum_{i=1}^{N}{ \left( y_{i - 1} + y_i \right)
                    \left( x_i - x_{i - 1} \right) }\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>Dependent variable</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>Independent variable</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>The integrated area</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.fit_phi_value">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">fit_phi_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#fit_phi_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.fit_phi_value" title="Link to this definition">¶</a></dt>
<dd><p>Returns the dot product of phi and coefficients.</p>
<p>A utility function for use in calculating the polynomial fit based on the
polynomial terms of the independent values (<cite>phi</cite>), and a set of calculated
<cite>coefficients</cite>.</p>
<p>The return value for <cite>phi</cite> (<span class="math notranslate nohighlight">\(\Phi\)</span>) terms and coefficients
(<span class="math notranslate nohighlight">\(c\)</span>) each consisting of <span class="math notranslate nohighlight">\(L\)</span> terms is:</p>
<div class="math notranslate nohighlight">
\[y = \sum_{l=1}^{L}{c_l \Phi_l}\]</div>
<p>The polynomial terms <span class="math notranslate nohighlight">\(\Phi\)</span> are pre-calculated and used in place of
regular independent values <span class="math notranslate nohighlight">\(x\)</span> in the resampling algorithm to avoid
the unnecessary recalculation of terms in a polynomial equation.  For
example, if fitting</p>
<div class="math notranslate nohighlight">
\[y = 5 x_0 x_1 + 6 x_0 x_3^2 + 7 x_1^3 x_4^2 + 8 x_0 x_1 x_2 x_3\]</div>
<p>we set</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}c = [5,\, 6,\, 7,\, 8]\\\Phi = [x_0 x_1,\, x_0 x_3^2,\, x_1^3 x_4^2,\, x_0 x_1 x_2 x_3]\end{aligned}\end{align} \]</div>
<p>and then only need to perform the simple fast calculation</p>
<div class="math notranslate nohighlight">
\[y = c \cdot \Phi\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (n_coefficients,)</span></dt><dd><p>Polynomial terms of independent values.</p>
</dd>
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (n_coefficients,)</span></dt><dd><p>Coefficients used to determine fit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit</strong><span class="classifier">float</span></dt><dd><p>The fitted value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.fit_phi_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">fit_phi_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_covariance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#fit_phi_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.fit_phi_variance" title="Link to this definition">¶</a></dt>
<dd><p>Calculates variance given the polynomial terms of a coordinate.</p>
<p>The output variance for given polynomial terms <cite>phi</cite> (<span class="math notranslate nohighlight">\(\Phi\)</span>) is
given as:</p>
<div class="math notranslate nohighlight">
\[V = \Phi^T Var(\hat{c}) \Phi\]</div>
<p>where <span class="math notranslate nohighlight">\(Var(\hat{c})\)</span> is the covariance matrix inverse of the
fit coefficients (<cite>inv_covariance</cite>) such that <span class="math notranslate nohighlight">\(Var(\hat{c})_{i, j}\)</span>
gives the covariance between the coefficients for terms <span class="math notranslate nohighlight">\(i\)</span> and
<span class="math notranslate nohighlight">\(j\)</span>, and the coefficients <span class="math notranslate nohighlight">\(\hat{c}\)</span> define the fit:</p>
<div class="math notranslate nohighlight">
\[y = \hat{c} \cdot \Phi\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (ncoeffs,)</span></dt><dd><p>The polynomial terms.</p>
</dd>
<dt><strong>inv_covariance</strong><span class="classifier">numpy.ndarray (ncoeffs, ncoeffs)</span></dt><dd><p>The covariance matrix inverse of the fit coefficients.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">float</span></dt><dd><p>The calculated variance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.fit_residual">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">fit_residual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficients</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#fit_residual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.fit_residual" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the residual of a polynomial fit to data.</p>
<p>The residual is calculated using the matrix operation Y - CX where
Y is the <cite>dataset</cite>, C are the <cite>coefficients</cite> and X is the <cite>phi</cite> polynomial
terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>Data from which coefficients were derived.</p>
</dd>
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>Polynomial terms of independent values of each sample.</p>
</dd>
<dt><strong>coefficients</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>Coefficient values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residual</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The residual</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.half_max_sigmoid">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">half_max_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_half</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#half_max_sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.half_max_sigmoid" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate a special case of the logistic function where f(x0) = 0.5.</p>
<p>The generalized logistic function is given as:</p>
<div class="math notranslate nohighlight">
\[f(x) = A + \frac{K - A}
                {\left( C + Q e^{-B(x - x_0)} \right)^{1/\nu}}\]</div>
<p>and may be evaluated with <a class="reference internal" href="#grig.resample_utils.logistic_curve" title="grig.resample_utils.logistic_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">logistic_curve()</span></code></a>.</p>
<p>We can manipulate this function so that <span class="math notranslate nohighlight">\(f(x_{half}) = (K + A) / 2\)</span>
(the midpoint of the function) by setting the location of maximum growth
(<span class="math notranslate nohighlight">\(x_0\)</span>) to occur at:</p>
<div class="math notranslate nohighlight">
\[x_0 = x_{half} + \frac{1}{B}
                 \ln{\left( \frac{2^\nu - C}{Q} \right)}\]</div>
<p>Since a logarithm is required, it is incumbent on the user to ensure that
no logarithms are taken of any quantity <span class="math notranslate nohighlight">\(\leq 0\)</span>, i.e.,
<span class="math notranslate nohighlight">\((2^\nu - C) / Q &gt; 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The independent variable.</p>
</dd>
<dt><strong>x_half</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The x value for which f(x) = 0.5.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The upper asymptote when <cite>c</cite> is one.</p>
</dd>
<dt><strong>a</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The lower asymptote.</p>
</dd>
<dt><strong>c</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Typically takes a value of 1.  Otherwise, the upper asymptote is
a + ((k - a) / c^(1/v)).</p>
</dd>
<dt><strong>q</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Related to the value of f(0).  Fixes the point of inflection.  In this
implementation, <cite>q</cite> is completely factored out after simplifying and
does not have any affec</p>
</dd>
<dt><strong>b</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The growth rate.</p>
</dd>
<dt><strong>v</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Must be greater than zero.  Affects near which asymptote the maximum
growth occurs (point of inflection).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">float or numpy.ndarray</span></dt><dd><p>The half-max sigmoid evaluated at <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.logistic_curve">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">logistic_curve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#logistic_curve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.logistic_curve" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate the generalized logistic function.</p>
<p>The generalized logistic function is given as:</p>
<div class="math notranslate nohighlight">
\[f(x) = A + \frac{K - A}
                {\left( C + Q e^{-B(x - x_0)} \right)^{1/\nu}}\]</div>
<p>Taken from Wikipedia contributors. (2020, June 11). Generalised logistic
function. In Wikipedia, The Free Encyclopedia.
Retrieved 23:51, July 6, 2020, from
<a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Generalised_logistic_function&amp;oldid=961965809">https://en.wikipedia.org/w/index.php?title=Generalised_logistic_function&amp;oldid=961965809</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The independent variable.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>An offset applied to <cite>x</cite>.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The upper asymptote when <cite>c</cite> is one.</p>
</dd>
<dt><strong>a</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The lower asymptote.</p>
</dd>
<dt><strong>c</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Typically takes a value of 1.  Otherwise, the upper asymptote is
a + ((k - a) / c^(1/v)).</p>
</dd>
<dt><strong>q</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Related to the value of f(0).</p>
</dd>
<dt><strong>b</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>The growth rate.</p>
</dd>
<dt><strong>v</strong><span class="classifier">int or float or numpy.ndarray (shape), optional</span></dt><dd><p>Must be greater than zero.  Affects near which asymptote the maximum
growth occurs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">float or numpy.ndarray (shape)</span></dt><dd><p>The logistic function evaluated at <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.multiple_polynomial_terms">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">multiple_polynomial_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#multiple_polynomial_terms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.multiple_polynomial_terms" title="Link to this definition">¶</a></dt>
<dd><p>Derive polynomial terms for a coordinate set given polynomial exponents.</p>
<p>Raises multiple coordinates by a power and then calculates the product over
all dimensions.  For example, the output of an (x, y) vector with
<cite>exponent=[[2, 3]]</cite> would be <span class="math notranslate nohighlight">\(x^2y^3\)</span>.</p>
<p>Note that multiple sets of exponents are expected to be provided during
this operation, so the <cite>exponents</cite> parameter should be a 2-dimensional
array.  The return value will be a 2-dimensional array with the size of
the first dimension equal to the number of exponent sets, and the size of
the second dimension equal to the number of vector sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (N, n_vectors)</span></dt><dd><p>Sets of vectors in N-dimensions.</p>
</dd>
<dt><strong>exponents</strong><span class="classifier">numpy.ndarray (n_exponents, N)</span></dt><dd><p>Sets of exponents by which to raise the vector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (n_exponents, n_vectors)</dt><dd><p>The product of the exponentiation of the vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.multivariate_gaussian">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">multivariate_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covariance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#multivariate_gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.multivariate_gaussian" title="Link to this definition">¶</a></dt>
<dd><p>Return values of a multivariate Gaussian in K-dimensional coordinates.</p>
<p>The density of a multivariate Gaussian is given as:</p>
<div class="math notranslate nohighlight">
\[f_{\mathbf X}(x_1, \ldots, x_k) = \frac
    {\exp\left(-\frac{1}{2} (x - \mu)^T \Sigma^{-1}(x - \mu) \right)}
    {\sqrt{(2 \pi)^K |\Sigma|}}\]</div>
<p>where the <cite>coordinates</cite> <span class="math notranslate nohighlight">\(X\)</span> are real <span class="math notranslate nohighlight">\(K\)</span> dimensional vectors,
<span class="math notranslate nohighlight">\(\Sigma\)</span> is the covariance matrix with determinant <span class="math notranslate nohighlight">\(|\Sigma|\)</span>,
and the <cite>center</cite> of the distribution is given by <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>Note that by default, the factor <span class="math notranslate nohighlight">\({\sqrt{(2 \pi)^K |\Sigma|}}\)</span> is not
applied unless <cite>normalize</cite> is <cite>True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>covariance</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>The covariance matrix (<span class="math notranslate nohighlight">\(\Sigma\)</span>).  Should be symmetric and
positive definite.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinates at which to evaluate the multivariate Gaussian.</p>
</dd>
<dt><strong>center</strong><span class="classifier">numpy.ndarray (n_dimensions,), optional</span></dt><dd><p>The center of the distribution.  If not supplied, the center is
assumed to be zero in all dimensions.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, normalize by dividing by <span class="math notranslate nohighlight">\(\sqrt{(2 \pi)^k |\Sigma|}\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>density</strong><span class="classifier">numpy.ndarray (n_coordinates,)</span></dt><dd><p>The density evaluated at each coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.no_fit_solution">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">no_fit_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">set_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_weights_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rchi2_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_variance_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#no_fit_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.no_fit_solution" title="Link to this definition">¶</a></dt>
<dd><p>Fill output arrays with set values on fit failure.</p>
<p>On fit failure, the output arrays are filled with certain values indicating
that a fit is not possible.  Count, and weight arrays contain zeros; the
error, reduced chi-squared and offset variance are set to NaN; finally,
the data array is set to <cite>cval</cite>, a user set float value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>set_index</strong><span class="classifier">int</span></dt><dd><p>An integer representing the data set for which a fit cannot be
performed.</p>
</dd>
<dt><strong>point_index</strong><span class="classifier">int</span></dt><dd><p>An integer representing the index of the fit coordinate at which the
fit cannot be performed.</p>
</dd>
<dt><strong>fit_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The output fit values.</p>
</dd>
<dt><strong>error_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The output error values on the fit.</p>
</dd>
<dt><strong>counts_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The number of samples used to create the fit.</p>
</dd>
<dt><strong>weights_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The sum of full weights applied to samples in the fit.</p>
</dd>
<dt><strong>distance_weights_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The sum of only the distance weights applied to samples in the fit.</p>
</dd>
<dt><strong>rchi2_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The reduced chi-squared statistic of the fit.</p>
</dd>
<dt><strong>offset_variance_out</strong><span class="classifier">numpy.ndarray (n_sets, n_coordinates)</span></dt><dd><p>The variance as derived from the offset of the fit coordinate from the
sample distribution.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>False</cite> do not update <cite>error_out</cite>.</p>
</dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If ‘False’ do not update <cite>counts_out</cite>.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>False</cite> do not update <cite>weights_out</cite>.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>False</cite> do not update <cite>distance_weights_out</cite>.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>False</cite> do not update <cite>rchi2_out</cite>.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>False</cite> do not update <cite>offset_variance_out</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>The fill value for <cite>data_out</cite> on fit failure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd><p>All arrays are updated in-place.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.offset_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">offset_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#offset_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.offset_variance" title="Link to this definition">¶</a></dt>
<dd><p>Variance at reference coordinate derived from distribution uncertainty.</p>
<p>Given a distribution of <cite>coordinates</cite> (<span class="math notranslate nohighlight">\(X\)</span>), calculate the variance
at a <cite>reference</cite> coordinate (<span class="math notranslate nohighlight">\(X_{ref}\)</span>) based upon the uncertainty in
the coordinate distribution.  Firstly, the distribution covariance matrix
(<span class="math notranslate nohighlight">\(\Sigma\)</span>) is calculated by <a class="reference internal" href="#grig.resample_utils.coordinate_covariance" title="grig.resample_utils.coordinate_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_covariance()</span></code></a> enabling
the variance at the reference position to be given as:</p>
<div class="math notranslate nohighlight">
\[V(X_{ref}) = (X_{ref} - E[X])^{T} \Sigma^{-1} (X_{ref} - E[X])\]</div>
<p>If the expected value of the distribution is known (<span class="math notranslate nohighlight">\(E[X]\)</span>) or
pre-calculated, it can be passed in to the function using the <cite>mean</cite>
optional parameter along with the lost degrees of freedom (<cite>dof</cite>) spent in
determining <span class="math notranslate nohighlight">\(E[X]\)</span>.  If not, the default is to use <span class="math notranslate nohighlight">\(\bar{X}\)</span>
and <cite>dof</cite> = 1.</p>
<p>The user may optionally specify a <cite>scale</cite> factor (<span class="math notranslate nohighlight">\(\beta\)</span>) such that:</p>
<div class="math notranslate nohighlight">
\[V(X_{ref}) = (\beta(X_{ref} - E[X]))^{T} \Sigma^{-1}
             (\beta(X_{ref} - E[X]))\]</div>
<p>or:</p>
<div class="math notranslate nohighlight">
\[V(X_{ref}) = \beta^2 (X_{ref} - E[X])^{T} \Sigma^{-1} (X_{ref} - E[X])\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_coordinates)</span></dt><dd><p>The coordinates of the distribution.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The reference coordinate.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (n_coordinates,), optional</span></dt><dd><p>An array of bool values where <cite>True</cite> indicates a coordinate should
be included in the calculation, and <cite>False</cite> indicates that a coordinate
should be ignored.  By default, all coordinates are included.</p>
</dd>
<dt><strong>mean</strong><span class="classifier">numpy.ndarray (n_dimensions,), optional</span></dt><dd><p>The mean of the coordinate distribution in each dimension.  If not
provided, the expected value in each dimension will be calculated
using <a class="reference internal" href="#grig.resample_utils.coordinate_mean" title="grig.resample_utils.coordinate_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">coordinate_mean()</span></code></a>.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">int or float, optional</span></dt><dd><p>The scaling factor described above.</p>
</dd>
<dt><strong>dof</strong><span class="classifier">int or float, optional</span></dt><dd><p>The lost degrees of freedom, typically 1 to indicate that the
population mean is not known and is replaced by the sample mean.</p>
</dd>
<dt><strong>sigma_inv</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions), optional</span></dt><dd><p>If the covariance matrix of the coordinate distribution has already
been calculated, the matrix inverse may be passed in as sigma_inv for
speed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">float</span></dt><dd><p>The variance at the reference coordinate determined from the coordinate
distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.polynomial_derivative_map">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">polynomial_derivative_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#polynomial_derivative_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.polynomial_derivative_map" title="Link to this definition">¶</a></dt>
<dd><p>Creates a mapping from polynomial exponents to derivatives.</p>
<p>Please see <a class="reference internal" href="#grig.resample_utils.polynomial_exponents" title="grig.resample_utils.polynomial_exponents"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_exponents()</span></code></a> for details on how a polynomial
equation is defined within the resampling algorithm, and the use of the
<cite>exponents</cite> array in defining the polynomial terms (<span class="math notranslate nohighlight">\(\Phi\)</span>).</p>
<p>Within the confines of the resampling algorithm, the polynomial exponents
should have always been defined in a way that will always allow the
derivative of a polynomial fit to be calculated from existing,
pre-calculated <span class="math notranslate nohighlight">\(\Phi\)</span> terms.</p>
<p>For example, consider the 2-dimensional 2nd order polynomial equation and
its derivatives in each dimension:</p>
<div class="math notranslate nohighlight">
\[f(x, y) = c_1 + c_2 x + c_3 x^2 + c_4 y + c_5 x y + c_6 y^2\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial x} = c_2 + 2 c_3 x + c_5 y\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial y} = c_4 + c_5 x + 2 c_6 y\]</div>
<p>Converting <span class="math notranslate nohighlight">\(f(x, y) \rightarrow f(\Phi)\)</span> we get:</p>
<div class="math notranslate nohighlight">
\[f(\Phi) = c_1 \Phi_1 + c_2 \Phi_2 + c_3 \Phi_3 + c_4 \Phi_4 +
          c_5 \Phi_5 + c_6 \Phi_6\]</div>
<p>It can then be seen that</p>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial x} = c_2 \Phi_1 + 2 c_3 \Phi_2 + c_5 \Phi_4\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial y} = c_4 \Phi_1 + c_5 \Phi_2 + 2 c_6 \Phi_4\]</div>
<p>Generalizing for a polynomial equation consisting of <span class="math notranslate nohighlight">\(M\)</span> terms of the
independent variable <span class="math notranslate nohighlight">\(X\)</span> in <span class="math notranslate nohighlight">\(K-\text{dimensions}\)</span>, a mapping
(<span class="math notranslate nohighlight">\(h\)</span>) can be devised enabling calculation of the derivatives from
pre-existing terms.  For dimension <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial f}{\partial X_k} = \sum_{m=1}^{M}
    {h_{k, 0, m} \cdot c_{h_{k, 1, m}} \cdot \Phi_{h_{k, 2, m}}}\]</div>
<p>This allows the derivative to be calculated from the existing polynomial
terms (<span class="math notranslate nohighlight">\(\Phi\)</span>) and coefficients (<span class="math notranslate nohighlight">\(c\)</span>).  In addition, the
mapping can be calculated prior to reduction and will therefore only need
to be calculated once along with <span class="math notranslate nohighlight">\(\Phi\)</span>.  Once the coefficients are
known, the derivatives can then be calculated using <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>Derivatives may be evaluated using <a class="reference internal" href="#grig.resample_utils.evaluate_derivative" title="grig.resample_utils.evaluate_derivative"><code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate_derivative()</span></code></a> and
<a class="reference internal" href="#grig.resample_utils.evaluate_derivatives" title="grig.resample_utils.evaluate_derivatives"><code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate_derivatives()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">numpy.ndarray (n_terms, n_dimensions)</span></dt><dd><p>The exponents defining a polynomial equation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>derivative_map</strong><span class="classifier">numpy.ndarray of int</span></dt><dd><p>An array of shape (n_dimensions, 3, n_valid_terms).  The second
dimension (of size 3) gives a constant multiplier in the first element,
the coefficient index in the second element, and the phi index in the
second element.  The third dimension will generally be of a smaller
size than the number of terms in the polynomial equation as not all
are required to calculate the derivative.  Due to the fact that some
dimensions may contain more valid terms than others, <cite>n_valid_terms</cite>
is set to the maximum number of valid terms over all dimensions.  Any
invalid terms still remaining in the mapping array will have
multipliers set to zero, and index pointers set to -1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.polynomial_exponents">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">polynomial_exponents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_max_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#polynomial_exponents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.polynomial_exponents" title="Link to this definition">¶</a></dt>
<dd><p>Define a set of polynomial exponents.</p>
<p>The resampling algorithm uses defines a set of polynomial exponents as an
array of shape (dimensions, terms) for an equation of the form:</p>
<div class="math notranslate nohighlight">
\[f( \Phi ) = \sum_{m=1}^{M}{c_m \Phi_m}\]</div>
<p>for <span class="math notranslate nohighlight">\(M\)</span> terms.  Here, <span class="math notranslate nohighlight">\(\Phi_m\)</span> represents the product of
independent variables, each raised to an appropriate power as defined by
<cite>exponents</cite>. For example, consider the equation for 2-dimensional data
with independent variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>:</p>
<div class="math notranslate nohighlight">
\[f(x, y) = c_1 + c_2 x + c_3 x^2 + c_4 y + c_5 x y + c_6 y^2\]</div>
<p>In this case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exponents</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># represents a constant or x^0 y^0</span>
             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># represents x</span>
             <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># represents x^2</span>
             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># represents y</span>
             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># represents xy</span>
             <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>  <span class="c1"># represents y^2</span>
</pre></div>
</div>
<p>The resampling algorithm solves for the coefficients (<span class="math notranslate nohighlight">\(c\)</span>) by
converting <span class="math notranslate nohighlight">\(f(X) \rightarrow f(\Phi)\)</span> for
<span class="math notranslate nohighlight">\(K-\text{dimensional}\)</span> independent variables (<span class="math notranslate nohighlight">\(X\)</span>)
and <cite>exponents</cite> (<span class="math notranslate nohighlight">\(p\)</span>) by setting:</p>
<div class="math notranslate nohighlight">
\[\Phi_m = \prod_{k=1}^{K}{X_{k}^{p_{m, k}}}\]</div>
<p>In most of the code, the <span class="math notranslate nohighlight">\(\Phi\)</span> terms are interchangable with
“polynomial terms”, and in the above example <span class="math notranslate nohighlight">\(\Phi_5 = xy\)</span> since
exponents[4] = [1, 1] representing <span class="math notranslate nohighlight">\(x^1 y^1\)</span>.</p>
<p>Note that for all terms (<span class="math notranslate nohighlight">\(m\)</span>) in each dimension <span class="math notranslate nohighlight">\(k\)</span>,
<span class="math notranslate nohighlight">\(\sum_{k=1}^{K}{p_{m, k}} \leq max(\text{order})\)</span>.  In addition,
if <cite>use_max_order</cite> is <cite>False</cite> (default),
<span class="math notranslate nohighlight">\(p_{m,k} \leq \text{order}[k]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int or array_like of int</span></dt><dd><p>Polynomial order for which to generate exponents.  If an array
will create full polynomial exponents over all len(order)
dimensions.</p>
</dd>
<dt><strong>ndim</strong><span class="classifier">int, optional</span></dt><dd><p>If set, return Taylor expansion for <cite>ndim</cite> dimensions for
the given <cite>order</cite> if <cite>order</cite> is not an array.</p>
</dd>
<dt><strong>use_max_order</strong><span class="classifier">bool, optional</span></dt><dd><p>This keyword is only applicable for multi-dimensional data when orders
are unequal across dimensions.  When <cite>True</cite>, the maximum exponent for
each dimension is equal to max(order).  If <cite>False</cite>, the maximum
available exponent for dimension k is equal to order[k].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(n_terms, n_dimensions) array of polynomial exponents.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial_exponents</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[0],</span>
<span class="go">       [1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial_exponents</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [0, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [0, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial_exponents</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [3, 0],</span>
<span class="go">       [0, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 1],</span>
<span class="go">       [0, 2],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [0, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.polynomial_terms">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">polynomial_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#polynomial_terms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.polynomial_terms" title="Link to this definition">¶</a></dt>
<dd><p>Derive polynomial terms given coordinates and polynomial exponents.</p>
<p>Raises a single coordinate or multiple coordinates by a power and then
calculates the product over all dimensions.  For example, the output of
an (x, y) vector with <cite>exponent=[[2, 3]]</cite> would be <span class="math notranslate nohighlight">\(x^2y^3\)</span>.</p>
<p>Note that multiple sets of exponents are expected to be provided during
this operation, so the <cite>exponents</cite> parameter should be a 2-dimensional
array.  If a single N-dimensional vector is provided, the output will be
a 1-dimensional array with a single value for each exponent set.  If
multiple vectors are provided, the output will be of shape (number of
exponent sets, number of vectors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (N, n_vectors) or (N,)</span></dt><dd><p>Sets of coordinates in N-dimensions or a single coordinate of
N-dimensions.</p>
</dd>
<dt><strong>exponents</strong><span class="classifier">numpy.ndarray (n_exponents, N)</span></dt><dd><p>Sets of polynomial exponents to apply to coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (n_exponents, n_vectors) or (n_exponents,)</dt><dd><p>The polynomial terms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.relative_density">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">relative_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_sum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#relative_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.relative_density" title="Link to this definition">¶</a></dt>
<dd><p>Returns the relative density of samples compared to a uniform distribution.</p>
<p>The relative local density is defined as 1 for a uniform distribution,
&lt; 1 for a distribution that is sparse near the center, and &gt; 1 when
clustered around the center.</p>
<p>The sum of the <cite>distance_weights</cite> returned from a Gaussian weighting
function on the samples is required for this calculation.  The
weighting function should be of the form:</p>
<div class="math notranslate nohighlight">
\[w(\Delta x) = exp \left(
    -\sum_{k=1}^{K}{\frac{-\Delta x_k^2}{2 \sigma_k^2}}
    \right)\]</div>
<p>over <span class="math notranslate nohighlight">\(K\)</span> dimensions where <span class="math notranslate nohighlight">\(\Delta x_k\)</span> is the offset of a
sample in dimension <span class="math notranslate nohighlight">\(k\)</span> from the point of interest, and
<span class="math notranslate nohighlight">\(\sigma\)</span> must be supplied to <cite>relative_density</cite> as <cite>sigma</cite>, where
<cite>distance_weights</cite> = <span class="math notranslate nohighlight">\(\sum_{i=1}^{N}{w(x_i)}\)</span> and
<cite>counts</cite> = <span class="math notranslate nohighlight">\(N\)</span>.  Note that <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(x\)</span> must be
scaled such that the principle axis of an ellipsoid window
containing all samples are equal to unity (principle axis in dimension
<span class="math notranslate nohighlight">\(k\)</span> is <span class="math notranslate nohighlight">\(\Omega_k = 1\)</span> such that
<span class="math notranslate nohighlight">\(\prod_{k=1}^{K}{\Omega_k} = 1\)</span> below).</p>
<p>The local relative density is then given as:</p>
<div class="math notranslate nohighlight">
\[\rho = \frac{\rho(\text{measured})}{\rho(\text{uniform})}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\rho(\text{uniform}) = N \frac{\Gamma \left( 1 + \frac{K}{2} \right)}
                              {\pi^{K/2} \prod_{k=1}^{K}{\Omega_k}}\]</div>
<div class="math notranslate nohighlight">
\[\rho(\text{measured}) = \frac
    {\sum_{i=1}^{N}{w_i}}
    {\int \cdots \int_{R} w(\mathbf{\Delta x}) \, {dx}_1 \cdots {dx}_K}\]</div>
<p>and region <span class="math notranslate nohighlight">\(R\)</span> satisfies the requirement
<span class="math notranslate nohighlight">\(\| \mathbf{\Delta x} \|_2 \leq 1\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">np.ndarray (n_dimensions,)</span></dt><dd><p>The standard deviation of the Gaussian weighting function used to
calculate the <cite>distance_weights</cite> for each dimension.</p>
</dd>
<dt><strong>counts</strong><span class="classifier">int or float or numpy.ndarray (N,)</span></dt><dd><p>The number of data samples included in the sum of distance weights.</p>
</dd>
<dt><strong>weight_sum</strong><span class="classifier">int or float or numpy.ndarray (N,)</span></dt><dd><p>The sum of weights as returned from a Gaussian weighting function.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Relative error tolerance passed to <cite>scipy.integrate.quad</cite> when
determining the integral of the weighting function.  The default of
10^(2*dim - 7) determined by testing, balancing precision with
speed and convergence.</p>
</dd>
<dt><strong>max_dim</strong><span class="classifier">int, optional</span></dt><dd><p>If the number of dimensions is greater than max_dim, do not attempt
to calculate the relative density since the integral calculation
is unlikely to converge and will take a vast amount of time.  The
return output will be 1.0 or an array of ones (N,).  The maximum
recommended number of dimensions is 4 (default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>float or numpy.ndarray of float64 (N,)</dt><dd><p>The relative density.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scale_coordinates">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scale_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scale_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scale_coordinates" title="Link to this definition">¶</a></dt>
<dd><p>Apply scaling factors and offsets to N-dimensional data.</p>
<p>The two available transforms are controlled by the <cite>reverse</cite>.  The
transform functions apply the following functions:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Reverse</p></th>
<th class="head"><p>f(x)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>False (default)</p></td>
<td><p>(x - offset) / scale</p></td>
</tr>
<tr class="row-odd"><td><p>True</p></td>
<td><p>(x * scale) + offset</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (N, M) or (N,)</span></dt><dd><p>Either a 1 or 2-dimensional array may be supplied.  If a 1-dimensional
array is supplied, it is assumed that it represents a single
coordinates in N-dimensions.  If a 2-dimensional array is supplied,
it should be of shape (N, M) where N is the number of dimensions, and
M is the number of coordinates.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The scaling factor to apply to each dimension.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The offset to apply to each dimension.</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, apply the reverse transform.  The default is <cite>False</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (N, M) or (N,)</dt><dd><p>The scaled <cite>coordinates</cite> array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scale_forward_scalar">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scale_forward_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scale_forward_scalar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scale_forward_scalar" title="Link to this definition">¶</a></dt>
<dd><p>Applies the function <cite>f(x) = (x - offset) / scale</cite> to a single coordinate.</p>
<p>This is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> jit compiled function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinate</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>An array where N is the number of dimensions.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The scaling factor to apply to each dimension.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The offset to apply to each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (N,)</dt><dd><p>The scaled <cite>coordinates</cite> array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scale_forward_vector">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scale_forward_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scale_forward_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scale_forward_vector" title="Link to this definition">¶</a></dt>
<dd><p>Applies the function <cite>f(x) = (x - offset) / scale</cite> to a coordinate array.</p>
<p>This is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> jit compiled function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (N, M)</span></dt><dd><p>An array where N is the number of dimensions, and M is the number of
coordinates.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The scaling factor to apply to each dimension.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The offset to apply to each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (N, M)</dt><dd><p>The scaled <cite>coordinates</cite> array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scale_reverse_scalar">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scale_reverse_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scale_reverse_scalar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scale_reverse_scalar" title="Link to this definition">¶</a></dt>
<dd><p>Applies the function <cite>f(x) = (x * scale) + offset</cite> to a single coordinate.</p>
<p>This is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> jit compiled function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinate</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>An array where N is the number of dimensions.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The scaling factor to apply to each dimension.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The offset to apply to each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (N,)</dt><dd><p>The scaled <cite>coordinates</cite> array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scale_reverse_vector">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scale_reverse_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scale_reverse_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scale_reverse_vector" title="Link to this definition">¶</a></dt>
<dd><p>Applies the function <cite>f(x) = (x * scale) + offset</cite> to a coordinate array.</p>
<p>This is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> jit compiled function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinates</strong><span class="classifier">numpy.ndarray (N, M)</span></dt><dd><p>An array where N is the number of dimensions, and M is the number of
coordinates.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The scaling factor to apply to each dimension.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The offset to apply to each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (N, M)</dt><dd><p>The scaled <cite>coordinates</cite> array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scaled_adaptive_weight_matrices">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scaled_adaptive_weight_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rchi2_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scaled_adaptive_weight_matrices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scaled_adaptive_weight_matrices" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <cite>scaled_adaptive_weight_matrix</cite> over multiple values.</p>
<p>Please see <a class="reference internal" href="#grig.resample_utils.scaled_adaptive_weight_matrix" title="grig.resample_utils.scaled_adaptive_weight_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">scaled_adaptive_weight_matrix()</span></code></a> for details on how the
weighting kernel is modified using a single scaling factor.  This function
performs the calculation for multiple scaling factors (<span class="math notranslate nohighlight">\(\chi_r^2\)</span>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The standard deviations of the Gaussian for each dimensional component
used for the distance weighting of each sample in the initial fit.</p>
</dd>
<dt><strong>rchi2_values</strong><span class="classifier">numpy.ndarray (n_data_sets, fit_shape)</span></dt><dd><p>The reduced chi-squared statistics of the fit for each data set.  Here,
<cite>fit_shape</cite> is an arbitrary array shape which depends upon the shape of
the output fit coordinates defined by the user.</p>
</dd>
<dt><strong>fixed</strong><span class="classifier">numpy.ndarray of bool (n_dimensions,), optional</span></dt><dd><p>If supplied, <cite>True</cite> values indicate that the width of the Gaussian
along the corresponding axis should not be altered in the output
result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled_matrices</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The scaled weighting kernel with shape
(n_data_sets, fit_shape, 1, n_dimensions) where <cite>fit_shape</cite> is
determined by the shape of the output fit coordinates supplied by the
user, and <cite>n_data_sets</cite> is the number of data sets to be fit.  The
third axis (of size 1), is a dummy dimension required for Numba to
compile successfully.  The last dimension contains the new scaled
inverse <span class="math notranslate nohighlight">\(\alpha_{scaled,k}^{-1}\)</span> values as described in
<a class="reference internal" href="#grig.resample_utils.scaled_adaptive_weight_matrix" title="grig.resample_utils.scaled_adaptive_weight_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">scaled_adaptive_weight_matrix()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.scaled_adaptive_weight_matrix">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">scaled_adaptive_weight_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rchi2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#scaled_adaptive_weight_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.scaled_adaptive_weight_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Scales a Gaussian weighting kernel based on a prior fit.</p>
<p>In the standard resampling algorithm, a polynomial fit may weight each
sample (<span class="math notranslate nohighlight">\(x\)</span>) according to its distance from the reference position at
which the fit is derived (<span class="math notranslate nohighlight">\(x_{ref}\)</span>) such that samples closer to the
reference position have more influence on the fit than those that are
farther.  The weighting function used is:</p>
<div class="math notranslate nohighlight">
\[w(x) = exp \left(
   -\sum_{k=1}^{K}{\frac{(x_{ref, k} - x_k)^2}{2 \sigma_k^2}}
           \right)\]</div>
<p>in <span class="math notranslate nohighlight">\(K\)</span> dimensions where <span class="math notranslate nohighlight">\(\sigma\)</span> (supplied to this function
via <cite>sigma</cite>) is a scaling factor, equivalent to the standard deviation of
a normal distribution.  Following a fit, it is also possible to generate
a reduced chi-squared statistic (<span class="math notranslate nohighlight">\(\chi_r^2\)</span>) which measures the
“goodness” of fit.</p>
<p>With this information we can rescale <cite>sigma</cite> in an attempt to get
<span class="math notranslate nohighlight">\(\chi_r^2 \rightarrow 1\)</span> i.e., get a good fit within noise
limitations.  This function assumes that if <span class="math notranslate nohighlight">\(\chi_r^2 &lt; 1\)</span>, the
samples have been over-fit, and therefore, the weighting function should be
“widened” to allow more distant samples to have a stronger influence on the
fit and subsequent <span class="math notranslate nohighlight">\(\chi_r^2\)</span> calculation.  Likewise, if
<span class="math notranslate nohighlight">\(\chi_r^2 &gt; 1\)</span>, this implies that the weighting function should be
truncated so that the fit focuses more strongly on providing a good fit
to nearby samples.  i.e., there is likely structure away from the fit
location that cannot be modelled well by a polynomial of the given order.</p>
<p>To accomplish this, the weighting kernel is rescaled such that:</p>
<div class="math notranslate nohighlight">
\[\chi_r^2 \prod_{k=1}^{K}{\sigma_{scaled, k}^2} =
    \prod_{k=1}^{K}{\sigma_k^2}\]</div>
<p>The reason is that for a multivariate Gaussian:</p>
<div class="math notranslate nohighlight">
\[\int_{R^K} exp \left(
    -\frac{1}{2} (x - x_{ref})^T \Sigma^{-1} (x - x_{ref})
\right)
= (2 \pi)^{K/2} |\Sigma|^{1/2}\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma^2 = diag(\Sigma)\)</span>:</p>
<div class="math notranslate nohighlight">
\[|\Sigma| \propto \prod_{k=1}^{K}{\sigma_k^2} \propto \chi_r\]</div>
<p>Note that in this specific implementation, the shape of the weighting
kernel remains unchanged and only the overall size is allowed to vary.
Therefore, a single scaling factor (<span class="math notranslate nohighlight">\(\beta\)</span>) is applied over all
dimensions such that:</p>
<div class="math notranslate nohighlight">
\[\sigma_{scaled, k} = \frac{\sigma_k}{\sqrt{\beta}}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\beta = \chi_r^{1 / K}\]</div>
<p>To reduce subsequent calculations, a scaled <span class="math notranslate nohighlight">\(\alpha\)</span> value is passed
out instead of <span class="math notranslate nohighlight">\(\sigma_{scaled}\)</span> where:</p>
<div class="math notranslate nohighlight">
\[\alpha = 2 \sigma^2\]</div>
<p>Therefore, the final output value will be:</p>
<div class="math notranslate nohighlight">
\[\alpha_{scaled, k}^{-1} = \frac{\beta}{2 \sigma_k^2}\]</div>
<p>Finally, scaling does not need to occur across all dimensions, and it is
possible to fix the shape of the kernel in one or more dimensions by using
the <cite>fixed</cite> parameter.  If this is the case:</p>
<div class="math notranslate nohighlight">
\[\beta = \chi_r^{\frac{1}{K - K_{fixed}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(K_{fixed}\)</span> is the number dimensions in which scaling has been
disabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The standard deviations of the Gaussian for each dimensional component
used for distance weighting of each sample in the initial fit.</p>
</dd>
<dt><strong>rchi2</strong><span class="classifier">float</span></dt><dd><p>The reduced chi-squared statistic of the fit.</p>
</dd>
<dt><strong>fixed</strong><span class="classifier">numpy.ndarray of bool (n_dimensions,), optional</span></dt><dd><p>If supplied, <cite>True</cite> values indicate that the width of the Gaussian
along the corresponding axis should not be altered in the output
result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverse_alpha</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The scaled <cite>sigma</cite> values converted to the inverse <cite>alpha</cite> array,
required by <a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_scaled" title="grig.resample_utils.calculate_adaptive_distance_weights_scaled"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_scaled()</span></code></a> to
create a set of weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.shaped_adaptive_weight_matrices">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">shaped_adaptive_weight_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rchi2_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_mscp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance_offsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#shaped_adaptive_weight_matrices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.shaped_adaptive_weight_matrices" title="Link to this definition">¶</a></dt>
<dd><p>Wrapper for <cite>shaped_adaptive_weight_matrix</cite> over multiple values.</p>
<p>Please see <a class="reference internal" href="#grig.resample_utils.shaped_adaptive_weight_matrix" title="grig.resample_utils.shaped_adaptive_weight_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">shaped_adaptive_weight_matrix()</span></code></a> for details on how the
weighting kernel is modified using a scale factor and measure of the
derivatives of the fitting function.  This function performs the
calculation for multiple scaling factors (<span class="math notranslate nohighlight">\(\chi_r^2\)</span>) and
derivative measures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The standard deviations of the Gaussian for each dimensional component
used for the distance weighting of each sample in the initial fit.</p>
</dd>
<dt><strong>rchi2_values</strong><span class="classifier">numpy.ndarray (n_sets, shape)</span></dt><dd><p>The reduced chi-squared statistics of the fit for each data set.  Here,
<cite>shape</cite> is an arbitrary array shape which depends upon the shape of
the output fit coordinates defined by the user.</p>
</dd>
<dt><strong>gradient_mscp</strong><span class="classifier">numpy.ndarray (n_sets, shape, n_dimensions, n_dimensions)</span></dt><dd><p>An array where gradient_mscp[i, j] = derivative[i] * derivative[j] in
dimensions i and j.  Please see <a class="reference internal" href="#grig.resample_utils.derivative_mscp" title="grig.resample_utils.derivative_mscp"><code class="xref py py-func docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a> for further
information.  The last two dimensions must be Hermitian and real-valued
(symmetric) for each fit set/coordinate.</p>
</dd>
<dt><strong>density</strong><span class="classifier">numpy.ndarray (n_sets, shape)</span></dt><dd><p>The local relative density of the samples around the fit coordinate.  A
value of 1 represents uniform distribution.  Values greater than 1
indicate clustering around the fitting point, and values less than 1
indicate that samples are sparsely distributed around the fitting
point.  Please see <a class="reference internal" href="#grig.resample_utils.relative_density" title="grig.resample_utils.relative_density"><code class="xref py py-func docutils literal notranslate"><span class="pre">relative_density()</span></code></a> for further information.</p>
</dd>
<dt><strong>variance_offsets</strong><span class="classifier">numpy.ndarray (n_sets, shape)</span></dt><dd><p>The variance at the fit coordinate determined from the sample
coordinate distribution. i.e., if a fit is performed at the center of
the sample distribution, the variance is zero.  If done at 2-sigma from
the sample distribution center, the variance is 4.</p>
</dd>
<dt><strong>fixed</strong><span class="classifier">numpy.ndarray of bool (n_dimensions,), optional</span></dt><dd><p>If supplied, <cite>True</cite> values indicate that the width of the Gaussian
along the corresponding axis should not be altered in the output
result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>shape_matrices</strong><span class="classifier">numpy.ndarray (n_sets, shape, n_dimensions, n_dimensions)</span></dt><dd><p>Shape matrices defined for each set/coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.shaped_adaptive_weight_matrix">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">shaped_adaptive_weight_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rchi2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_mscp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#shaped_adaptive_weight_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.shaped_adaptive_weight_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Shape and scale the weighting kernel based on a prior fit.</p>
<p>In the standard resampling algorithm, a polynomial fit may weight each
sample coordinate (<span class="math notranslate nohighlight">\(x\)</span>) according to its distance from the reference
position at which the fit is derived (<span class="math notranslate nohighlight">\(x_{ref}\)</span>) such that samples
closer to the reference position have more influence on the fit than those
that are farther.  The weighting function used is:</p>
<div class="math notranslate nohighlight">
\[W = exp(-\Delta x^T A^{-1} \Delta x)\]</div>
<p>where <span class="math notranslate nohighlight">\({\Delta x}_k = x_{ref, k} - x_k\)</span> for dimension <span class="math notranslate nohighlight">\(k\)</span>, and
<span class="math notranslate nohighlight">\(A\)</span> is a symmetric positive definite matrix defining the “shape” of
the weighting kernel.  This effectively defines a multivariate Gaussian
centered on the reference point where overall size, rotation, and stretch
of each principle axis may be altered.  The goal of shaping the weighting
kernel <span class="math notranslate nohighlight">\(A\)</span>, is to produce a fit where the reduced chi-squared
statistic of the fit equal to one (<span class="math notranslate nohighlight">\(\chi_r^2 = 1\)</span>).  To derive the
shape <span class="math notranslate nohighlight">\(A\)</span>, an initial fit must have first been performed using a
square diagonal matrix <span class="math notranslate nohighlight">\(A_0\)</span>, whose diagonal elements are the square
of the <cite>sigma</cite> parameter (<span class="math notranslate nohighlight">\(diag(A_0) = 2 \sigma^2\)</span>).  It is then easy
to define <span class="math notranslate nohighlight">\(A_0^{-1}\)</span> in <span class="math notranslate nohighlight">\(K\)</span> dimensions as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_0^{-1} = \frac{1}{2}
    \begin{bmatrix}
        \frac{1}{\sigma_0^2} &amp; 0 &amp; \dots &amp; 0 \\
        0 &amp; \frac{1}{\sigma_1^2} &amp; \ddots &amp; \vdots \\
        \vdots &amp; \ddots &amp; \ddots &amp; 0 \\
        0 &amp; \dots &amp; 0 &amp; \frac{1}{\sigma_K^2}
    \end{bmatrix}\end{split}\]</div>
<p>Following (or during) the initial fit with <span class="math notranslate nohighlight">\(A_0\)</span>, the mean
square cross products of the derivatives evaluated at the sample
coordinates should be calculated using <a class="reference internal" href="#grig.resample_utils.derivative_mscp" title="grig.resample_utils.derivative_mscp"><code class="xref py py-func docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a>, where the
returned matrix has values:</p>
<div class="math notranslate nohighlight">
\[\bar{g}_{ij}^2 = \frac{\partial \bar{f}}{\partial X_i}
                 \frac{\partial \bar{f}}{\partial X_j}\]</div>
<p>for dimensions <span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(X_j\)</span> in K-dimensions, where
<span class="math notranslate nohighlight">\(\partial \bar{f} / \partial X_i\)</span> is the weighted mean of the partial
derivatives over all samples in the fit with respect to <span class="math notranslate nohighlight">\(X_i\)</span>, with
weighting defined by <span class="math notranslate nohighlight">\(W\)</span> (above) using <span class="math notranslate nohighlight">\(A_0^{-1}\)</span>.</p>
<p>The matrix <span class="math notranslate nohighlight">\(\bar{g}^2\)</span> is only used to define the shape of new
weighting kernel, not the overall size.  Therefore, it is normalized such
that <span class="math notranslate nohighlight">\(|\bar{g}^2| = 1\)</span>.</p>
<p>We can then use singular value decomposition to factorize <span class="math notranslate nohighlight">\(\bar{g}^2\)</span>
into:</p>
<div class="math notranslate nohighlight">
\[\bar{g}^2 = U S V^T\]</div>
<p>Here, the matrices <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(V^T\)</span> represent rotations (since
<span class="math notranslate nohighlight">\(|\bar{g}^2| &gt; 0\)</span>), and the singular values (<span class="math notranslate nohighlight">\(S\)</span>) can be
thought of as the magnitudes of the semi-axes of an ellipsoid in
K-dimensional space.  Naively, this provides us with a basis from which to
determine the final “shape” matrix where:</p>
<div class="math notranslate nohighlight">
\[A^{-1} = \beta\, \bar{g}^2\]</div>
<p>and <span class="math notranslate nohighlight">\(\beta\)</span> is an as yet undetermined scaling factor representing
the overall size of the new kernel.  The resulting weighting kernel has the
shape of an ellipsoid with the smallest semi-axis oriented parallel to
the gradient.  In other words, the new weighting will result in a fit that
is less sensitive to distant samples in directions where the gradient is
high, and more sensitive to distant samples in directions where the
gradient is low.</p>
<p>However, we must still keep in mind that our overall goal is to get
<span class="math notranslate nohighlight">\(\chi_r^2 \rightarrow 1\)</span> when a fit is performed using the new
kernel <span class="math notranslate nohighlight">\(A\)</span>.  For example, if <span class="math notranslate nohighlight">\(\chi_r=1\)</span> in the initial fit,
there is no need to modify the kernel, and if <span class="math notranslate nohighlight">\(\chi_r &lt; 1\)</span>, then we
do not want to get an even better fit.</p>
<p>Another factor to consider is that we cannot be completely confident in
this new shape due to the distribution of samples.  If we are fitting at a
point that is away from the center of the sample distribution, it is
unadvisable to use a highly shaped kernel due to increased uncertainty in
the mean partial derivatives.  Furthermore, even if we are fitting close to
the center of the distribution, that does not mean that the derivative
calculations were not skewed by a few nearby samples when fitting in a
local depression of the sample density (for example, near the center of a
donut-like distribution).</p>
<p>We model our confidence (<span class="math notranslate nohighlight">\(\gamma\)</span>) in the “shape” using a logistic
function (see <a class="reference internal" href="#grig.resample_utils.stretch_correction" title="grig.resample_utils.stretch_correction"><code class="xref py py-func docutils literal notranslate"><span class="pre">stretch_correction()</span></code></a>) that factors in <span class="math notranslate nohighlight">\(\chi_r^2\)</span>,
a measure of the sample density profile (<span class="math notranslate nohighlight">\(\rho\)</span>) at the fit
coordinate, and from the deviation of the fit coordinate from the center of
the sample distribution (<span class="math notranslate nohighlight">\(\sigma_d\)</span>):</p>
<div class="math notranslate nohighlight">
\[\gamma = \frac{2}
         {\left(
             {1 + (2^{exp(\sigma)} - 1)e^{\rho (1 - \chi_r^2)}}
         \right)^{1/exp(\sigma)}} - 1\]</div>
<p>The density <span class="math notranslate nohighlight">\(\rho\)</span> is calculated using <a class="reference internal" href="#grig.resample_utils.relative_density" title="grig.resample_utils.relative_density"><code class="xref py py-func docutils literal notranslate"><span class="pre">relative_density()</span></code></a> which
sets <span class="math notranslate nohighlight">\(\rho=1\)</span> when the samples are uniformly distributed,
<span class="math notranslate nohighlight">\(\rho &gt; 1\)</span> when the distribution is concentrated on the fit
coordinate, and <span class="math notranslate nohighlight">\(0 &lt; \rho &lt; 1\)</span> when the fitting in a local depression
of the distribution density.  The deviation (<span class="math notranslate nohighlight">\(\sigma_d\)</span>) is
calculated using <a class="reference internal" href="#grig.resample_utils.offset_variance" title="grig.resample_utils.offset_variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code></a>.</p>
<p>The confidence parameter has asymptotes at <span class="math notranslate nohighlight">\(\gamma = \pm 1\)</span>, is
equal to zero at <span class="math notranslate nohighlight">\(\chi_r^2=1\)</span>, is positive for <span class="math notranslate nohighlight">\(\chi_r^2 &gt; 1\)</span>,
and is negative for <span class="math notranslate nohighlight">\(\chi_r^2 &lt; 1\)</span>.  Also, the magnitude increases
with <span class="math notranslate nohighlight">\(\rho\)</span>, and decreases with <span class="math notranslate nohighlight">\(\sigma_d\)</span>.  The final shape
matrix is then defined as:</p>
<div class="math notranslate nohighlight">
\[A^{-1} = \beta\, U S^{\gamma} V^T\]</div>
<p>Note that as <span class="math notranslate nohighlight">\(\gamma \rightarrow 0\)</span>, the kernel approaches that of
a spheroid.  For <span class="math notranslate nohighlight">\(\chi_r^2 &gt; 1\)</span>, the kernel approaches
<span class="math notranslate nohighlight">\(\bar{g}^2\)</span>.  When <span class="math notranslate nohighlight">\(\chi_r^2 &lt; 1\)</span>, the kernel effectively
rotates so that the fit becomes increasingly sensitive to samples along
the direction of the derivative.  The overall size of the kernel remains
constant since <span class="math notranslate nohighlight">\(|S^{\gamma}| = |\bar{g}^2| = 1\)</span>.</p>
<p>Finally, the only remaining factor to calculate is the scaling factor
<span class="math notranslate nohighlight">\(\beta\)</span> which is given as:</p>
<div class="math notranslate nohighlight">
\[\beta = \left( \frac{\chi_r}{|A_0|} \right)^{1/K}\]</div>
<p>Note that this scaling has the effect of setting</p>
<div class="math notranslate nohighlight">
\[\frac{|A_0|}{|A|} = \chi_r\]</div>
<p>The user has the option of fixing the kernel in certain dimensions such
that <span class="math notranslate nohighlight">\({A_0}_{k, k} = A_{k, k}\)</span>.  If this is the case, for any fixed
dimension <span class="math notranslate nohighlight">\(k\)</span> we set:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}{U S^{\gamma} V^T}_{k, k} = 1\\{U S^{\gamma} V^T}_{k, i \neq k}^2 = 0\\{U S^{\gamma} V^T}_{i \neq k, k}^2 = 0\end{aligned}\end{align} \]</div>
<p>meaning the scaling is unaltered for dimensions <span class="math notranslate nohighlight">\(k\)</span>, and no rotation
will be applied to any other dimension with respect to <span class="math notranslate nohighlight">\(k\)</span>.  Since
the overall size must be controlled through fewer dimensions,
<span class="math notranslate nohighlight">\(\beta\)</span> must take the form of a diagonal matrix:</p>
<div class="math notranslate nohighlight">
\[diag(\beta)_{i \in fixed} = \frac{1}{2 \sigma_i^2}
,\,\,
diag(\beta)_{i \notin fixed} =
    \left(
    \frac{\chi_r |A_0|}{|{U S^{\gamma} V^T}|}
    \prod_{i \in fixed}{2 \sigma_i^2}
    \right)^{1 / (K - K_{fixed})}\]</div>
<p>Once again <span class="math notranslate nohighlight">\(A^{-1} = \beta\, U S^{\gamma} V^T\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The standard deviations of the Gaussian for each dimensional component
used for the distance weighting of each sample in the initial fit.</p>
</dd>
<dt><strong>rchi2</strong><span class="classifier">float</span></dt><dd><p>The reduced chi-squared statistic of the fit.</p>
</dd>
<dt><strong>gradient_mscp</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>An array where gradient_mscp[i, j] = derivative[i] * derivative[j] in
dimensions i and j.  Please see <a class="reference internal" href="#grig.resample_utils.derivative_mscp" title="grig.resample_utils.derivative_mscp"><code class="xref py py-func docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a> for further
information.  Must be Hermitian and real-valued (symmetric).</p>
</dd>
<dt><strong>density</strong><span class="classifier">float, optional</span></dt><dd><p>The local relative density of the samples around the fit coordinate.  A
value of 1 represents uniform distribution.  Values greater than 1
indicate clustering around the fitting point, and values less than 1
indicate that samples are sparsely distributed around the fitting
point.  Please see <a class="reference internal" href="#grig.resample_utils.relative_density" title="grig.resample_utils.relative_density"><code class="xref py py-func docutils literal notranslate"><span class="pre">relative_density()</span></code></a> for further information.</p>
</dd>
<dt><strong>variance_offset</strong><span class="classifier">float, optional</span></dt><dd><p>The variance at the fit coordinate determined from the sample
coordinate distribution. i.e., if a fit is performed at the center of
the sample distribution, the variance is zero.  If done at 2-sigma from
the sample distribution center, the variance is 4.</p>
</dd>
<dt><strong>fixed</strong><span class="classifier">numpy.ndarray of bool (n_dimensions,), optional</span></dt><dd><p>If supplied, <cite>True</cite> values indicate that the width of the Gaussian
along the corresponding axis should not be altered in the output
result.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>The threshold below which SVD values are considered zero when
determining the matrix rank of <cite>derivative_mscp</cite>.  Please
see <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.linalg.matrix_rank()</span></code> for further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>shape_matrix</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>A matrix defining the shape of the weighting kernel required by
<a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_shaped" title="grig.resample_utils.calculate_adaptive_distance_weights_shaped"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_shaped()</span></code></a> to create a set of
weighting factors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.sigmoid">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.sigmoid" title="Link to this definition">¶</a></dt>
<dd><p>Evaluate a scaled and shifted logistic function.</p>
<p>The sigmoid function has the form:</p>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1}{1 + e^{\beta (x - \alpha)}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta\)</span> is the scaling <cite>factor</cite>, and <span class="math notranslate nohighlight">\(\alpha\)</span> is an
<cite>offset</cite> applied to <cite>x</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The independent variable.  If an array is supplied, must be the same
shape as <cite>factor</cite> and <cite>offset</cite> (if both/either are also arrays).</p>
</dd>
<dt><strong>factor</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The scaling factor applied to <cite>x</cite>.  If an array is supplied, must be
the same shape as <cite>x</cite> and <cite>offset</cite> (if both/either are also arrays).</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The offset to applied to <cite>x</cite>.  If an array is supplied, must be
the same shape as <cite>x</cite> and <cite>factor</cite> (if both/either are also arrays).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">float or numpy.ndarray (shape)</span></dt><dd><p>The sigmoid function evaluated at <cite>x</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.single_polynomial_terms">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">single_polynomial_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#single_polynomial_terms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.single_polynomial_terms" title="Link to this definition">¶</a></dt>
<dd><p>Derive polynomial terms for a single coordinate given polynomial exponents.</p>
<p>Raises a single coordinate by a power and then calculates the product over
all dimensions.  For example, the output of an (x, y) vector with
<cite>exponent=[[2, 3]]</cite> would be <span class="math notranslate nohighlight">\(x^2y^3\)</span>.</p>
<p>Note that multiple sets of exponents are expected to be provided during
this operation, so the <cite>exponents</cite> parameter should be a 2-dimensional
array.  The return value will be a 1-dimensional array with size equal
to the number of exponent sets provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coordinate</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The coordinate in each dimension.</p>
</dd>
<dt><strong>exponents</strong><span class="classifier">numpy.ndarray (n_exponents, N)</span></dt><dd><p>Sets of exponents to apply to the coordinate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (n_exponents,)</dt><dd><p>The polynomial terms for the coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_amat_beta">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_amat_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_amat_beta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_amat_beta" title="Link to this definition">¶</a></dt>
<dd><p>Convenience function returning matrices suitable for linear algebra.</p>
<p>Given independent variables <span class="math notranslate nohighlight">\(\Phi\)</span>, data <span class="math notranslate nohighlight">\(y\)</span>, and weights
<span class="math notranslate nohighlight">\(W\)</span>, returns matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> where:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}A = \Phi W \Phi^T\\B = \Phi W y\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>Polynomial terms of independent variables for each sample in the fit.</p>
</dd>
<dt><strong>data</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>Sample data values.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>Squared weights.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A, B</strong><span class="classifier">numpy.ndarray (n_terms, n_terms), numpy.ndarray (n_terms,)</span></dt><dd><p>The <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> terms described above.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_coefficients">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_coefficients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_coefficients" title="Link to this definition">¶</a></dt>
<dd><p>Find least squares solution of Ax=B and rank of A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amat</strong><span class="classifier">numpy.ndarray (ncoeffs, ndata)</span></dt><dd><p>The coefficient array.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">numpy.ndarray (ncoeffs,) or (ncoeffs, N)</span></dt><dd><p>Dependent values.  If 2-dimensional, the least-squares solution is
calculated for each column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rank, x</strong><span class="classifier">int, numpy.ndarray (min(M, N),)</span></dt><dd><p>The rank of <cite>amat</cite> and least-squares solution of x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_fit">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_distance_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_coordinate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">term_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_term_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_term_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_fit" title="Link to this definition">¶</a></dt>
<dd><p>Solve for a fit at a single coordinate.</p>
<p>Solves a polynomial fit of the form:</p>
<div class="math notranslate nohighlight">
\[f(\Phi) = \hat{c} \cdot \Phi\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{c}\)</span> are the derived polynomial coefficients for the
<span class="math notranslate nohighlight">\(\Phi\)</span> terms.  The <span class="math notranslate nohighlight">\(\Phi\)</span> terms are derived from the
independent values of the samples within the window region of the fit
coordinate, and from the fit coordinates themselves (see
<a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a> for further details).</p>
<p>The <span class="math notranslate nohighlight">\(\Phi\)</span> terms are pre-calculated early in the resampling algorithm
as this is a relatively cheap calculation, and we do not want to repeat
the same calculation multiple times.  For example, if sample[1] is within
the window region of point[1] and point[2], there should be no need
to repeat the polynomial term calculation twice.  Initially, one might
think that the actual coordinates could then be discarded, but there are a
number of calculations that depend on the sample coordinates relative to
the fitting points, which must therefore be dealt with “on-the-fly”.</p>
<p>EDGE CHECKING</p>
<p>The first of the on-the-fly calculation is the “edge check”.  Generally,
polynomial fits are not well-defined away from the sample distribution
from which they were derived.  This is especially true for higher order
fits that may fit the sample distribution well, but start to deviate wildly
when evaluated outside of the distribution.  The edge check step defines a
border around the distribution, outside of which the fit will be aborted.
There are a number of algorithms available which vary in robustness and
speed.  Please see <a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a> for details on available algorithms.</p>
<p>ORDER CHECKING</p>
<p>The next step is to determine if it is possible to perform a polynomial
fit of the given order.  For example, a 1-dimensional 2nd order polynomial
fit can only be derived from a minimum of 3 samples.  Additionally, if
some samples share the same coordinate, the fit becomes underdetermined, or
if dealing with multidimensional data, one needs to ensure that the samples
are not colinear.  If we also wish to propagate or derive valid errors, we
should ensure the system is overdetermined.  There are a number of order
checking algorithms which vary in robustness and speed.  Please see
<a class="reference internal" href="#grig.resample_utils.check_orders" title="grig.resample_utils.check_orders"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_orders()</span></code></a> for details on the available algorithms.</p>
<p>There are two available actions if the samples fail the order check.  The
first (default) is to simply abort fitting.  The second option is to
lower the order of fit until the samples meet the order check requirements.
This is only possible if the fit order is equal across all dimensions.  To
allow for variable orders, set the <cite>order_term_indices</cite> (see parameter
descriptions) to a valid value, and update <cite>window_phi</cite> and <cite>fit_phi</cite>
accordingly.</p>
<p>FITTING</p>
<p>If the above checks pass, a fit can be attempted.  There are actually
three types of fit that may be performed.  The first is the standard
polynomial fit described above.  The second is a weighted mean which may
explicitly be performed by setting <cite>mean_fit</cite> to <cite>True</cite>, or may be
performed on-the-fly if the order was lowered to zero during the order
check.  Finally, if <cite>is_covar</cite> was set to <cite>True</cite>, the <cite>window_values</cite> are
considered covariances to propagate, and a fit will derived by propagating
a weighted variance.</p>
<p>FINAL VALIDATION</p>
<p>If a polynomial fit was performed, a final check may be performed to
confirm that the solution does not deviate to significantly from the
expected values.  This is done by evaluating the reduced chi-squared
statistic of the fit (<span class="math notranslate nohighlight">\(\chi_r^2\)</span>).  If
<span class="math notranslate nohighlight">\(\sqrt{\chi_r^2} &gt; | \text{fit\_threshold} |\)</span>, the fit is not
accepted, and is aborted if <cite>fit_threshold</cite> &lt; 0, or set to the weighted
mean of the samples if <cite>fit_threshold</cite> &gt; 0.  No validation will be
performed if <cite>fit_threshold</cite> is set to zero (default).  Note that
<cite>window_error</cite> must be supplied in order for validation to be meaningful.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The independent coordinates within the window region of the fitting
coordinate.</p>
</dd>
<dt><strong>window_phi</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>The polynomial terms of <cite>window_coordinates</cite>.  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a> for further details.</p>
</dd>
<dt><strong>window_values</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The dependent values of the samples.</p>
</dd>
<dt><strong>window_error</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The associated 1-sigma error values for each sample in each set.  The
user may also supply an array of shape (1,) in which case all
samples in a set will share the same associated error value.  If the
shape is set to (0,) this indicates that no error values are available
for the samples.</p>
</dd>
<dt><strong>window_mask</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>A mask where <cite>False</cite> indicates that the associated sample should be
excluded from the fit.</p>
</dd>
<dt><strong>window_distance_weights</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The distance weighting factors applied to each sample in the fit.</p>
</dd>
<dt><strong>fit_coordinate</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The coordinate of the fitting point.</p>
</dd>
<dt><strong>fit_phi</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The polynomial of <cite>fit_coordinate</cite>.  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a> for further details.</p>
</dd>
<dt><strong>order</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.</p>
</dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that <cite>window_values</cite> contains covariance values
that should be propagated through algorithm.  If this is the case,
polynomial fitting is disabled, and a weighted variance is calculated
instead.</p>
</dd>
<dt><strong>fit_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>If fit_threshold is non-zero, perform a check on the goodness of the
fit.  When the reduced-chi statistic is greater than
abs(fit_threshold), the fit is determined to be a failure, and a
replacement value is used. If <cite>fit_threshold</cite> &lt; 0, failed fit values
will be set to <cite>cval</cite>.  If <cite>fit_threshold</cite> &gt; 0, failed fit values
will be replaced by the weighted mean.</p>
</dd>
<dt><strong>mean_fit</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, a weighted mean is performed instead of calculating a
polynomial fit.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>In a case that a fit is unable to be calculated at certain location,
<cite>cval</cite> determines the returned fit value.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, weight the samples in the fit by the inverse variance
(1 / window_error^2) in addition to distance weighting.</p>
</dd>
<dt><strong>estimate_covariance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, when determining the error on the fit and reduced
chi-squared, calculate the covariance of the fit coefficients using
<a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a>.  Otherwise, use
<a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse" title="grig.resample_utils.covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a>.</p>
</dd>
<dt><strong>order_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>An integer specifying which polynomial order validation algorithm to
use.  The default (1), will always be the more robust of all available
options.  For further information, please see <a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a>.</p>
</dd>
<dt><strong>term_indices</strong><span class="classifier">numpy.ndarray (&gt; max(order) + 1,), optional</span></dt><dd><p>A 1-dimensional lookup array for use in determining the correct phi
terms to use for a given polynomial order.  The order validation
algorithm ensures a fit of the requested order is possible.  If not,
and the orders are equal in all dimensions, it may also optionally
return a suggested order.  In this case, <cite>order_term_indices</cite> is used
to select the correct <cite>window_phi</cite> and <cite>fit_phi</cite> for a given order (k),
where terms are extracted via
<cite>phi[order_term_indices[k]:order_term_indices[k+1]]</cite>.</p>
</dd>
<dt><strong>derivative_term_map</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>A mapping array for the determination of derivatives from the
coefficients of the fit, and available terms in “phi”.  The shape of
the array is (n_dimensions, 3, n_derivative_terms).  This is only
required if the gradient is required as an output.  For a full
description of the derivative map, please see
<a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a>.</p>
</dd>
<dt><strong>derivative_term_indices</strong><span class="classifier">numpy.ndarray (max(order) + 1,), optional</span></dt><dd><p>If the fit order is allowed to vary, gives the indices in
<cite>derivative_term_map</cite> for a given symmetrical order.  The correct
<cite>derivative_term_map</cite> mapping for order k is given as
<cite>derivative_term_map[:, :, indices[k]:indices[k + 2]]</cite>.</p>
</dd>
<dt><strong>edge_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>Integer specifying the algorithm used to determine whether a fit should
be attempted with respect to the sample distribution.  Please see
<a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a> for further information.  The default (1), is
always the most robust of the available algorithms.</p>
</dd>
<dt><strong>edge_threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A threshold parameter determining how close an edge should be to the
center of the distribution during <a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a>.  Higher values
result in an edge closer to the sample mean.  A value should be
provided for each dimension.  A zero value in any dimension will result
in an infinite edge for that dimension.</p>
</dd>
<dt><strong>minimum_points</strong><span class="classifier">int, optional</span></dt><dd><p>Certain order validation algorithms check the number of available
samples as a means to determine what order of fit is appropriate.
If pre-calculated for the base <cite>order</cite>, it may be passed in here for
a slight speed advantage.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the error on the fit.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of all sample weights used in determining the
fit.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of only the distance weights used in
determining the fit.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the reduced chi-squared statistic for each of
the fits.</p>
</dd>
<dt><strong>get_cross_derivatives</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the derivative mean-squared-cross-products of the
samples in the fit.  See <a class="reference internal" href="#grig.resample_utils.derivative_mscp" title="grig.resample_utils.derivative_mscp"><code class="xref py py-func docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a> for further
information.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool optional</span></dt><dd><p>If <cite>True</cite>, return the offset of the fitting point from the sample
distribution.  See <a class="reference internal" href="#grig.resample_utils.offset_variance" title="grig.resample_utils.offset_variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code></a> for further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_result</strong><span class="classifier">8-tuple</span></dt><dd><dl class="simple">
<dt>fit_result[0]: Fitted value (float).</dt><dd><p>Set to <cite>cval</cite> on fit failure.</p>
</dd>
<dt>fit_result[1]: Error on the fit (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
<dt>fit_result[2]: Number of samples included in the fit (int).</dt><dd><p>Set to 0 on fit failure.</p>
</dd>
<dt>fit_result[3]: Weight sum (float).</dt><dd><p>Set to 0.0 on fit failure.</p>
</dd>
<dt>fit_result[4]: Distance weight sum (float).</dt><dd><p>Set to 0.0 on fit failure.</p>
</dd>
<dt>fit_result[5]: Reduced chi-squared statistic (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
<dt>fit_result[6]: Derivative mean-squared-cross-product (numpy.ndarray).</dt><dd><p>Set to shape (0, 0) on fit failure, and
(n_dimensions, n_dimensions) otherwise.</p>
</dd>
<dt>fit_result[7]: Offset variance from the distribution center (float).</dt><dd><p>Set to NaN on fit failure.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_fits">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_phi_terms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_phi_terms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_term_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_term_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_term_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_algorithm_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_distance_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_cross_derivatives</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_offset_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_fits"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_fits" title="Link to this definition">¶</a></dt>
<dd><p>Solve all fits within one intersection block.</p>
<p>This function is a wrapper for <a class="reference internal" href="#grig.resample_utils.solve_fit" title="grig.resample_utils.solve_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fit()</span></code></a> over all data sets and
fit points.  The main computations here involve:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Creating and populating the output arrays.</p></li>
<li><p>Selecting the correct samples within the region of each fitting
window.</p></li>
<li><p>Calculating the full weighting factors for the fits.</p></li>
</ol>
</div></blockquote>
<p>For further details on the actual fitting, please see <a class="reference internal" href="#grig.resample_utils.solve_fit" title="grig.resample_utils.solve_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_fit()</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sample_indices</strong><span class="classifier">numba.typed.List</span></dt><dd><p>A list of 1-dimensional numpy.ndarray (dtype=int) of length n_fits.
Each list element <cite>sample_indices[i]</cite>, contains the indices of samples
within the “window” region of <cite>fit_indices[i]</cite>.</p>
</dd>
<dt><strong>sample_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_samples)</span></dt><dd><p>The independent coordinates for each sample in n_dimensions</p>
</dd>
<dt><strong>sample_phi_terms</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>The polynomial terms of <cite>sample_coordinates</cite>.  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a> for further details.</p>
</dd>
<dt><strong>sample_data</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>The dependent values of the samples for n_sets, each containing
n_samples.</p>
</dd>
<dt><strong>sample_error</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>The associated 1-sigma error values for each sample in each set.  The
user may also supply an array of shape (n_sets, 1) in which case all
samples in a set will share the same associated error value.  If
the shape is set to (n_sets, 0), this indicates that no error values
are available for the samples.</p>
</dd>
<dt><strong>sample_mask</strong><span class="classifier">numpy.ndarray (n_sets, n_samples)</span></dt><dd><p>A mask where <cite>False</cite> indicates that the associated sample should be
excluded from all fits.</p>
</dd>
<dt><strong>fit_coordinates</strong><span class="classifier">numpy.ndarray (n_dimensions, n_fits)</span></dt><dd><p>The independent variables at each fit coordinate in d_dimensions.</p>
</dd>
<dt><strong>fit_phi_terms</strong><span class="classifier">numpy.ndarray (n_terms, n_fits)</span></dt><dd><p>The polynomial terms of <cite>fit_coordinates</cite>.  Please see
<a class="reference internal" href="#grig.resample_utils.polynomial_terms" title="grig.resample_utils.polynomial_terms"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a> for further details.</p>
</dd>
<dt><strong>order</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The desired order of the fit as a (1,) or (n_dimensions,) array.  If
only a single value is supplied, it will be applied over all
dimensions.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A distance weighting scaling factor per dimension.  The weighting
kernel is applied equally to all sets and samples.  For further
details, please see <a class="reference internal" href="#grig.resample_utils.calculate_distance_weights" title="grig.resample_utils.calculate_distance_weights"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_distance_weights()</span></code></a>.  Will be
overridden by <cite>adaptive_alpha</cite> if <cite>adaptive_alpha.size &gt; 0</cite>.</p>
</dd>
<dt><strong>adaptive_alpha</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Shape = (n_samples, n_sets, [1 or n_dimensions], n_dimensions).
Defines a weighting kernel for each sample in each set.  The function
<a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_scaled" title="grig.resample_utils.calculate_adaptive_distance_weights_scaled"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_scaled()</span></code></a> will be used for
kernels of shape (1, n_dimensions), and
<a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_shaped" title="grig.resample_utils.calculate_adaptive_distance_weights_shaped"><code class="xref py py-func docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_shaped()</span></code></a> will be used for
kernels of shape (n_dimensions, n_dimensions).  <cite>adaptive_alpha</cite> is
a required parameter due to Numba constraints, and will override
the <cite>alpha</cite> parameter unless it has a size of 0.  Therefore, to
disable, please set the size of any dimension to zero.</p>
</dd>
<dt><strong>is_covar</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that <cite>sample_data</cite> contains covariance values
that should be propagated through algorithm.  If this is the case,
polynomial fitting is disabled, and a weighted variance is calculated
instead.</p>
</dd>
<dt><strong>mean_fit</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, a weighted mean is performed instead of calculating a
polynomial fit.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>In a case that a fit is unable to be calculated at certain location,
<cite>cval</cite> determines the fill value for the output <cite>fit</cite> array at those
locations.</p>
</dd>
<dt><strong>fit_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>If fit_threshold is non-zero, perform a check on the goodness of the
fit.  When the reduced-chi statistic is greater than
abs(fit_threshold), the fit is determined to be a failure, and a
replacement value is used. If <cite>fit_threshold</cite> &lt; 0, failed fit values
will be set to <cite>cval</cite>.  If <cite>fit_threshold</cite> &gt; 0, failed fit values will
be replaced by the weighted mean.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, weight the samples in the fit by the inverse variance
(1 / sample_error^2) in addition to distance weighting.</p>
</dd>
<dt><strong>estimate_covariance</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, calculate the covariance of the fit coefficients using
<a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a>.  Otherwise, use
<a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse" title="grig.resample_utils.covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a>.</p>
</dd>
<dt><strong>order_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>An integer specifying which polynomial order validation algorithm to
use.  The default (1), will always be the more robust of all available
options.  For further information, please see <a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a>.</p>
</dd>
<dt><strong>order_term_indices</strong><span class="classifier">numpy.ndarray (&gt; max(order) + 1,), optional</span></dt><dd><p>A 1-dimensional lookup array for use in determining the correct phi
terms to use for a given polynomial order.  The order validation
algorithm ensures a fit of the requested order is possible.  If not,
and the orders are equal in all dimensions, it may also optionally
return a suggested order.  In this case, <cite>order_term_indices</cite> is used
to select the correct <cite>sample_phi_terms</cite> and <cite>fit_phi_terms</cite> for a
given order (k), where terms are extracted via
<cite>phi[order_term_indices[k]:order_term_indices[k + 2]]</cite>.</p>
</dd>
<dt><strong>derivative_term_map</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>A mapping array for the determination of derivatives from the
coefficients of the fit, and available terms in “phi”.  The shape of
the array is (n_dimensions, 3, n_derivative_terms).  This is only
required if the gradient is required as an output.  For a full
description of the derivative map, please see
<a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a>.</p>
</dd>
<dt><strong>derivative_term_indices</strong><span class="classifier">numpy.ndarray (max(order) + 1,), optional</span></dt><dd><p>If the fit order is allowed to vary, gives the indices in
<cite>derivative_term_map</cite> for a given symmetrical order.  The correct
<cite>derivative_term_map</cite> mapping for order k is given as
<cite>derivative_term_map[:, :, indices[k]:indices[k + 2]]</cite>.</p>
</dd>
<dt><strong>edge_algorithm_idx</strong><span class="classifier">int, optional</span></dt><dd><p>Integer specifying the algorithm used to determine whether a fit should
be attempted with respect to the sample distribution.  Please see
<a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a> for further information.  The default (1), is
always the most robust of the available algorithms.</p>
</dd>
<dt><strong>edge_threshold</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>A threshold parameter determining how close an edge should be to the
center of the distribution during <a class="reference internal" href="#grig.resample_utils.check_edges" title="grig.resample_utils.check_edges"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_edges()</span></code></a>.  Higher values
result in an edge closer to the sample mean.  A value should be
provided for each dimension.  A zero value in any dimension will result
in an infinite edge for that dimension.</p>
</dd>
<dt><strong>minimum_points</strong><span class="classifier">int, optional</span></dt><dd><p>Certain order validation algorithms check the number of available
samples as a means to determine what order of fit is appropriate.
If pre-calculated for the base <cite>order</cite>, it may be passed in here for
a slight speed advantage.</p>
</dd>
<dt><strong>get_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the error on the fit.</p>
</dd>
<dt><strong>get_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the number of samples used when determining the fit
at each fitting point.</p>
</dd>
<dt><strong>get_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of all sample weights used in determining the
fit at each point.</p>
</dd>
<dt><strong>get_distance_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the sum of only the distance weights used in
determining the fit at each point.</p>
</dd>
<dt><strong>get_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the reduced chi-squared statistic for each of the
fitted points.</p>
</dd>
<dt><strong>get_cross_derivatives</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, return the derivative mean-squared-cross-products of the
samples for each of the fitted points.  See <a class="reference internal" href="#grig.resample_utils.derivative_mscp" title="grig.resample_utils.derivative_mscp"><code class="xref py py-func docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a>
for further information.</p>
</dd>
<dt><strong>get_offset_variance</strong><span class="classifier">bool optional</span></dt><dd><p>If <cite>True</cite>, return the offset of the fitting point from the sample
distribution.  See <a class="reference internal" href="#grig.resample_utils.offset_variance" title="grig.resample_utils.offset_variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code></a> for further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fit_results</strong><span class="classifier">8-tuple of numpy.ndarray</span></dt><dd><p>fit_results[0]: Fitted values.
fit_results[1]: Error on the fit.
fit_results[2]: Number of samples in each fit.
fit_results[3]: Weight sums.
fit_results[4]: Distance weight sums.
fit_results[5]: Reduced chi-squared statistic.
fit_results[6]: Derivative mean-squared-cross-products.
fit_results[7]: Offset variances from the sample distribution center.</p>
<p>All arrays except for fit_results[6] have the shape (n_sets, n_fits)
or (0, 0) depending on whether <cite>get_&lt;name&gt;</cite> is <cite>True</cite> or <cite>False</cite>
respectively.  The derivative MSCP is of shape
(n_sets, n_fits, n_dimensions, n_dimensions) if requested, and
(1, 0, 0, 0) otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_inverse_covariance_matrices">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_inverse_covariance_matrices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighted_amat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_residual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_inverse_covariance_matrices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_inverse_covariance_matrices" title="Link to this definition">¶</a></dt>
<dd><p>Inverse covariance matrices on fit coefficients from errors and residuals.</p>
<p>A utility function to calculate the inverse covariance matrices of the fit
coefficients (<span class="math notranslate nohighlight">\(c\)</span>) based on the <span class="math notranslate nohighlight">\(1\sigma\)</span> error values of the
sample measurements and/or the residuals of the fit
<span class="math notranslate nohighlight">\(y - c \cdot \Phi\)</span>.</p>
<p>The function used to calculate the error covariance may be either
<a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a> or
<a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse" title="grig.resample_utils.covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a>.  However,
<a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a> will always be used to
calculate the covariance matrix derived from residuals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">numpy.ndarray (nterms, N)</span></dt><dd><p>The polynomial terms for each of the N samples.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The 1-sigma error values for each sample.</p>
</dd>
<dt><strong>residuals</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The residuals of the fit y - c.phi.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weighting of each sample in the fit.</p>
</dd>
<dt><strong>error_weighted_amat</strong><span class="classifier">numpy.ndarray (nterms, nterms), optional</span></dt><dd><p>The matrix <span class="math notranslate nohighlight">\(A = \Phi^T W Var(y) W \Phi\)</span>, optionally passed in for
speed if pre-calculated.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or float, optional</span></dt><dd><p>The rank of <cite>error_weighted_amat</cite>, if provided, and it’s rank was
pre-calculated.  Otherwise, it will be solved for.</p>
</dd>
<dt><strong>calculate_error</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, calculate the covariance of the fit coefficients based upon
the <cite>error</cite> values.</p>
</dd>
<dt><strong>calculate_residual</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, calculate the covariance of the fit coefficients based upon
<cite>residuals</cite> of the fit.</p>
</dd>
<dt><strong>estimate_covariance</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, calculate the covariance of the fit coefficients from the
<cite>error</cite> values using <a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a>.
Otherwise, use <a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse" title="grig.resample_utils.covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>e_inv, r_inv</strong><span class="classifier">numpy.ndarray, numpy.ndarray</span></dt><dd><p>The inverse covariance calculated from <cite>error</cite>, and the inverse
covariance calculated from <cite>residuals</cite>.  If <cite>calculate_error</cite> is True,
the shape of e_cov will be (nterms, nterms) or (0, 0) otherwise.  The
same is true for <cite>calculate_residual</cite> and r_cov.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_mean_fit">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_mean_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_mean_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_mean_fit" title="Link to this definition">¶</a></dt>
<dd><p>Return the weighted mean of data, variance, and reduced chi-squared.</p>
<p>For <cite>data</cite> (<span class="math notranslate nohighlight">\(y\)</span>), <cite>error</cite> (<span class="math notranslate nohighlight">\(\sigma\)</span>), and weights (<span class="math notranslate nohighlight">\(w\)</span>),
the weighted mean is given as:</p>
<div class="math notranslate nohighlight">
\[\bar{y} = \frac{\sum_{i=1}^{N}{w_i y_i}}
               {\sum_{i=1}^{N}{w_i}}\]</div>
<p>The returned variance (<span class="math notranslate nohighlight">\(V\)</span>) will depend on <cite>use_error</cite>.  If
<cite>use_error</cite> is <cite>True</cite>:</p>
<div class="math notranslate nohighlight">
\[V = \frac{\sum_{i=1}^{N}{(w_i\sigma_i)^2}}{(\sum_{i=1}^{N}{w_i})^2}\]</div>
<p>If <cite>use_error</cite> is <cite>False</cite>:</p>
<div class="math notranslate nohighlight">
\[V = \frac{1}{N - 1}
    \frac{\sum_{i=1}^{N}{w_i (y_i - \bar{y})^2}}
         {\sum_{i=1}^{N}{w_i}}\]</div>
<p>Finally, the reduced chi-squared statistic is given as:</p>
<div class="math notranslate nohighlight">
\[\chi_r^2 = \frac{N}{N - 1}
   \frac{\sum_{i=1}^{N}{w_i (y_i - \bar{y})^2 / \sigma_i^2}}
        {\sum_{i=1}^{N}{w_i}}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\chi_r^2 = 1\)</span> is <cite>use_error</cite> is <cite>False</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The data array consisting of N samples.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The associated 1-sigma error values for each of the N data samples.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weighting applied to each of the N data samples.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>The sum of the weights, optionally passed in for speed if
pre-calculated.</p>
</dd>
<dt><strong>calculate_variance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, calculate the variance.  Otherwise, variance will be
returned as a float value of zero.</p>
</dd>
<dt><strong>calculate_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, calculate the reduced chi-squared statistic.  Otherwise, it
will be returned as a float value of zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean, variance, rchi2</strong><span class="classifier">float, float, float</span></dt><dd><p>The weighted mean, variance and reduced chi-squared statistic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_polynomial_fit">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_polynomial_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_term_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_rchi2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calculate_derivative_mscp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_covariance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_polynomial_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_polynomial_fit" title="Link to this definition">¶</a></dt>
<dd><p>Derive a polynomial fit from samples, then calculate fit at single point.</p>
<p>The fit to the sample distribution is given as</p>
<div class="math notranslate nohighlight">
\[f(\Phi) = \hat{c} \cdot \Phi\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> contains products of the sample coordinates for each
coefficient term.  The coefficients <span class="math notranslate nohighlight">\(\hat{c}\)</span> are solved for using
least-squares fitting and then applied to calculate the fitted value at a
single point <span class="math notranslate nohighlight">\(f(\Phi_{fit})\)</span>.</p>
<p>It is also possible to return an on the fit as a variance.  If a valid
error is supplied, it will be propagated.  If no valid errors are
available, they will be calculated from residuals on the fit.</p>
<p>The reduced chi-squared (<span class="math notranslate nohighlight">\(\chi^2\)</span>) statistic may also be calculated,
but is only really meaningful if valid errors were supplied.  Otherwise,
<span class="math notranslate nohighlight">\(\chi^2 \equiv 1\)</span>.</p>
<p>Finally, the covariance of gradients between dimensions may also be
returned.  Note that these are the weighted mean of all sample gradients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi_samples</strong><span class="classifier">numpy.ndarray (n_terms, n_samples)</span></dt><dd><p>The array of independent terms for each sample.</p>
</dd>
<dt><strong>phi_point</strong><span class="classifier">numpy.ndarray (n_terms,)</span></dt><dd><p>The array containing the independent terms at the fitting point.</p>
</dd>
<dt><strong>data</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The array of sample values.</p>
</dd>
<dt><strong>error</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The array of error values for each sample.  Note that if errors are
unavailable, an array of size 0 may be supplied.  If this is the case,
and an error on the fit is required, it will be derived from the
residuals of the fit from the data.  In addition, the reduced
chi-squared statistic will always be 1.0 if derived from residuals.</p>
</dd>
<dt><strong>distance_weight</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The distance weighting factor (not including any error weighting)
applied to each sample in the fit.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">numpy.ndarray (n_samples,)</span></dt><dd><p>The full weighting factor applied to each sample in the fit.</p>
</dd>
<dt><strong>derivative_term_map</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>A mapping array for the determination of derivatives from the
coefficients of the fit, and available terms in “phi”.  The shape of
the array is (n_dimensions, 3, n_derivative_terms).  This is only
required if the gradient is required as an output.  For a full
description of the derivative map, please see
<a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map" title="grig.resample_utils.polynomial_derivative_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a>.</p>
</dd>
<dt><strong>calculate_variance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, calculate the variance on the fit.  The variance will be
calculated irrespectively if a valid error was supplied, and the
reduced chi-squared statistic is required as a return value.</p>
</dd>
<dt><strong>calculate_rchi2</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, calculate the reduced chi-squared statistic of the fit.
Note that valid errors must be supplied for this to be meaningful.</p>
</dd>
<dt><strong>calculate_derivative_mscp</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, calculate the covariance of the derivatives at the fit
point.</p>
</dd>
<dt><strong>error_weighting</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, indicates that <cite>weights</cite> includes an error weighting
factor of 1/sigma^2.  This allows for a slight speed increase when
performing the fit as some mathematical terms will not need to be
recalculated.</p>
</dd>
<dt><strong>estimate_covariance</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, uses <a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse" title="grig.resample_utils.estimated_covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a> instead
of <a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse" title="grig.resample_utils.covariance_matrix_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a> when determining the variance.
This is suggested if the errors are not well-behaved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fit_value, variance, rchi2, gradients</strong><span class="classifier">float, float, float, numpy.ndarray</span></dt><dd><p>The value of the fit at the fit point.  The variance and reduced
chi-squared will only be calculated if <cite>calculate_variance</cite> and
<cite>calculate_rchi2</cite> are respectively set to <cite>True</cite>.  The <cite>gradients</cite>
matrix is an (n_dimensions, n_dimensions) array where
gradients[i, j] = dx_i * dx_j.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_rchi2_from_error">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_rchi2_from_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_rchi2_from_error"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_rchi2_from_error" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced chi-squared given residuals and sample errors.</p>
<p>For <cite>weights</cite> <span class="math notranslate nohighlight">\(w\)</span>, <cite>errors</cite> <span class="math notranslate nohighlight">\(\sigma\)</span>, and residuals <span class="math notranslate nohighlight">\(r\)</span>
where <span class="math notranslate nohighlight">\(r = y - f(x)\)</span>, the reduced chi-squared is given as:</p>
<div class="math notranslate nohighlight">
\[\chi_r^2 = \frac{N}{N - M}
           \frac{\sum_{i=1}^{N}{w_i r_i^2 / \sigma_i^2}}
                {\sum_{i=1}^{N}{w_i}}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is given by <cite>rank</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The residuals to the fit, or y - f(x).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weights to each sample in the fit.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The 1-sigma measurement errors for each sample in the fit.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>The sum of the sample weights, optionally passed in for speed.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or float, optional</span></dt><dd><p>The degrees of freedom used in the reduced chi-squared value is taken
as N - rank.  The default is 1 and applies the Bessel correction.
If N &lt; rank, rank is automatically set to N - 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rchi2</strong><span class="classifier">float</span></dt><dd><p>The reduced chi-squared value for the fit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.solve_rchi2_from_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">solve_rchi2_from_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#solve_rchi2_from_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.solve_rchi2_from_variance" title="Link to this definition">¶</a></dt>
<dd><p>Return the reduced chi-squared given residuals and constant variance.</p>
<p>For <cite>weights</cite> <span class="math notranslate nohighlight">\(w\)</span>, <cite>variance</cite> <span class="math notranslate nohighlight">\(V\)</span>, and residuals <span class="math notranslate nohighlight">\(r\)</span>
where <span class="math notranslate nohighlight">\(r = y - f(x)\)</span>, the reduced chi-squared is given as:</p>
<div class="math notranslate nohighlight">
\[\chi_r^2 = \frac{1}{N - M}
           \frac{\sum_{i=1}^{N}{w_i r_i^2}}
                {V \sum_{i=1}^{N}{w_i}}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is given by <cite>rank</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The residuals to the fit, or y - f(x).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weights to each sample in the fit.</p>
</dd>
<dt><strong>variance</strong><span class="classifier">int or float</span></dt><dd><p>The constant variance of the fit.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>The sum of the sample weights, optionally passed in for speed.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int or float, optional</span></dt><dd><p>The degrees of freedom used in the reduced chi-squared value is taken
as N - rank.  The default is 1 and applies the Bessel correction.
If N &lt; rank, rank is automatically set to N - 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rchi2</strong><span class="classifier">float</span></dt><dd><p>The reduced chi-squared value for the fit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.sscp">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">sscp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#sscp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.sscp" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the sum-of-squares-and-cross-products of a matrix.</p>
<p>For the matrix <span class="math notranslate nohighlight">\(A\)</span>, calculates <span class="math notranslate nohighlight">\(A^TA\)</span>.  If weights (<span class="math notranslate nohighlight">\(W\)</span>)
are provided.</p>
<div class="math notranslate nohighlight">
\[sscp = WA^TAW^T\]</div>
<p>Note that the <cite>weight</cite> should only contain the diagonal elements of
<span class="math notranslate nohighlight">\(W\)</span>, and as such should be a 1-dimensional array.</p>
<p>If <cite>normalize=True</cite>:</p>
<div class="math notranslate nohighlight">
\[sscp = \frac{WA^TAW^T}{trace(W^TW)}\]</div>
<p>where <span class="math notranslate nohighlight">\(W = I\)</span>, the identity matrix if <cite>weight</cite> is not supplied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">numpy.ndarray (M, N)</span></dt><dd><p>Input matrix.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">numpy.ndarray (N,), optional</span></dt><dd><p>Weights to be applied during sscp.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, scales result as described above.  Default is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray of numpy.float64 (M, M)</dt><dd><p>Square output array containing the sum-of-squares-and-cross-products
matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.stretch_correction">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">stretch_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rchi2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance_offset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#stretch_correction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.stretch_correction" title="Link to this definition">¶</a></dt>
<dd><p>A sigmoid function used by the “shaped” adaptive resampling algorithm.</p>
<p>This sigmoid function is applied when determining the severity of stretch
(<span class="math notranslate nohighlight">\(s\)</span>) applied to principle axes of a rotated weighting kernel.  The
correction term (<span class="math notranslate nohighlight">\(\gamma\)</span>) is applied as:</p>
<div class="math notranslate nohighlight">
\[s_{corrected} = s^\gamma\]</div>
<p>Since the stretch values are determined from the singular values of
a normalized Hermitian matrix <span class="math notranslate nohighlight">\(A\)</span> (see
<a class="reference internal" href="#grig.resample_utils.shaped_adaptive_weight_matrix" title="grig.resample_utils.shaped_adaptive_weight_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">shaped_adaptive_weight_matrix()</span></code></a>), where <span class="math notranslate nohighlight">\(|A| \equiv 1\)</span>, then:</p>
<div class="math notranslate nohighlight">
\[\prod_{k=1}^{K}{s_k} = \prod_{k=1}^{K}{s_{corrected, k}} = 1\]</div>
<p>in <span class="math notranslate nohighlight">\(K\)</span> dimensions.  In other words, this does not affect the overall
size (or volume) of the weighting kernel.</p>
<p>The correction factor is calculated using <a class="reference internal" href="#grig.resample_utils.half_max_sigmoid" title="grig.resample_utils.half_max_sigmoid"><code class="xref py py-func docutils literal notranslate"><span class="pre">half_max_sigmoid()</span></code></a> using
<span class="math notranslate nohighlight">\(c=1\)</span>, lower and upper asymptotes as -1 and 1, such that the midpoint
is fixed at zero when <span class="math notranslate nohighlight">\(x=0\)</span>.  After making the necessary
substitutions, the correction factor is given as:</p>
<div class="math notranslate nohighlight">
\[\gamma = \frac{2}
         {\left( {1 + (2^{\nu} - 1)e^{B(1 - x)}} \right)^{1/\nu}} - 1\]</div>
<p>We then set the rate as <span class="math notranslate nohighlight">\(B = \rho\)</span> where <span class="math notranslate nohighlight">\(\rho\)</span> is the
<cite>density</cite> as determined by <a class="reference internal" href="#grig.resample_utils.relative_density" title="grig.resample_utils.relative_density"><code class="xref py py-func docutils literal notranslate"><span class="pre">relative_density()</span></code></a>, and the point of
inflection as <span class="math notranslate nohighlight">\(exp(\sigma)\)</span> where <span class="math notranslate nohighlight">\(\sigma^2\)</span> is the
<cite>variance_offset</cite> as determined by <a class="reference internal" href="#grig.resample_utils.offset_variance" title="grig.resample_utils.offset_variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code></a>.  Finally,
setting <span class="math notranslate nohighlight">\(x = \chi_r^2\)</span> we arrive at:</p>
<div class="math notranslate nohighlight">
\[\gamma = \frac{2}
         {\left(
             {1 + (2^{exp(\sigma)} - 1)e^{\rho (1 - \chi_r^2)}}
         \right)^{1/exp(\sigma)}} - 1\]</div>
<p>As <span class="math notranslate nohighlight">\(\gamma \rightarrow 0\)</span>, the resulting shape becomes more
symmetrical.  This will be the case when the fitting point is away from
the center of the sample distribution (high <span class="math notranslate nohighlight">\(\sigma^2\)</span>), the fit
occurs in a low density area (low <span class="math notranslate nohighlight">\(\beta\)</span>), or
<span class="math notranslate nohighlight">\(\chi_r^2 \rightarrow 1\)</span>.</p>
<p>It should be noted that <span class="math notranslate nohighlight">\(s_{corrected} \rightarrow s\)</span> as
<span class="math notranslate nohighlight">\(\chi_r^2 \rightarrow \infty\)</span>.  However, in the range
<span class="math notranslate nohighlight">\(0 &lt; \chi_r^2 &lt; 1\)</span>, the correction factor is actually negative, with
<span class="math notranslate nohighlight">\(\gamma \rightarrow -1\)</span> as <span class="math notranslate nohighlight">\(\chi_r^2 \rightarrow 0\)</span>.  This
has the effect of effectively rotating the shape so that its major axis is
perpendicular to the mean sample gradient rather than parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rchi2</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The reduced chi-squared statistic of the initial fit.</p>
</dd>
<dt><strong>density</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The local relative density at the fitting point (see
<a class="reference internal" href="#grig.resample_utils.relative_density" title="grig.resample_utils.relative_density"><code class="xref py py-func docutils literal notranslate"><span class="pre">relative_density()</span></code></a>).</p>
</dd>
<dt><strong>variance_offset</strong><span class="classifier">int or float or numpy.ndarray (shape)</span></dt><dd><p>The variance at the fitting with respect to the coordinate distribution
of the sample used in the fit.  Please see <a class="reference internal" href="#grig.resample_utils.offset_variance" title="grig.resample_utils.offset_variance"><code class="xref py py-func docutils literal notranslate"><span class="pre">offset_variance()</span></code></a> for
further information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>correction</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The correction factor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For high valued inflection points, <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> will set values in the
denominator of the above equation to infinity, or 1, resulting in a
misleading correction factor of <span class="math notranslate nohighlight">\(\pm 1\)</span>.  In order to counter this,
<a class="reference internal" href="#grig.resample_utils.half_max_sigmoid" title="grig.resample_utils.half_max_sigmoid"><code class="xref py py-func docutils literal notranslate"><span class="pre">half_max_sigmoid()</span></code></a> could not be used, and the calculation is done
“by hand” with spurious values resulting in a correction factor of zero.
This also requires some <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> hackery resulting in the final output
value being a <cite>numpy.ndarray</cite> in all cases.  When single valued inputs are
supplied, the output will be a single-valued array of zero dimensions
which should be suitable for subsequent calculations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.update_mask">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">update_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#update_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.update_mask" title="Link to this definition">¶</a></dt>
<dd><p>Updates a mask, setting False values where weights are zero or non-finite.</p>
<p>Utility function update a boolean <cite>mask</cite> in place given <cite>weights</cite>.  mask
values where weights are zero or non-finite will be set to <cite>False</cite>, and
the total number of <cite>True</cite> values is returned as output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (N,)</span></dt><dd><p>The weight values.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">numpy.ndarray of bool (N,)</span></dt><dd><p>The mask array to update in place.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>counts</strong><span class="classifier">int</span></dt><dd><p>The number of <cite>True</cite> mask values following the update.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.variance_from_offsets">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">variance_from_offsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#variance_from_offsets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.variance_from_offsets" title="Link to this definition">¶</a></dt>
<dd><p>Determine the variance given offsets from the expected value.</p>
<p>The output variance is:</p>
<div class="math notranslate nohighlight">
\[V = M^T \Sigma^{-1} M\]</div>
<p>where <cite>offsets</cite> (<span class="math notranslate nohighlight">\(M\)</span>) are the deviations <span class="math notranslate nohighlight">\(X - E[X]\)</span> and
<span class="math notranslate nohighlight">\(\Sigma\)</span> is the <cite>covariance</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offsets</strong><span class="classifier">numpy.ndarray (n_dimensions,)</span></dt><dd><p>The observational offsets from the expected value.</p>
</dd>
<dt><strong>covariance</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions)</span></dt><dd><p>The covariance matrix of observations.</p>
</dd>
<dt><strong>sigma_inv</strong><span class="classifier">numpy.ndarray (n_dimensions, n_dimensions), optional</span></dt><dd><p>The matrix inverse of the covariance matrix, optionally passed in for
speed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">float</span></dt><dd><p>The variance as described above.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.weighted_fit_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">weighted_fit_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#weighted_fit_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.weighted_fit_variance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate variance of a fit from the residuals of the fit to data.</p>
<p>For data <span class="math notranslate nohighlight">\(y\)</span>, weights <span class="math notranslate nohighlight">\(w\)</span>, and fitted function
<span class="math notranslate nohighlight">\(f(x) = fit(x, y, w)\)</span>, the residual is given as
<span class="math notranslate nohighlight">\(r = y - f(x)\)</span>.  The variance is then given as:</p>
<div class="math notranslate nohighlight">
\[V = \frac{1}{N - M}
    \frac{\sum_{i=1}^{N}{w_i r_i^2}}
         {\sum_{i=1}^{N}{w_i}}\]</div>
<p>where <span class="math notranslate nohighlight">\(M\)</span> = <cite>dof</cite> if <span class="math notranslate nohighlight">\(M &lt; N\)</span> and <span class="math notranslate nohighlight">\(M = N - 1\)</span> otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>The residuals given as data - fit.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>The weights.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>The sum of weights optionally passed in for speed if pre-calculated.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int, optional</span></dt><dd><p>The degrees of freedom used in the variance calculation is taken as
ndata - rank.  The default is 1 and applies the Bessel correction.
If ndata &lt; rank, rank is automatically set to ndata - 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">float</span></dt><dd><p>Variance calculated from residuals.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.weighted_mean">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">weighted_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#weighted_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.weighted_mean" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the weighted mean of a data set.</p>
<p>The weighted mean of data <span class="math notranslate nohighlight">\(y\)</span> with weights <span class="math notranslate nohighlight">\(w\)</span> is given as:</p>
<div class="math notranslate nohighlight">
\[\bar{y} = \frac{\sum_{i=1}^{N}{w_i y_i}}
               {\sum_{i=1}^{N}{w_i}}\]</div>
<p>This is a jit compiled <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> function for use within other
functions in <cite>sofia_redux.toolkit.resampling</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>Data.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>Weights.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>Sum of <cite>weights</cite>, optionally passed in for speed if pre-calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weighted_mean</strong><span class="classifier">float</span></dt><dd><p>The weighted mean.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.weighted_mean_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">weighted_mean_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#weighted_mean_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.weighted_mean_variance" title="Link to this definition">¶</a></dt>
<dd><p>Calculated mean weighted variance.</p>
<p>Propagate variance as:</p>
<div class="math notranslate nohighlight">
\[\bar{V} = \frac{\sum_{i=1}^{N}{w_i^2 V_i}}
               {(\sum_{i=1}^{N}{w_i})^2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>variance</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>Variance array.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>Weights.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>Sum of weights.  Passed in for speed if pre-calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean_variance</strong><span class="classifier">float</span></dt><dd><p>The propagated variance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="grig.resample_utils.weighted_variance">
<span class="sig-prename descclassname"><span class="pre">grig.resample_utils.</span></span><span class="sig-name descname"><span class="pre">weighted_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weightsum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/grig/resample_utils.html#weighted_variance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#grig.resample_utils.weighted_variance" title="Link to this definition">¶</a></dt>
<dd><p>Utility function to calculate the biased weighted variance.</p>
<p>Calculates the biased weighted variance from data errors as:</p>
<div class="math notranslate nohighlight">
\[V = \frac{\sum{(w\sigma)^2}}{(\sum{w})^2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>error</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>1-sigma error values.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray (ndata,)</span></dt><dd><p>Data weights.</p>
</dd>
<dt><strong>weightsum</strong><span class="classifier">int or float, optional</span></dt><dd><p>Sum of weights.  Optionally passed in for speed if pre-calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weighted_variance</strong><span class="classifier">float</span></dt><dd><p>The weighted variance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">grig package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a><ul>
<li><a class="reference internal" href="#module-grig.clean_image">grig.clean_image module</a><ul>
<li><a class="reference internal" href="#grig.clean_image.clean_image"><code class="docutils literal notranslate"><span class="pre">clean_image()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample">grig.resample module</a><ul>
<li><a class="reference internal" href="#grig.resample.Resample"><code class="docutils literal notranslate"><span class="pre">Resample</span></code></a></li>
<li><a class="reference internal" href="#grig.resample.resampler"><code class="docutils literal notranslate"><span class="pre">resampler()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample_base">grig.resample_base module</a><ul>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase"><code class="docutils literal notranslate"><span class="pre">ResampleBase</span></code></a><ul>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.block_loop"><code class="docutils literal notranslate"><span class="pre">ResampleBase.block_loop()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.calculate_minimum_points"><code class="docutils literal notranslate"><span class="pre">ResampleBase.calculate_minimum_points()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.combine_blocks"><code class="docutils literal notranslate"><span class="pre">ResampleBase.combine_blocks()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.estimate_feature_windows"><code class="docutils literal notranslate"><span class="pre">ResampleBase.estimate_feature_windows()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.estimate_max_bytes"><code class="docutils literal notranslate"><span class="pre">ResampleBase.estimate_max_bytes()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.features"><code class="docutils literal notranslate"><span class="pre">ResampleBase.features</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.fit_settings"><code class="docutils literal notranslate"><span class="pre">ResampleBase.fit_settings</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.fit_tree"><code class="docutils literal notranslate"><span class="pre">ResampleBase.fit_tree</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.get_grid_class"><code class="docutils literal notranslate"><span class="pre">ResampleBase.get_grid_class()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.global_resampling_values"><code class="docutils literal notranslate"><span class="pre">ResampleBase.global_resampling_values()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.grid_class"><code class="docutils literal notranslate"><span class="pre">ResampleBase.grid_class</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.multi_set"><code class="docutils literal notranslate"><span class="pre">ResampleBase.multi_set</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.n_samples"><code class="docutils literal notranslate"><span class="pre">ResampleBase.n_samples</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.n_sets"><code class="docutils literal notranslate"><span class="pre">ResampleBase.n_sets</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.pre_fit"><code class="docutils literal notranslate"><span class="pre">ResampleBase.pre_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.process_block"><code class="docutils literal notranslate"><span class="pre">ResampleBase.process_block()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.process_blocks"><code class="docutils literal notranslate"><span class="pre">ResampleBase.process_blocks()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.reduction_settings"><code class="docutils literal notranslate"><span class="pre">ResampleBase.reduction_settings()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.set_sample_tree"><code class="docutils literal notranslate"><span class="pre">ResampleBase.set_sample_tree()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.sufficient_memory_for"><code class="docutils literal notranslate"><span class="pre">ResampleBase.sufficient_memory_for()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_base.ResampleBase.window"><code class="docutils literal notranslate"><span class="pre">ResampleBase.window</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample_kernel">grig.resample_kernel module</a><ul>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel"><code class="docutils literal notranslate"><span class="pre">ResampleKernel</span></code></a><ul>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.block_loop"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.block_loop()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.combine_blocks"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.combine_blocks()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.degrees"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.degrees</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.estimate_feature_windows"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.estimate_feature_windows()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.exit_code"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.exit_code</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.exit_message"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.exit_message</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.kernel</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel_offsets"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.kernel_offsets</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.kernel_spacing"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.kernel_spacing</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.process_block"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.process_block()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.reduction_settings"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.reduction_settings()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.set_kernel"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.set_kernel()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.set_sample_tree"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.set_sample_tree()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel.ResampleKernel.spline"><code class="docutils literal notranslate"><span class="pre">ResampleKernel.spline</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample_kernel_utils">grig.resample_kernel_utils module</a><ul>
<li><a class="reference internal" href="#grig.resample_kernel_utils.apply_mask_to_kernel_set_arrays"><code class="docutils literal notranslate"><span class="pre">apply_mask_to_kernel_set_arrays()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel_utils.calculate_kernel_weights"><code class="docutils literal notranslate"><span class="pre">calculate_kernel_weights()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel_utils.solve_kernel_fit"><code class="docutils literal notranslate"><span class="pre">solve_kernel_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_kernel_utils.solve_kernel_fits"><code class="docutils literal notranslate"><span class="pre">solve_kernel_fits()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample_polynomial">grig.resample_polynomial module</a><ul>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial</span></code></a><ul>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.calculate_adaptive_smoothing"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.calculate_adaptive_smoothing()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.calculate_minimum_points"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.calculate_minimum_points()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.check_order"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.check_order()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.fit_tree"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.fit_tree</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.order"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.order</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.pre_fit"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.pre_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.process_block"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.process_block()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.reduction_settings"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.reduction_settings()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_polynomial.ResamplePolynomial.set_sample_tree"><code class="docutils literal notranslate"><span class="pre">ResamplePolynomial.set_sample_tree()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#grig.resample_polynomial.resamp"><code class="docutils literal notranslate"><span class="pre">resamp()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-grig.resample_utils">grig.resample_utils module</a><ul>
<li><a class="reference internal" href="#grig.resample_utils.apply_mask_to_set_arrays"><code class="docutils literal notranslate"><span class="pre">apply_mask_to_set_arrays()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.array_sum"><code class="docutils literal notranslate"><span class="pre">array_sum()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_scaled"><code class="docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_scaled()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.calculate_adaptive_distance_weights_shaped"><code class="docutils literal notranslate"><span class="pre">calculate_adaptive_distance_weights_shaped()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.calculate_distance_weights"><code class="docutils literal notranslate"><span class="pre">calculate_distance_weights()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.calculate_distance_weights_from_matrix"><code class="docutils literal notranslate"><span class="pre">calculate_distance_weights_from_matrix()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.calculate_fitting_weights"><code class="docutils literal notranslate"><span class="pre">calculate_fitting_weights()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_edge_with_box"><code class="docutils literal notranslate"><span class="pre">check_edge_with_box()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_edge_with_distribution"><code class="docutils literal notranslate"><span class="pre">check_edge_with_distribution()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_edge_with_ellipsoid"><code class="docutils literal notranslate"><span class="pre">check_edge_with_ellipsoid()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_edge_with_range"><code class="docutils literal notranslate"><span class="pre">check_edge_with_range()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_edges"><code class="docutils literal notranslate"><span class="pre">check_edges()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_orders"><code class="docutils literal notranslate"><span class="pre">check_orders()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_orders_with_bounds"><code class="docutils literal notranslate"><span class="pre">check_orders_with_bounds()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_orders_with_counts"><code class="docutils literal notranslate"><span class="pre">check_orders_with_counts()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.check_orders_without_bounds"><code class="docutils literal notranslate"><span class="pre">check_orders_without_bounds()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.convert_to_numba_list"><code class="docutils literal notranslate"><span class="pre">convert_to_numba_list()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.coordinate_covariance"><code class="docutils literal notranslate"><span class="pre">coordinate_covariance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.coordinate_mean"><code class="docutils literal notranslate"><span class="pre">coordinate_mean()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.covariance_matrix_inverse"><code class="docutils literal notranslate"><span class="pre">covariance_matrix_inverse()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.derivative_mscp"><code class="docutils literal notranslate"><span class="pre">derivative_mscp()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.distribution_variances"><code class="docutils literal notranslate"><span class="pre">distribution_variances()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.estimated_covariance_matrix_inverse"><code class="docutils literal notranslate"><span class="pre">estimated_covariance_matrix_inverse()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.evaluate_derivative"><code class="docutils literal notranslate"><span class="pre">evaluate_derivative()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.evaluate_derivatives"><code class="docutils literal notranslate"><span class="pre">evaluate_derivatives()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.fasttrapz"><code class="docutils literal notranslate"><span class="pre">fasttrapz()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.fit_phi_value"><code class="docutils literal notranslate"><span class="pre">fit_phi_value()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.fit_phi_variance"><code class="docutils literal notranslate"><span class="pre">fit_phi_variance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.fit_residual"><code class="docutils literal notranslate"><span class="pre">fit_residual()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.half_max_sigmoid"><code class="docutils literal notranslate"><span class="pre">half_max_sigmoid()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.logistic_curve"><code class="docutils literal notranslate"><span class="pre">logistic_curve()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.multiple_polynomial_terms"><code class="docutils literal notranslate"><span class="pre">multiple_polynomial_terms()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.multivariate_gaussian"><code class="docutils literal notranslate"><span class="pre">multivariate_gaussian()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.no_fit_solution"><code class="docutils literal notranslate"><span class="pre">no_fit_solution()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.offset_variance"><code class="docutils literal notranslate"><span class="pre">offset_variance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.polynomial_derivative_map"><code class="docutils literal notranslate"><span class="pre">polynomial_derivative_map()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.polynomial_exponents"><code class="docutils literal notranslate"><span class="pre">polynomial_exponents()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.polynomial_terms"><code class="docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.relative_density"><code class="docutils literal notranslate"><span class="pre">relative_density()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scale_coordinates"><code class="docutils literal notranslate"><span class="pre">scale_coordinates()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scale_forward_scalar"><code class="docutils literal notranslate"><span class="pre">scale_forward_scalar()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scale_forward_vector"><code class="docutils literal notranslate"><span class="pre">scale_forward_vector()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scale_reverse_scalar"><code class="docutils literal notranslate"><span class="pre">scale_reverse_scalar()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scale_reverse_vector"><code class="docutils literal notranslate"><span class="pre">scale_reverse_vector()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scaled_adaptive_weight_matrices"><code class="docutils literal notranslate"><span class="pre">scaled_adaptive_weight_matrices()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.scaled_adaptive_weight_matrix"><code class="docutils literal notranslate"><span class="pre">scaled_adaptive_weight_matrix()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.shaped_adaptive_weight_matrices"><code class="docutils literal notranslate"><span class="pre">shaped_adaptive_weight_matrices()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.shaped_adaptive_weight_matrix"><code class="docutils literal notranslate"><span class="pre">shaped_adaptive_weight_matrix()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.sigmoid"><code class="docutils literal notranslate"><span class="pre">sigmoid()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.single_polynomial_terms"><code class="docutils literal notranslate"><span class="pre">single_polynomial_terms()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_amat_beta"><code class="docutils literal notranslate"><span class="pre">solve_amat_beta()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_coefficients"><code class="docutils literal notranslate"><span class="pre">solve_coefficients()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_fit"><code class="docutils literal notranslate"><span class="pre">solve_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_fits"><code class="docutils literal notranslate"><span class="pre">solve_fits()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_inverse_covariance_matrices"><code class="docutils literal notranslate"><span class="pre">solve_inverse_covariance_matrices()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_mean_fit"><code class="docutils literal notranslate"><span class="pre">solve_mean_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_polynomial_fit"><code class="docutils literal notranslate"><span class="pre">solve_polynomial_fit()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_rchi2_from_error"><code class="docutils literal notranslate"><span class="pre">solve_rchi2_from_error()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.solve_rchi2_from_variance"><code class="docutils literal notranslate"><span class="pre">solve_rchi2_from_variance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.sscp"><code class="docutils literal notranslate"><span class="pre">sscp()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.stretch_correction"><code class="docutils literal notranslate"><span class="pre">stretch_correction()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.update_mask"><code class="docutils literal notranslate"><span class="pre">update_mask()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.variance_from_offsets"><code class="docutils literal notranslate"><span class="pre">variance_from_offsets()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.weighted_fit_variance"><code class="docutils literal notranslate"><span class="pre">weighted_fit_variance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.weighted_mean"><code class="docutils literal notranslate"><span class="pre">weighted_mean()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.weighted_mean_variance"><code class="docutils literal notranslate"><span class="pre">weighted_mean_variance()</span></code></a></li>
<li><a class="reference internal" href="#grig.resample_utils.weighted_variance"><code class="docutils literal notranslate"><span class="pre">weighted_variance()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="../grig/toolkit/splines/spline_examples.html"
                          title="previous chapter">The Spline class</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="grig.grid.html"
                          title="next chapter">grig.grid package</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/grig.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="grig.grid.html" title="grig.grid package"
             >next</a> |</li>
        <li class="right" >
          <a href="../grig/toolkit/splines/spline_examples.html" title="The Spline class"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../grig/index.html" >Grig Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>