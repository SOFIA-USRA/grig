<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grig.resample_kernel &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=9559a862"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.resample_kernel</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for grig.resample_kernel</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="kn">from</span> <span class="nn">grig.resample_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">scale_coordinates</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">grig.resample_kernel_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">solve_kernel_fits</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">grig.resample_base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ResampleBase</span><span class="p">,</span> <span class="n">_global_resampling_values</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">grig.tree.kernel_tree</span> <span class="kn">import</span> <span class="n">KernelTree</span>
<span class="kn">from</span> <span class="nn">grig.toolkit.multiproc</span> <span class="kn">import</span> <span class="n">unpickle_file</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ResampleKernel&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="ResampleKernel">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel">[docs]</a>
<span class="k">class</span> <span class="nc">ResampleKernel</span><span class="p">(</span><span class="n">ResampleBase</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span>
                 <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">robust</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negthresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kernel_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kernel_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kernel_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">degrees</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">knots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">knot_estimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
                 <span class="n">fix_knots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                 <span class="n">max_iteration</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                 <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">reduce_degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">imperfect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                 <span class="n">large_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class to resample data using kernel convolution.</span>

<span class="sd">        The kernel resampler may take regular or irregular spaced data, an</span>
<span class="sd">        irregular or regular kernel, and use kernel convolution to resample</span>
<span class="sd">        onto arbitrary coordinates where each output value is the convolution</span>
<span class="sd">        of the original sample data and the given kernel.  Here, irregular</span>
<span class="sd">        refers values that have specified coordinates.  i.e., they do not</span>
<span class="sd">        necessarily fall onto a regular grid.</span>

<span class="sd">        Generally, this class was designed to process irregular data when</span>
<span class="sd">        convolution is required.  If both the kernel and samples exist on</span>
<span class="sd">        regularly spaced grids, there are many alternatives that could be used</span>
<span class="sd">        to perform such a convolution much more quickly such as</span>
<span class="sd">        :func:`scipy.ndimage.convolve`.</span>

<span class="sd">        Convolution is achieved by creating a spline representation of the</span>
<span class="sd">        kernel which is then used to interpolate values of the kernel at the</span>
<span class="sd">        required locations.  Note that while the default settings assume that</span>
<span class="sd">        the kernel is perfect, noisy kernels may also be supplied and smoothed</span>
<span class="sd">        if required.  Please see the :class:`Spline` class for further details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : array_like of float</span>
<span class="sd">            (n_features, n_samples) array of independent values.  A local</span>
<span class="sd">            internal copy will be created if it is not a numpy.float64</span>
<span class="sd">            type.</span>
<span class="sd">        data : array_like of float</span>
<span class="sd">            (n_sets, n_samples) or (n_samples,) array of dependent values.</span>
<span class="sd">            multiple (n_sets) sets of data are supplied, then n_sets solutions</span>
<span class="sd">            will be calculated at each resampling point.</span>
<span class="sd">        kernel : array_like of float</span>
<span class="sd">            An n_features-dimensional array containing a regularly spaced</span>
<span class="sd">            resampling kernel or an irregular 1-D kernel array.  If the kernel</span>
<span class="sd">            is irregular, `kernel_offsets` must be provided.</span>
<span class="sd">        error : array_like of float, optional</span>
<span class="sd">            (n_sets, n_samples) or (n_samples,) array of error (1-sigma) values</span>
<span class="sd">            associated with the `data` array.  `error` will be used to</span>
<span class="sd">            weight fits, and be propagated to the output error values.  If not</span>
<span class="sd">            supplied, the error may still be calculated from residuals to the</span>
<span class="sd">            fit during :func:`ResamplePolynomial.__call__`.</span>
<span class="sd">        mask : array_like of bool, optional</span>
<span class="sd">            (n_sets, n_data) or (n_data,) array of bool where `True`</span>
<span class="sd">            indicates a valid data point that can be included the fitting</span>
<span class="sd">            and `False` indicates data points that should be excluded from</span>
<span class="sd">            the fit.  Masked points will be reflected in the output counts</span>
<span class="sd">            array.  If not supplied, all samples are considered valid.</span>
<span class="sd">        robust : float, optional</span>
<span class="sd">            Specifies an outlier rejection threshold for `data`. A data point</span>
<span class="sd">            is identified as an outlier if abs(x_i - x_med)/MAD &gt; robust, where</span>
<span class="sd">            x_med is the median, and MAD is the Median Absolute Deviation</span>
<span class="sd">            defined as 1.482 * median(abs(x_i - x_med)).</span>
<span class="sd">        negthresh : float, optional</span>
<span class="sd">            Specifies a negative value rejection threshold such that</span>
<span class="sd">            data &lt; (-stddev(data) * negthresh) will be excluded from the fit.</span>
<span class="sd">        kernel_spacing : float or numpy.ndarray (float), optional</span>
<span class="sd">            The spacing between kernel elements for all or each feature.  If</span>
<span class="sd">            an array is supplied, should be of shape (n_features,).  This</span>
<span class="sd">            feature may only be used for regular grids with n_features</span>
<span class="sd">            dimensions.  Either `kernel_spacing` or `kernel_offsets` must be</span>
<span class="sd">            supplied.</span>
<span class="sd">        kernel_offsets : tuple or array_like, optional</span>
<span class="sd">            If the kernel is regular, should be an n-dimensional tuple</span>
<span class="sd">            containing the grid indices in each dimension.  Otherwise, should</span>
<span class="sd">            be an array of shape (n_dimensions, kernel.size).  Either</span>
<span class="sd">            `kernel_spacing` or `kernel_offsets` must be supplied.</span>
<span class="sd">        kernel_weights : numpy.ndarray, optional</span>
<span class="sd">            Optional weights to supply to the spline fit for each data point.</span>
<span class="sd">            Should be the same shape as the supplied kernel.</span>
<span class="sd">        limits : numpy.ndarray (float), optional</span>
<span class="sd">            An array of shape (n_dimensions, 2) that may be supplied to set the</span>
<span class="sd">            minimum and maximum coordinate values used during the spline fit.</span>
<span class="sd">            For example, limits[1, 0] sets the minimum knot value in the second</span>
<span class="sd">            dimensions and limits[1, 1] sets the maximum knot value in the</span>
<span class="sd">            second dimension.  By default this is set to the minimum and</span>
<span class="sd">            maximum values of the coordinates in each dimension.</span>
<span class="sd">        degrees : int or numpy.ndarray (int), optional</span>
<span class="sd">            The degree of spline to fit in each dimension.  Either a scalar can</span>
<span class="sd">            be supplied pertaining to all dimensions, or an array of shape</span>
<span class="sd">            (n_dimensions,) can be used.</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            Used to specify the smoothing factor.  If set to `None`, the</span>
<span class="sd">            smoothing will be determined based on user settings or input data.</span>
<span class="sd">            If `exact` is `True`, smoothing will be disabled (zero).  If</span>
<span class="sd">            `exact`is `False`, smoothing will be set to n - sqrt(2 * n) where</span>
<span class="sd">            n is the number of data values.  If supplied, smoothing must be</span>
<span class="sd">            greater than zero.  See above for further details.  Note that if</span>
<span class="sd">            smoothing is zero, and the degrees are not equal over each</span>
<span class="sd">            dimension, smoothing will be set to `eps` due to numerical</span>
<span class="sd">            instabilities.</span>
<span class="sd">        knots : list or tuple or numpy.ndarray, optional</span>
<span class="sd">            A set of starting knot coordinates for each dimension.  If a list</span>
<span class="sd">            or tuple is supplied it should be of length n_dimensions where</span>
<span class="sd">            element i is an array of shape (n_knots[i]) for dimension i.  If</span>
<span class="sd">            an array is supplied, it should be of shape</span>
<span class="sd">            (n_dimension, max(n_knots)). Note that there must be at least</span>
<span class="sd">            2 * (degree + 1) knots for each dimension.  Unused or invalid</span>
<span class="sd">            knots may be set to NaN, at the end of each array.  Knot</span>
<span class="sd">            coordinates must also be monotonically increasing in each</span>
<span class="sd">            dimension.</span>
<span class="sd">        knot_estimate : numpy.ndarray (int), optional</span>
<span class="sd">            The maximum number of knots required for the spline fit in each</span>
<span class="sd">            dimension and of shape (n_dimensions,).  If not supplied, the knot</span>
<span class="sd">            estimate will be set to</span>
<span class="sd">            int((n / n_dimensions) ** n_dimensions^(-1)) or n_knots if</span>
<span class="sd">            knots were supplied and fixed.</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            A value where 0 &lt; eps &lt; 1.  This defines the magnitude used to</span>
<span class="sd">            identify singular values in the spline observation matrix (A).  If</span>
<span class="sd">            any row of A[:, 0] &lt; (eps * max(A[:,0])) it will be considered</span>
<span class="sd">            singular.</span>
<span class="sd">        fix_knots : bool, optional</span>
<span class="sd">            If `True`, do not attempt to modify or add knots to the spline fit.</span>
<span class="sd">            Only the initial supplied user knots will be used.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            A value in the range 0 &lt; tolerance &lt; 1 used to determine the exit</span>
<span class="sd">            criteria for the spline fit.  See above for further details.</span>
<span class="sd">        max_iteration : int, optional</span>
<span class="sd">            The maximum number of iterations to perform when solving for the</span>
<span class="sd">            spline fit.</span>
<span class="sd">        exact : bool, optional</span>
<span class="sd">            If `True`, the initial knots used will coincide with the actual</span>
<span class="sd">            input coordinates and smoothing will be set to zero.  No knots</span>
<span class="sd">            should be supplied by the user in this instance.</span>
<span class="sd">        reduce_degrees : bool, optional</span>
<span class="sd">            Only relevant if `exact` is `True`.  If set to `True`, the maximum</span>
<span class="sd">            allowable degree in each dimension will be limited to</span>
<span class="sd">            (len(unique(x)) // 2) - 1 where x are the coordinate values in any</span>
<span class="sd">            dimension.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            Number of points at which to switch to brute-force during the</span>
<span class="sd">            ball tree query algorithm.  See `sklearn.neighbours.BallTree`</span>
<span class="sd">            for further details.</span>
<span class="sd">        large_data : bool, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the ball tree should be created on</span>
<span class="sd">            subsets of the data.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.  This is important in determining which samples lie</span>
<span class="sd">            inside the window region of a resampling point, and when deriving</span>
<span class="sd">            distance weighting factors.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : Invalid inputs to __init__ or __call__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="n">kernel</span><span class="p">,</span>
            <span class="s1">&#39;kernel_spacing&#39;</span><span class="p">:</span> <span class="n">kernel_spacing</span><span class="p">,</span>
            <span class="s1">&#39;kernel_offsets&#39;</span><span class="p">:</span> <span class="n">kernel_offsets</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">kernel_weights</span><span class="p">,</span>
            <span class="s1">&#39;limits&#39;</span><span class="p">:</span> <span class="n">limits</span><span class="p">,</span>
            <span class="s1">&#39;degrees&#39;</span><span class="p">:</span> <span class="n">degrees</span><span class="p">,</span>
            <span class="s1">&#39;smoothing&#39;</span><span class="p">:</span> <span class="n">smoothing</span><span class="p">,</span>
            <span class="s1">&#39;knots&#39;</span><span class="p">:</span> <span class="n">knots</span><span class="p">,</span>
            <span class="s1">&#39;knot_estimate&#39;</span><span class="p">:</span> <span class="n">knot_estimate</span><span class="p">,</span>
            <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="n">eps</span><span class="p">,</span>
            <span class="s1">&#39;fix_knots&#39;</span><span class="p">:</span> <span class="n">fix_knots</span><span class="p">,</span>
            <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span>
            <span class="s1">&#39;max_iteration&#39;</span><span class="p">:</span> <span class="n">max_iteration</span><span class="p">,</span>
            <span class="s1">&#39;exact&#39;</span><span class="p">:</span> <span class="n">exact</span><span class="p">,</span>
            <span class="s1">&#39;reduce_degrees&#39;</span><span class="p">:</span> <span class="n">reduce_degrees</span><span class="p">,</span>
            <span class="s1">&#39;imperfect&#39;</span><span class="p">:</span> <span class="n">imperfect</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance_kwargs</span> <span class="o">=</span> <span class="n">distance_kwargs</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                         <span class="n">robust</span><span class="o">=</span><span class="n">robust</span><span class="p">,</span> <span class="n">negthresh</span><span class="o">=</span><span class="n">negthresh</span><span class="p">,</span>
                         <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="n">large_data</span><span class="o">=</span><span class="n">large_data</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the resampling kernel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">kernel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spacing between kernel grid points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">kernel_spacing</span>
        <span class="k">if</span> <span class="n">spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">scale_coordinates</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinate offsets for the kernel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">kernel_coordinates</span>
        <span class="k">return</span> <span class="n">scale_coordinates</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the degrees of the spline fit to the kernel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">degrees</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exit_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the exit code of the spline fit.</span>

<span class="sd">        Please see the :class:`Spline` class for further details on</span>
<span class="sd">        the meanings of each code.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">exit_code</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exit_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline exit message.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">exit_message</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline object for the kernel fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Spline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">spline</span>

<div class="viewcode-block" id="ResampleKernel.set_sample_tree">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.set_sample_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sample_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                        <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                        <span class="n">large_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the sample tree from input coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (float)</span>
<span class="sd">            The input coordinates of shape (n_features, n_samples).</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            Number of points at which to switch to brute-force during the</span>
<span class="sd">            ball tree query algorithm.  See `sklearn.neighbours.BallTree`</span>
<span class="sd">            for further details.</span>
<span class="sd">        large_data : bool, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the ball tree should be created on</span>
<span class="sd">            subsets of the data.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.  This is important in determining which samples lie</span>
<span class="sd">            inside the window region of a resampling point, and when deriving</span>
<span class="sd">            distance weighting factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_sample_tree</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_feature_windows</span><span class="p">(),</span>
            <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="n">large_data</span><span class="o">=</span><span class="n">large_data</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_args</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResampleKernel.estimate_feature_windows">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.estimate_feature_windows">[docs]</a>
    <span class="k">def</span> <span class="nf">estimate_feature_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the radius of the fitting window for each feature.</span>

<span class="sd">        The window for the resampling algorithm will be set to encompass the</span>
<span class="sd">        kernel extent over all dimensions.  Unlike the standard resampling</span>
<span class="sd">        algorithm, the coordinates of the data samples are irrelevant.</span>

<span class="sd">        The window radius is based on the kernel extent in this implementation.</span>

<span class="sd">        Since the resampling algorithm uses an ellipsoid window to determine</span>
<span class="sd">        possible candidates for fitting, the window is determined as an</span>
<span class="sd">        ellipsoid which circumscribes the cuboid kernel array.  Although there</span>
<span class="sd">        are an infinite number of possible ellipsoids, this particular method</span>
<span class="sd">        uses the constraints that principle axes of the ellipsoid and cuboid</span>
<span class="sd">        widths are at a constant ratio.  For example, in two dimensions where</span>
<span class="sd">        a and b are the principle axes of an ellipsoid, and w and h are the</span>
<span class="sd">        widths of the kernel:</span>

<span class="sd">        a/w = b/h; (w / 2a)^2 + (h / 2b)^2 = 1.</span>

<span class="sd">        This leads to us setting the principle axes as:</span>

<span class="sd">        a_i = sqrt(n / 4) * w_i + delta</span>

<span class="sd">        where w_i is the width of the kernel in dimension i in n-dimensions,</span>
<span class="sd">        and delta = spacing/1e6 so that any edge cases can be included safely.</span>
<span class="sd">        This is also valid in one dimension (a_i = w_i / 2).  Note that kernels</span>
<span class="sd">        are assumed to be exactly centered, so the width of a kernel in any</span>
<span class="sd">        dimension will be:</span>

<span class="sd">        w_i = spacing_i * (kernel.shape[i] - 1)</span>

<span class="sd">        Note that this implementation takes the width as 2 * the maximum</span>
<span class="sd">        absolute offset of the kernel for each dimension, so that irregular</span>
<span class="sd">        kernels may be safely used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        window : numpy.ndarray (n_features,)</span>
<span class="sd">            The principle axes of an ellipsoid used to create a fitting</span>
<span class="sd">            region around each resampling point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        <span class="n">temp_tree</span> <span class="o">=</span> <span class="n">KernelTree</span><span class="p">(</span><span class="n">temp_shape</span><span class="p">)</span>
        <span class="n">temp_tree</span><span class="o">.</span><span class="n">parse_kernel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_args</span><span class="p">[</span><span class="s1">&#39;kernel&#39;</span><span class="p">],</span>
            <span class="n">kernel_spacing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_args</span><span class="p">[</span><span class="s1">&#39;kernel_spacing&#39;</span><span class="p">],</span>
            <span class="n">kernel_offsets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_args</span><span class="p">[</span><span class="s1">&#39;kernel_offsets&#39;</span><span class="p">])</span>
        <span class="n">max_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp_tree</span><span class="o">.</span><span class="n">extent</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">typical_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
            <span class="n">typical_spacing</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">temp_tree</span><span class="o">.</span><span class="n">kernel_coordinates</span><span class="p">[</span><span class="n">feature</span><span class="p">])))</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">max_width</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">+=</span> <span class="n">typical_spacing</span> <span class="o">*</span> <span class="mf">1e-6</span>
        <span class="k">return</span> <span class="n">window</span></div>


<div class="viewcode-block" id="ResampleKernel.set_kernel">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.set_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">knots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">knot_estimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">fix_knots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">reduce_degrees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">imperfect</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the kernel for subsequent fitting.</span>

<span class="sd">        During this process, a spline will be fit to describe the kernel at</span>
<span class="sd">        all intermediate points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kernel : numpy.ndarray (float)</span>
<span class="sd">            The kernel to set.  Must have n_features dimensions.</span>
<span class="sd">        kernel_spacing : float or numpy.ndarray (float), optional</span>
<span class="sd">            The spacing between each kernel element in units of the</span>
<span class="sd">            coordinates. Either supplied as a single value for all features,</span>
<span class="sd">            or as an array of shape (n_features,) giving the kernel spacing</span>
<span class="sd">            for each feature.</span>
<span class="sd">        kernel_offsets : tuple or array_like, optional</span>
<span class="sd">            If the kernel is regular, should be an n-dimensional tuple</span>
<span class="sd">            containing the grid indices in each dimension.  Otherwise, should</span>
<span class="sd">            be an array of shape (n_dimensions, kernel.size).</span>
<span class="sd">        weights : numpy.ndarray, optional</span>
<span class="sd">            Optional weights to supply to the spline fit for each data point.</span>
<span class="sd">            Should be the same shape as the supplied kernel.</span>
<span class="sd">        limits : numpy.ndarray (float), optional</span>
<span class="sd">            An array of shape (n_dimensions, 2) that may be supplied to set the</span>
<span class="sd">            minimum and maximum coordinate values used during the spline fit.</span>
<span class="sd">            For example, limits[1, 0] sets the minimum knot value in the second</span>
<span class="sd">            dimensions and limits[1, 1] sets the maximum knot value in the</span>
<span class="sd">            second dimension.  By default this is set to the minimum and</span>
<span class="sd">            maximum values of the coordinates in each dimension.</span>
<span class="sd">        degrees : int or numpy.ndarray (int), optional</span>
<span class="sd">            The degree of spline to fit in each dimension.  Either a scalar can</span>
<span class="sd">            be supplied pertaining to all dimensions, or an array of shape</span>
<span class="sd">            (n_dimensions,) can be used.</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            Used to specify the smoothing factor.  If set to `None`, the</span>
<span class="sd">            smoothing will be determined based on user settings or input data.</span>
<span class="sd">            If `exact` is `True`, smoothing will be disabled (zero).  If</span>
<span class="sd">            `exact` is `False`, smoothing will be set to n - sqrt(2 * n)</span>
<span class="sd">            where n is the number of data values.  If supplied, smoothing</span>
<span class="sd">            must be greater than zero.  See above for further details.  Note</span>
<span class="sd">            that if smoothing is zero, and the degrees are not equal over</span>
<span class="sd">            each dimension, smoothing will be set to `eps` due to numerical</span>
<span class="sd">            instabilities.</span>
<span class="sd">        knots : list or tuple or numpy.ndarray, optional</span>
<span class="sd">            A set of starting knot coordinates for each dimension.  If a list</span>
<span class="sd">            or tuple is supplied it should be of length n_dimensions where</span>
<span class="sd">            element i is an array of shape (n_knots[i]) for dimension i.  If</span>
<span class="sd">            an array is supplied, it should be of shape</span>
<span class="sd">            (n_dimension, max(n_knots)). Note that there must be at least</span>
<span class="sd">            2 * (degree + 1) knots for each dimension.  Unused or invalid</span>
<span class="sd">            knots may be set to NaN, at the end of each array.  Knot</span>
<span class="sd">            coordinates must also be monotonically increasing in each</span>
<span class="sd">            dimension.</span>
<span class="sd">        knot_estimate : numpy.ndarray (int), optional</span>
<span class="sd">            The maximum number of knots required for the spline fit in each</span>
<span class="sd">            dimension and of shape (n_dimensions,).  If not supplied, the knot</span>
<span class="sd">            estimate will be set to</span>
<span class="sd">            int((n / n_dimensions) ** n_dimensions^(-1)) or n_knots if</span>
<span class="sd">            knots were supplied and fixed.</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            A value where 0 &lt; eps &lt; 1.  This defines the magnitude used to</span>
<span class="sd">            identify singular values in the spline observation matrix (A).  If</span>
<span class="sd">            any row of A[:, 0] &lt; (eps * max(A[:,0])) it will be considered</span>
<span class="sd">            singular.</span>
<span class="sd">        fix_knots : bool, optional</span>
<span class="sd">            If `True`, do not attempt to modify or add knots to the spline fit.</span>
<span class="sd">            Only the initial supplied user knots will be used.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            A value in the range 0 &lt; tolerance &lt; 1 used to determine the exit</span>
<span class="sd">            criteria for the spline fit.  See above for further details.</span>
<span class="sd">        max_iteration : int, optional</span>
<span class="sd">            The maximum number of iterations to perform when solving for the</span>
<span class="sd">            spline fit.</span>
<span class="sd">        exact : bool, optional</span>
<span class="sd">            If `True`, the initial knots used will coincide with the actual</span>
<span class="sd">            input coordinates and smoothing will be set to zero.  No knots</span>
<span class="sd">            should be supplied by the user in this instance.</span>
<span class="sd">        reduce_degrees : bool, optional</span>
<span class="sd">            Only relevant if `exact` is `True`.  If set to `True`, the maximum</span>
<span class="sd">            allowable degree in each dimension will be limited to</span>
<span class="sd">            (len(unique(x)) // 2) - 1 where x are the coordinate values in any</span>
<span class="sd">            dimension.</span>
<span class="sd">        imperfect : bool, optional</span>
<span class="sd">            If a spline fit to the kernel is allowed to be imperfect (`True`),</span>
<span class="sd">            will only raise an error on spline fitting if a major error was</span>
<span class="sd">            encountered.  Otherwise, fits will be permitted so long as a</span>
<span class="sd">            solution was reached, even if that solution did not meet</span>
<span class="sd">            expectations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kernel_spacing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kernel_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Kernel spacing or offsets must be supplied.&quot;</span><span class="p">)</span>

        <span class="c1"># Scale offsets or spacings</span>
        <span class="c1"># Kernel coordinates are always relative to the center.</span>

        <span class="c1"># offsets supersede spacings</span>
        <span class="k">if</span> <span class="n">kernel_offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scaled_offsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kernel_spacing</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
                <span class="n">scaled_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel_offsets</span><span class="p">[</span><span class="n">feature</span><span class="p">])</span>
                                      <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">[</span><span class="n">feature</span><span class="p">])</span>
            <span class="n">kernel_offsets</span> <span class="o">=</span> <span class="n">scaled_offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_offsets</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">kernel_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">kernel_spacing</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kernel_spacing</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">kernel_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">kernel_spacing</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
                                    <span class="n">kernel_spacing</span><span class="o">=</span><span class="n">kernel_spacing</span><span class="p">,</span>
                                    <span class="n">kernel_offsets</span><span class="o">=</span><span class="n">kernel_offsets</span><span class="p">,</span>
                                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                    <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span>
                                    <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
                                    <span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">,</span>
                                    <span class="n">knots</span><span class="o">=</span><span class="n">knots</span><span class="p">,</span>
                                    <span class="n">knot_estimate</span><span class="o">=</span><span class="n">knot_estimate</span><span class="p">,</span>
                                    <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                    <span class="n">fix_knots</span><span class="o">=</span><span class="n">fix_knots</span><span class="p">,</span>
                                    <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                                    <span class="n">max_iteration</span><span class="o">=</span><span class="n">max_iteration</span><span class="p">,</span>
                                    <span class="n">exact</span><span class="o">=</span><span class="n">exact</span><span class="p">,</span>
                                    <span class="n">reduce_degrees</span><span class="o">=</span><span class="n">reduce_degrees</span><span class="p">,</span>
                                    <span class="n">imperfect</span><span class="o">=</span><span class="n">imperfect</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResampleKernel.reduction_settings">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.reduction_settings">[docs]</a>
    <span class="k">def</span> <span class="nf">reduction_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_weighting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">absolute_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">fit_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                           <span class="n">edge_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">edge_algorithm</span><span class="o">=</span><span class="s1">&#39;distribution&#39;</span><span class="p">,</span>
                           <span class="n">is_covar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_threading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">use_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of reduction instructions based on user input.</span>

<span class="sd">        This method is responsible for determining, formatting, and checking</span>
<span class="sd">        a number variables required for the resampling algorithm based on</span>
<span class="sd">        user input.  For detailed descriptions of user options, please see</span>
<span class="sd">        :func:`ResamplePolynomial.__call__`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_weighting : bool, optional</span>
<span class="sd">            If `True` (default), weight polynomial fitting by the `error`</span>
<span class="sd">            values of each sample.</span>
<span class="sd">        absolute_weight : bool, optional</span>
<span class="sd">            If the kernel weights are negative, can lead to almost zero-like</span>
<span class="sd">            divisions in many of the algorithms.  If set to `True`, the sum of</span>
<span class="sd">            the absolute weights are used for normalization.</span>
<span class="sd">        fit_threshold : float, optional</span>
<span class="sd">            Not implemented for kernel fitting.</span>
<span class="sd">        cval : float, optional</span>
<span class="sd">            During fitting, any fit that does not meet the `order_algorithm`</span>
<span class="sd">            requirement will be set to this value. This will be NaN by default.</span>
<span class="sd">        edge_threshold : float or array_like or float</span>
<span class="sd">            If set to a value &gt; 0, edges of the fit will be masked out</span>
<span class="sd">            according to `edge_algorithm`. Values close to zero will result in</span>
<span class="sd">            a low degree of edge clipping, while values close to 1 clip edges</span>
<span class="sd">            to a greater extent.  The exact definition of `edge_threshold`</span>
<span class="sd">            depends on the algorithm.  For further details, please see</span>
<span class="sd">            :func:`resampling.resample_utils.check_edges`.</span>
<span class="sd">        edge_algorithm : str, optional</span>
<span class="sd">            Describes how to clip edges if edge_threshold is non-zero. The</span>
<span class="sd">            available algorithms are:</span>

<span class="sd">                - &#39;distribution&#39; (default): Statistics on sample distributions</span>
<span class="sd">                  are calculated, and if the resampling point is &gt; 1/threshold</span>
<span class="sd">                  standard deviations away from the sample mean, it will be</span>
<span class="sd">                  clipped.</span>
<span class="sd">                - &#39;ellipsoid&#39;: If the samples used to fit a</span>
<span class="sd">                  resampling point deviate from the resampling point</span>
<span class="sd">                  location by more than this amount, it will be clipped.</span>
<span class="sd">                - &#39;box&#39;: If the flattened 1-dimensional distribution</span>
<span class="sd">                  of samples center-of-mass deviates from the resampling</span>
<span class="sd">                  point location in any dimension, it will be clipped.</span>
<span class="sd">                - &#39;range&#39;: Over each dimension, check the distribution of</span>
<span class="sd">                  points is greater than edge_threshold to the &quot;left&quot; and</span>
<span class="sd">                  &quot;right&quot; of the resampling point.</span>
<span class="sd">        is_covar : bool, optional</span>
<span class="sd">            If True, the input data is treated as a covariance instead of</span>
<span class="sd">            a flux, and is propagated as if through a weighted mean.</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">            Specifies the maximum number of concurrently running jobs.  An</span>
<span class="sd">            attempt will be made to parallel process using a thread-pool if</span>
<span class="sd">            available, but will otherwise revert to the &quot;loky&quot; backend.</span>
<span class="sd">            Values of 0 or 1 will result in serial processing.  A negative</span>
<span class="sd">            value sets jobs to `n_cpus + 1 + jobs` such that -1 would use</span>
<span class="sd">            all cpus, and -2 would use all but one cpu.</span>
<span class="sd">        use_threading : bool, optional</span>
<span class="sd">            If `True`, force use of threads during multiprocessing.</span>
<span class="sd">        use_processes : bool, optional</span>
<span class="sd">            If `True`, force use of sub-processes during multiprocessing.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Optional keyword arguments to the reduction settings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        settings : dict</span>
<span class="sd">            The reduction settings.  Also, stored as</span>
<span class="sd">            :func:`ResamplePolynomial.fit_settings`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reduction_settings</span><span class="p">(</span>
            <span class="n">error_weighting</span><span class="o">=</span><span class="n">error_weighting</span><span class="p">,</span>
            <span class="n">fit_threshold</span><span class="o">=</span><span class="n">fit_threshold</span><span class="p">,</span>
            <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
            <span class="n">edge_threshold</span><span class="o">=</span><span class="n">edge_threshold</span><span class="p">,</span>
            <span class="n">edge_algorithm</span><span class="o">=</span><span class="n">edge_algorithm</span><span class="p">,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">use_threading</span><span class="o">=</span><span class="n">use_threading</span><span class="p">,</span>
            <span class="n">use_processes</span><span class="o">=</span><span class="n">use_processes</span><span class="p">)</span>
        <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;is_covar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_covar</span>

        <span class="k">if</span> <span class="n">absolute_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;absolute_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;absolute_weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">absolute_weight</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="k">return</span> <span class="n">settings</span></div>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">edge_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">edge_algorithm</span><span class="o">=</span><span class="s1">&#39;distribution&#39;</span><span class="p">,</span>
                 <span class="n">error_weighting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">absolute_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">is_covar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_threading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">use_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample data defined during initialization onto new coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : array_like or n-tuple of array_like</span>
<span class="sd">            args can take one of the following formats:</span>

<span class="sd">                - grid : n-tuple of array_like</span>
<span class="sd">                  Here `n` is the number of dimensions and each array should</span>
<span class="sd">                  be of shape (n_data,).  This indicates that resampling</span>
<span class="sd">                  should occur on a grid where the first argument</span>
<span class="sd">                  corresponds to the coordinates along the first dimension.</span>
<span class="sd">                - single point : n-tuple of float</span>
<span class="sd">                  `n` is the number of dimensions.  The coordinate to</span>
<span class="sd">                  resample onto.</span>
<span class="sd">                - irregular : array_like</span>
<span class="sd">                  An array of shape (n_dimensions, n_ndata) defining a</span>
<span class="sd">                  set of coordinates onto which to resample.</span>
<span class="sd">        cval : float, optional</span>
<span class="sd">            During fitting, any fit that does not meet the `order_algorithm`</span>
<span class="sd">            requirement will be set to this value. This will be NaN by default.</span>
<span class="sd">        edge_threshold : float or array_like or float</span>
<span class="sd">            If set to a value &gt; 0, edges of the fit will be masked out</span>
<span class="sd">            according to `edge_algorithm`. Values close to zero will result in</span>
<span class="sd">            a low degree of edge clipping, while values close to 1 clip edges</span>
<span class="sd">            to a greater extent.  The exact definition of `edge_threshold`</span>
<span class="sd">            depends on the algorithm.  For further details, please see</span>
<span class="sd">            :func:`resampling.resample_utils.check_edges`.</span>
<span class="sd">        edge_algorithm : str, optional</span>
<span class="sd">            Describes how to clip edges if edge_threshold is non-zero. The</span>
<span class="sd">            available algorithms are:</span>

<span class="sd">                - &#39;distribution&#39; (default): Statistics on sample distributions</span>
<span class="sd">                  are calculated, and if the resampling point is &gt; 1/threshold</span>
<span class="sd">                  standard deviations away from the sample mean, it will be</span>
<span class="sd">                  clipped.</span>
<span class="sd">                - &#39;ellipsoid&#39;: If the samples used to fit a</span>
<span class="sd">                  resampling point deviate from the resampling point</span>
<span class="sd">                  location by more than this amount, it will be clipped.</span>
<span class="sd">                - &#39;box&#39;: If the flattened 1-dimensional distribution</span>
<span class="sd">                  of samples center-of-mass deviates from the resampling</span>
<span class="sd">                  point location in any dimension, it will be clipped.</span>
<span class="sd">                - &#39;range&#39;: Over each dimension, check the distribution of</span>
<span class="sd">                  points is greater than edge_threshold to the &quot;left&quot; and</span>
<span class="sd">                  &quot;right&quot; of the resampling point.</span>
<span class="sd">        error_weighting : bool, optional</span>
<span class="sd">            If `True` (default), weight polynomial fitting by the `error`</span>
<span class="sd">            values of each sample.</span>
<span class="sd">        absolute_weight : bool, optional</span>
<span class="sd">            If the kernel weights are negative, can lead to almost zero-like</span>
<span class="sd">            divisions in many of the algorithms.  If set to `True`, the sum of</span>
<span class="sd">            the absolute weights are used for normalization.</span>
<span class="sd">        normalize : bool, optional</span>
<span class="sd">            If `True`, the data will be convolved with a normalized kernel</span>
<span class="sd">            such that sum(kernel) = 1.  Note that this may be sum(abs(kernel))</span>
<span class="sd">            if `absolute_weight` is `True`.</span>
<span class="sd">        is_covar : bool, optional</span>
<span class="sd">            If True, the input data is treated as a covariance instead of</span>
<span class="sd">            a flux, and is propagated as if through a weighted mean.</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">            Specifies the maximum number of concurrently running jobs.  An</span>
<span class="sd">            attempt will be made to parallel process using a thread-pool if</span>
<span class="sd">            available, but will otherwise revert to the &quot;loky&quot; backend.</span>
<span class="sd">            Values of 0 or 1 will result in serial processing.  A negative</span>
<span class="sd">            value sets jobs to `n_cpus + 1 + jobs` such that -1 would use</span>
<span class="sd">            all cpus, and -2 would use all but one cpu.</span>
<span class="sd">        use_threading : bool, optional</span>
<span class="sd">            If `True`, force use of threads during multiprocessing.</span>
<span class="sd">        use_processes : bool, optional</span>
<span class="sd">            If `True`, force use of sub-processes during multiprocessing.</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">            If `True`, If True returns the error which is given as the weighted</span>
<span class="sd">            RMS of the samples used for each resampling point.</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">            If `True` returns the number of samples used to fit each resampling</span>
<span class="sd">            point.</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">            If `True`, returns the sum of all sample weights (error and</span>
<span class="sd">            distance) used in the fit at each resampling point.</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">            If `True`, returns the sum of all sample distance weights (not</span>
<span class="sd">            including error) used in the fit at each resampling point.</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">            If `True`, returns the reduced chi-squared statistic of the fit</span>
<span class="sd">            at each resampling point.  Note that this is only valid if errors</span>
<span class="sd">            were supplied during :func:`ResamplePolynomial.__init__`.</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">            If `True`, returns the offset of the resampling point from the</span>
<span class="sd">            center of the sample distribution used to generate the fit as</span>
<span class="sd">            a variance.  i.e., a return value of 9 indicates a 3-sigma</span>
<span class="sd">            deviation of the resampling point from the sample distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit, [optional return values]</span>
<span class="sd">            The data fit at `args`.  Optional return values may also be</span>
<span class="sd">            returned if any of the get_* options are `True`.  If all are set</span>
<span class="sd">            to `True`, the return order is: fit, error, counts, weights,</span>
<span class="sd">            distance_weights, rchi2, cross_derivatives, offset_variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_call_arguments</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction_settings</span><span class="p">(</span>
            <span class="n">error_weighting</span><span class="o">=</span><span class="n">error_weighting</span><span class="p">,</span>
            <span class="n">absolute_weight</span><span class="o">=</span><span class="n">absolute_weight</span><span class="p">,</span>
            <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
            <span class="n">edge_threshold</span><span class="o">=</span><span class="n">edge_threshold</span><span class="p">,</span>
            <span class="n">edge_algorithm</span><span class="o">=</span><span class="n">edge_algorithm</span><span class="p">,</span>
            <span class="n">is_covar</span><span class="o">=</span><span class="n">is_covar</span><span class="p">,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">use_threading</span><span class="o">=</span><span class="n">use_threading</span><span class="p">,</span>
            <span class="n">use_processes</span><span class="o">=</span><span class="n">use_processes</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pre_fit</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">return_distance_weights</span> <span class="o">=</span> <span class="n">get_distance_weights</span>
            <span class="n">get_distance_weights</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_distance_weights</span> <span class="o">=</span> <span class="n">get_distance_weights</span>

        <span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">distance_weights</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
         <span class="n">distribution_offset_variance</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_loop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_tree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="p">,</span>
            <span class="n">settings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">get_error</span><span class="o">=</span><span class="n">get_error</span><span class="p">,</span>
            <span class="n">get_counts</span><span class="o">=</span><span class="n">get_counts</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="n">get_weights</span><span class="p">,</span>
            <span class="n">get_distance_weights</span><span class="o">=</span><span class="n">get_distance_weights</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="n">get_rchi2</span><span class="p">,</span>
            <span class="n">get_offset_variance</span><span class="o">=</span><span class="n">get_offset_variance</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">nzi</span> <span class="o">=</span> <span class="n">distance_weights</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">fit</span><span class="p">[</span><span class="n">nzi</span><span class="p">]</span> <span class="o">*=</span> <span class="n">distance_weights</span><span class="p">[</span><span class="n">nzi</span><span class="p">]</span>
            <span class="n">fit</span><span class="p">[</span><span class="o">~</span><span class="n">nzi</span><span class="p">]</span> <span class="o">=</span> <span class="n">cval</span>

        <span class="n">get_distance_weights</span> <span class="o">=</span> <span class="n">return_distance_weights</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_set</span><span class="p">:</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">distance_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">distribution_offset_variance</span> <span class="o">=</span> <span class="n">distribution_offset_variance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_error</span> <span class="ow">or</span> <span class="n">get_counts</span> <span class="ow">or</span> <span class="n">get_weights</span>
                <span class="ow">or</span> <span class="n">get_rchi2</span> <span class="ow">or</span> <span class="n">get_distance_weights</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">fit</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">error</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">counts</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">weights</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">distance_weights</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">sigma</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span>
                    <span class="n">distribution_offset_variance</span><span class="p">),)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fit</span>

<div class="viewcode-block" id="ResampleKernel.block_loop">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.block_loop">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">block_loop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sample_values</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                   <span class="n">settings</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">get_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">get_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform resampling reduction in parallel or series.</span>

<span class="sd">        Utility function to allow the resampling algorithm to process blocks</span>
<span class="sd">        of data in series or parallel, recombining the data once complete.</span>
<span class="sd">        Please see :func:`ResamplePolynomial.__call__` for descriptions of the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_values : numpy.ndarray</span>
<span class="sd">        error : numpy.ndarray</span>
<span class="sd">        mask : numpy.ndarray</span>
<span class="sd">        fit_tree : resampling.tree.PolynomialTree object</span>
<span class="sd">        sample_tree : resampling.tree.PolynomialTree object</span>
<span class="sd">        settings : dict</span>
<span class="sd">        iteration : int</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            For consistency with the resampler base only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_results : 8-tuple of numpy.ndarray</span>
<span class="sd">            In order: fit, error, counts, weights, distance weights,</span>
<span class="sd">                reduced chi-squared, MSCP derivatives, distribution offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_values</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                <span class="n">get_error</span><span class="p">,</span> <span class="n">get_counts</span><span class="p">,</span> <span class="n">get_weights</span><span class="p">,</span> <span class="n">get_distance_weights</span><span class="p">,</span>
                <span class="n">get_rchi2</span><span class="p">,</span> <span class="n">get_offset_variance</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">process_blocks</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                                    <span class="n">fit_tree</span><span class="p">,</span> <span class="n">jobs</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>

        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">sample_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_fits</span> <span class="o">=</span> <span class="n">fit_tree</span><span class="o">.</span><span class="n">n_members</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="o">.</span><span class="n">features</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">combine_blocks</span><span class="p">(</span>
            <span class="n">blocks</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">,</span> <span class="n">n_features</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cval&#39;</span><span class="p">],</span>
            <span class="n">get_error</span><span class="o">=</span><span class="n">get_error</span><span class="p">,</span>
            <span class="n">get_counts</span><span class="o">=</span><span class="n">get_counts</span><span class="p">,</span>
            <span class="n">get_weights</span><span class="o">=</span><span class="n">get_weights</span><span class="p">,</span>
            <span class="n">get_distance_weights</span><span class="o">=</span><span class="n">get_distance_weights</span><span class="p">,</span>
            <span class="n">get_rchi2</span><span class="o">=</span><span class="n">get_rchi2</span><span class="p">,</span>
            <span class="n">get_offset_variance</span><span class="o">=</span><span class="n">get_offset_variance</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResampleKernel.combine_blocks">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.combine_blocks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span>
                       <span class="n">get_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines the results from multiple reductions into one set.</span>

<span class="sd">        The resampling reduction may be performed in serial or parallel over</span>
<span class="sd">        multiple &quot;blocks&quot;, where each block contains a set of spatially</span>
<span class="sd">        close fit coordinates and all samples necessary to perform a fit</span>
<span class="sd">        over all points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blocks : n-tuple of processed reductions for n blocks.</span>
<span class="sd">        n_sets : int</span>
<span class="sd">            The number of data sets in the reduction.  Each set is contains</span>
<span class="sd">            the same sample coordinates as all other sets, but the sample</span>
<span class="sd">            values may vary.</span>
<span class="sd">        n_fits : int</span>
<span class="sd">            The number of fitting points over all blocks.</span>
<span class="sd">        n_dimensions : int</span>
<span class="sd">            The number of coordinate dimensions.</span>
<span class="sd">        cval : float</span>
<span class="sd">            The fill value for missing data in the output fit value arrays.</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">            If `True`, indicates that errors on the fit were calculated.</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">            If `True`, indicates that the number of samples used for each</span>
<span class="sd">            fit should be returned.</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">            If `True`, indicates that the total weight sum of all samples used</span>
<span class="sd">            in each fit should be returned.</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">            If `True`, indicates that the distance weight sum of all samples</span>
<span class="sd">            used in each fit should be returned.</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">            If `True`, indicates that the reduced chi-squared statistic for</span>
<span class="sd">            each fit should be returned.</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">            If `True`, indicates that the offset variance of the fit from the</span>
<span class="sd">            sample distribution should be returned.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            For consistency with ResampleBase only (not used).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : 7-tuple of numpy.ndarray</span>
<span class="sd">            results[0] = fitted values</span>
<span class="sd">            results[1] = error on the fit</span>
<span class="sd">            results[2] = counts</span>
<span class="sd">            results[3] = total weight sums</span>
<span class="sd">            results[4] = total distance weight sums</span>
<span class="sd">            results[5] = reduced chi-squared statistic</span>
<span class="sd">            results[6] = offset variance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The return value is always an 8-tuple, and the get_* keywords indicate</span>
<span class="sd">        whether the calculated values in the block reductions are valid.  If</span>
<span class="sd">        `False`, the corresponding output array will have the correct number of</span>
<span class="sd">        axes, but be of zero size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cval</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
            <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
            <span class="n">rchi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rchi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">fit_indices</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fit</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">error</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">counts</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">distance_weights</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">rchi2</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">offsets</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">fit</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">distance_weights</span><span class="p">,</span> <span class="n">rchi2</span><span class="p">,</span> <span class="n">offsets</span></div>


<div class="viewcode-block" id="ResampleKernel.process_block">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_kernel.ResampleKernel.process_block">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">process_block</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run :func:`solve_fits` on each block.</span>

<span class="sd">        Utility function that parses the settings and tree objects to something</span>
<span class="sd">        usable by the numba JIT compiled resampling functions.  This is not</span>
<span class="sd">        meant to be called directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : 2-tuple</span>
<span class="sd">            A tuple of form (filename, iteration) where the filename is a</span>
<span class="sd">            string pointing towards a previously saved pickle file containing</span>
<span class="sd">            the relevant information for the reduction if required.  If set to</span>
<span class="sd">            `None`, the arguments are retrieved from the</span>
<span class="sd">            `_global_resampling_values` global parameter.</span>
<span class="sd">        block : int</span>
<span class="sd">            The block index to process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : 9-tuple of numpy.ndarray</span>
<span class="sd">            The first element contains the fit point indices to be fit.  For</span>
<span class="sd">            the remaining elements, please see :func:`solve_fits` return</span>
<span class="sd">            values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span><span class="p">,</span> <span class="n">iteration</span> <span class="o">=</span> <span class="n">args</span>

        <span class="c1"># Loading cannot be covered in tests as it occurs on other CPUs.</span>
        <span class="n">load_args</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">if</span> <span class="s1">&#39;args&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_global_resampling_values</span><span class="p">:</span>
                <span class="n">load_args</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="s1">&#39;iteration&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_global_resampling_values</span><span class="p">:</span>
                <span class="n">load_args</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">iteration</span> <span class="o">!=</span> <span class="n">_global_resampling_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">):</span>
                <span class="n">load_args</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">filename</span> <span class="o">!=</span> <span class="n">_global_resampling_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">):</span>
                <span class="n">load_args</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">load_args</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">unpickle_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;iteration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iteration</span>
            <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="p">(</span><span class="n">sample_values</span><span class="p">,</span> <span class="n">sample_error</span><span class="p">,</span> <span class="n">sample_mask</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
         <span class="n">get_error</span><span class="p">,</span> <span class="n">get_counts</span><span class="p">,</span> <span class="n">get_weights</span><span class="p">,</span> <span class="n">get_distance_weights</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="p">,</span>
         <span class="n">get_offset_variance</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> <span class="o">=</span> <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>

        <span class="n">fit_indices</span><span class="p">,</span> <span class="n">fit_coordinates</span> <span class="o">=</span> \
            <span class="n">fit_tree</span><span class="o">.</span><span class="n">block_members</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">get_locations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">typed</span><span class="o">.</span><span class="n">List</span><span class="p">((</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">query_radius</span><span class="p">(</span>
            <span class="n">fit_coordinates</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

        <span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span> <span class="n">panel_steps</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span>
         <span class="n">nk1</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">n_knots</span><span class="p">)</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="o">.</span><span class="n">resampling_arguments</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fit_indices</span><span class="p">,</span>
                <span class="o">*</span><span class="n">solve_kernel_fits</span><span class="p">(</span>
                    <span class="n">sample_indices</span><span class="p">,</span> <span class="n">sample_tree</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">sample_values</span><span class="p">,</span> <span class="n">sample_error</span><span class="p">,</span> <span class="n">sample_mask</span><span class="p">,</span>
                    <span class="n">fit_coordinates</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span>
                    <span class="n">degrees</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span> <span class="n">panel_steps</span><span class="p">,</span>
                    <span class="n">knot_steps</span><span class="p">,</span> <span class="n">nk1</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">n_knots</span><span class="p">,</span>
                    <span class="n">is_covar</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;is_covar&#39;</span><span class="p">],</span>
                    <span class="n">cval</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cval&#39;</span><span class="p">],</span>
                    <span class="n">error_weighting</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;error_weighting&#39;</span><span class="p">],</span>
                    <span class="n">absolute_weight</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;absolute_weight&#39;</span><span class="p">],</span>
                    <span class="n">edge_algorithm_idx</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;edge_algorithm_idx&#39;</span><span class="p">],</span>
                    <span class="n">edge_threshold</span><span class="o">=</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;edge_threshold&#39;</span><span class="p">],</span>
                    <span class="n">get_error</span><span class="o">=</span><span class="n">get_error</span><span class="p">,</span>
                    <span class="n">get_counts</span><span class="o">=</span><span class="n">get_counts</span><span class="p">,</span>
                    <span class="n">get_weights</span><span class="o">=</span><span class="n">get_weights</span><span class="p">,</span>
                    <span class="n">get_distance_weights</span><span class="o">=</span><span class="n">get_distance_weights</span><span class="p">,</span>
                    <span class="n">get_rchi2</span><span class="o">=</span><span class="n">get_rchi2</span><span class="p">,</span>
                    <span class="n">get_offset_variance</span><span class="o">=</span><span class="n">get_offset_variance</span><span class="p">)</span>
                <span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.resample_kernel</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>