<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grig.toolkit.splines.spline_utils &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script src="../../../../_static/documentation_options.js?v=9559a862"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.toolkit.splines.spline_utils</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for grig.toolkit.splines.spline_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;find_knots&#39;</span><span class="p">,</span> <span class="s1">&#39;find_knot&#39;</span><span class="p">,</span> <span class="s1">&#39;calculate_minimum_bandwidth&#39;</span><span class="p">,</span>
           <span class="s1">&#39;flat_index_mapping&#39;</span><span class="p">,</span> <span class="s1">&#39;create_ordering&#39;</span><span class="p">,</span> <span class="s1">&#39;check_input_arrays&#39;</span><span class="p">,</span>
           <span class="s1">&#39;givens_parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;givens_rotate&#39;</span><span class="p">,</span> <span class="s1">&#39;build_observation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;back_substitute&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_rank_deficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_observation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;knot_fit&#39;</span><span class="p">,</span> <span class="s1">&#39;add_knot&#39;</span><span class="p">,</span> <span class="s1">&#39;evaluate_bspline&#39;</span><span class="p">,</span>
           <span class="s1">&#39;determine_smoothing_spline&#39;</span><span class="p">,</span> <span class="s1">&#39;discontinuity_jumps&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rational_interp_zero&#39;</span><span class="p">,</span> <span class="s1">&#39;fit_point&#39;</span><span class="p">,</span> <span class="s1">&#39;perform_fit&#39;</span><span class="p">,</span> <span class="s1">&#39;single_fit&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="find_knots">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.find_knots">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_knots</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">valid_knot_start</span><span class="p">,</span> <span class="n">valid_knot_end</span>
               <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the knot indices for an array of coordinates.</span>

<span class="sd">    The knot index (i) for a given coordinate (x) is defined such that</span>
<span class="sd">    knot[i] &lt;= x &lt; knot[i + 1].  Coordinates that are less than the minimum</span>
<span class="sd">    valid knot are set to the minimum valid knot index, and values that are</span>
<span class="sd">    greater than the maximum valid knot are set to the maximum valid knot</span>
<span class="sd">    index - 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The coordinates of shape (n_dimensions, m) where m are the number of</span>
<span class="sd">        coordinates.</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    valid_knot_start : numpy.ndarray (int)</span>
<span class="sd">        The start indices for the first valid knot in each dimension.  For a</span>
<span class="sd">        spline of degree k, this should be k.  The shape is (n_dimensions,).</span>
<span class="sd">    valid_knot_end : numpy.ndarray (int)</span>
<span class="sd">        The last valid knot index in each dimension of shape (n_dimensions,).</span>
<span class="sd">        for a spline of degree k, this should be n_knots - degree - 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knot_indices : numpy.ndarray (int)</span>
<span class="sd">        The knot index for each coordinate in each dimension of shape</span>
<span class="sd">        (n_dimensions, m).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dimensions</span><span class="p">,</span> <span class="n">n_data</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">knot_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">n_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot</span> <span class="o">=</span> <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_end</span> <span class="o">=</span> <span class="n">valid_knot_end</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_start</span> <span class="o">=</span> <span class="n">valid_knot_start</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="n">max_value</span> <span class="o">=</span> <span class="n">knot</span><span class="p">[</span><span class="n">knot_end</span><span class="p">]</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">knot</span><span class="p">[</span><span class="n">knot_start</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_data</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
                <span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_start</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
                <span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_end</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">knot_start</span><span class="p">,</span> <span class="n">knot_end</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">knot</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_end</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">knot_indices</span></div>



<div class="viewcode-block" id="find_knot">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.find_knot">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_knot</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">valid_knot_start</span><span class="p">,</span> <span class="n">valid_knot_end</span><span class="p">,</span>
              <span class="n">allow_outside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lower_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the knot index for a single coordinate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinate : numpy.ndarray (float)</span>
<span class="sd">        The coordinates of shape (n_dimensions, m).</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    valid_knot_start : numpy.ndarray (int)</span>
<span class="sd">        The start indices for the first valid knot in each dimension.  For a</span>
<span class="sd">        spline of degree k, this should be k.  The shape is (n_dimensions,).</span>
<span class="sd">    valid_knot_end : numpy.ndarray (int)</span>
<span class="sd">        The last valid knot index in each dimension of shape (n_dimensions,).</span>
<span class="sd">        for a spline of degree k, this should be n_knots - degree - 1.</span>
<span class="sd">    allow_outside : bool, optional</span>
<span class="sd">        If `True` (default), allow a fit outside the bounds of the knots.</span>
<span class="sd">    lower_bounds : numpy.ndarray (float)</span>
<span class="sd">        Specifies the lower range of valid coordinates for each dimension.</span>
<span class="sd">    upper_bounds : numpy.ndarray (float)</span>
<span class="sd">        Specifies the upper range of valid coordinates for each dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knot_indices : numpy.ndarray (int)</span>
<span class="sd">        The knot index for each coordinate in each dimension of shape</span>
<span class="sd">        (n_dimensions, m).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">size</span>
    <span class="n">knot_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">knot_line</span> <span class="o">=</span> <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_start</span> <span class="o">=</span> <span class="n">valid_knot_start</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_end</span> <span class="o">=</span> <span class="n">valid_knot_end</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_knot</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">knot_start</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_knot</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_knot</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">knot_end</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_knot</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">coordinate</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_knot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_outside</span><span class="p">:</span>
                <span class="n">knot_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">return</span> <span class="n">knot_index</span>
            <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_start</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">max_knot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_outside</span><span class="p">:</span>
                <span class="n">knot_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">return</span> <span class="n">knot_index</span>
            <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_end</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">knot_start</span><span class="p">,</span> <span class="n">knot_end</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_end</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">knot_index</span></div>



<div class="viewcode-block" id="calculate_minimum_bandwidth">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.calculate_minimum_bandwidth">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">calculate_minimum_bandwidth</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">n_knots</span><span class="p">,</span> <span class="n">permutations</span>
                                <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the minimum possible bandwidth given knots and spline degree.</span>

<span class="sd">    The bandwidth of a given observation matrix is given as:</span>

<span class="sd">    k0(d1*d2*d3*...*dn) + k1(d2*d3*...*dn) + k2(d3*...*dn) + ... + kn</span>

<span class="sd">    for the n-dimensional case where a number (1,2,3, etc) signifies the</span>
<span class="sd">    dimension number, k represents the degree, and dn is given as</span>
<span class="sd">    n_knots - k - 1.  This function loops through all available dimensional</span>
<span class="sd">    permutations in order to find the permutation that results in the smallest</span>
<span class="sd">    bandwidth.</span>

<span class="sd">    Finding the bandwidth is only relevant in more than one dimension.</span>
<span class="sd">    The bandwidth of the observation matrix may be minimized by switching the</span>
<span class="sd">    order of dimensions (coordinates, degrees, knot lines, etc.).  This can</span>
<span class="sd">    speed up evaluation of spline coefficients and knot locations.</span>

<span class="sd">    To save speed, permutations should be pre-calculated and supplied to this</span>
<span class="sd">    function, containing each possible ordering of the dimensions.  For</span>
<span class="sd">    example, for two dimensions, permutations would be [[0, 1], [1, 0]].</span>
<span class="sd">    For three dimensions permutations would be:</span>

<span class="sd">    [[0 1 2]</span>
<span class="sd">     [0 2 1]</span>
<span class="sd">     [1 0 2]</span>
<span class="sd">     [1 2 0]</span>
<span class="sd">     [2 0 1]</span>
<span class="sd">     [2 1 0]]</span>

<span class="sd">    Note that for 1-dimension the minimum bandwidth will be fixed.</span>

<span class="sd">    Dimensional permutations can be calculated via:</span>

<span class="sd">        permutations = np.array(list(itertools.permutations(range(n_dim))))</span>

<span class="sd">    where ndim is the number of dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    degrees : numpy.ndarray (int)</span>
<span class="sd">        The degrees of the spline in each dimension (n_dimensions,).</span>
<span class="sd">    n_knots : numpy.ndarray (int)</span>
<span class="sd">        The number of knots in each dimension (n_dimensions,).</span>
<span class="sd">    permutations : numpy.ndarray (int)</span>
<span class="sd">        All possible dimensional ordering of shape</span>
<span class="sd">        (n_permutations, n_dimensions).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    minimum_bandwidth, permutation_index, changed : int, int, bool</span>
<span class="sd">        The minimum bandwidth, the index of the permutation for the minimum</span>
<span class="sd">        bandwidth, and whether the permutation is different to the first</span>
<span class="sd">        available permutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_permutations</span><span class="p">,</span> <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">permutations</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">n_dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">permutations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span>

    <span class="n">difference</span> <span class="o">=</span> <span class="n">n_knots</span> <span class="o">-</span> <span class="n">degrees</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">min_bandwidth</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">min_permutation</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">min_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">):</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">step_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
            <span class="n">bandwidth</span> <span class="o">+=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">*</span> <span class="n">step_size</span>
            <span class="n">step_size</span> <span class="o">*=</span> <span class="n">difference</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">min_bandwidth</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">bandwidth</span> <span class="o">&lt;</span> <span class="n">min_bandwidth</span><span class="p">:</span>
            <span class="n">min_bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span>
            <span class="n">min_permutation</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span>
            <span class="n">min_i</span> <span class="o">=</span> <span class="n">pi</span>

    <span class="k">return</span> <span class="n">min_bandwidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_permutation</span><span class="p">,</span> <span class="n">min_i</span> <span class="o">!=</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="flat_index_mapping">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.flat_index_mapping">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flat_index_mapping</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return index slices for Numba flattened arrays.</span>

<span class="sd">    Given the shape of an array, return a variety of useful parameters for</span>
<span class="sd">    indexing a flattened (x.ravel()) version of that array.</span>

<span class="sd">    For example, consider an array (x) of shape (3, 4):</span>

<span class="sd">    x = [[ 0,  1,  2,  3],</span>
<span class="sd">         [ 4,  5,  6,  7],</span>
<span class="sd">         [ 8,  9, 10, 11]]</span>

<span class="sd">    which when flattened (x_flat) is equal to</span>

<span class="sd">    x_flat = [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]</span>

<span class="sd">    `map_indices` returns the indices of x_flat on x, and is a 2-D array of</span>
<span class="sd">    shape (n_dimensions, x.size).  map_indices[:, 6] gives the N-D index of</span>
<span class="sd">    element 6 of x_flat in terms of x.  i.e, map_indices[:, 6] = [1, 2].</span>

<span class="sd">    `transpose_indices` contains the flat indices of an array that has been</span>
<span class="sd">    transposed.  i.e. x.T.ravel()[transpose_indices] == x_flat</span>

<span class="sd">    `step_size` contains indicates the flat index jump along the given</span>
<span class="sd">    dimension.  i.e., the step size for the above example is [4, 1], indicating</span>
<span class="sd">    that for every increment along the first dimension, the flat index</span>
<span class="sd">    increments by 4.  Likewise, for every increment along the second dimension,</span>
<span class="sd">    the flat index increments by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : numpy.ndarray (int)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map_indices, transpose_indices, step_size</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">size</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">transpose_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="n">div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">mod_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">c_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="n">div_factor</span> <span class="o">=</span> <span class="n">size</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">n_dimensions</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">step_size</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
        <span class="n">mod_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_factor</span>
        <span class="n">c_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">c</span> <span class="o">*=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">*=</span> <span class="n">shape</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
        <span class="n">div_factor</span> <span class="o">/=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">div</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_factor</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">flat_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">//</span> <span class="n">div</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">transpose_indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">j</span> <span class="o">%</span> <span class="n">mod_t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">//</span> <span class="n">step_size</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># For shape (2, 3, 4):</span>
    <span class="c1"># 6 every 1 in chunks of 4   6 * ((j % 4) // 1)</span>
    <span class="c1"># 2 every 4 in chunks of     2 * ((j % 12) // 4)</span>
    <span class="c1"># 1 every 12 in              1 * ((j % 24) // 12)</span>

    <span class="k">return</span> <span class="n">flat_indices</span><span class="p">,</span> <span class="n">transpose_indices</span><span class="p">,</span> <span class="n">step_size</span></div>



<div class="viewcode-block" id="create_ordering">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.create_ordering">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">create_ordering</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of indices, create an ordering structure for fast access.</span>

<span class="sd">    The purpose of this function is to create two arrays than can be used</span>
<span class="sd">    to quickly retrieve all reverse indices for a given index using numba.</span>
<span class="sd">    For example, consider the array x:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 0, 2, 1, 4, 2, 1, 2, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; si, ni = create_ordering(x)</span>

<span class="sd">    We can now extract the indices on x for a given value.  E.g.,</span>

<span class="sd">    &gt;&gt;&gt; ri = []</span>
<span class="sd">    &gt;&gt;&gt; for value in [0, 1, 2, 3, 4]:</span>
<span class="sd">    ...     inds = []</span>
<span class="sd">    ...     ri.append(inds)</span>
<span class="sd">    ...     reverse_index = si[value]</span>
<span class="sd">    ...     while reverse_index != -1:</span>
<span class="sd">    ...         inds.append(reverse_index)</span>
<span class="sd">    ...         reverse_index = ni[reverse_index]</span>
<span class="sd">    &gt;&gt;&gt; print(ri)</span>
<span class="sd">    [[1, 0], [9, 6, 3], [8, 7, 5, 2], [], [4]]</span>

<span class="sd">    i.e., the indices on x where x is equal to 0 are [1, 0], and [8, 7, 5, 2]</span>
<span class="sd">    where x is equal to 2.</span>

<span class="sd">    This is a very useful feature for N-D numba functions as reverse indices</span>
<span class="sd">    can be precalculated and represented as 1-dimensional arrays and we avoid</span>
<span class="sd">    functions such as np.nonzero, argwhere etc, that introduce additional</span>
<span class="sd">    overhead associated with array creation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : numpy.ndarray (int)</span>
<span class="sd">        A list of input indices.</span>
<span class="sd">    size : int</span>
<span class="sd">        The size of the array to return.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    start_indices, next_indices : numpy.ndarray (int), numpy.ndarray (int)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="n">n_data</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span>
    <span class="n">start_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">next_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_data</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">next_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">start_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">start_indices</span><span class="p">,</span> <span class="n">next_indices</span></div>



<div class="viewcode-block" id="check_input_arrays">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.check_input_arrays">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">check_input_arrays</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check all input arrays.</span>

<span class="sd">    For a data point to be valid, it must have a finite value, weight</span>
<span class="sd">    and coordinate.  The weight must greater than zero, and coordinates</span>
<span class="sd">    must be finite in each dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : numpy.ndarray (float)</span>
<span class="sd">        An array of values of shape (n_data,).</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The coordinate values of shape (n_dimensions, n_data).</span>
<span class="sd">    weights : numpy.ndarray (float)</span>
<span class="sd">        The point weights of shape (n_data,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : numpy.ndarray (bool)</span>
<span class="sd">        A boolean mask of shape (n_data,) where `False` marks an invalid</span>
<span class="sd">        data coordinate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">n_data</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_data</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">x_value</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x_value</span><span class="p">):</span>
                <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">valid</span></div>



<div class="viewcode-block" id="givens_parameters">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.givens_parameters">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">givens_parameters</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the parameters of a Givens transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        The x value.</span>
<span class="sd">    y : float</span>
<span class="sd">        The y value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    updated_y, cos, sin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cos</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">sin</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">updated_y</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">updated_y</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span></div>



<div class="viewcode-block" id="givens_rotate">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.givens_rotate">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">givens_rotate</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the Givens transformation to a value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cos : float</span>
<span class="sd">    sin : float</span>
<span class="sd">    x : float</span>
<span class="sd">    y : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_rotated, y_rotated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">sin</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>



<div class="viewcode-block" id="build_observation">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.build_observation">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">build_observation</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span>
                      <span class="n">degrees</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">start_indices</span><span class="p">,</span>
                      <span class="n">next_indices</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span> <span class="n">spline_mapping</span>
                      <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the spline observation matrices.</span>

<span class="sd">    The observation matrices are used to solve the linear system of equations</span>
<span class="sd">    Ax = B in row-echelon form.  A and B (amat and beta) may be used to solve</span>
<span class="sd">    for x using either :func:`back_substitute` if A is full rank, or</span>
<span class="sd">    :func:`solve_rank_deficiency` if A is rank deficient.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The m coordinates to fit (n_dimensions, m).</span>
<span class="sd">    values : numpy.ndarray (float)</span>
<span class="sd">        The values at each coordinate (m,).</span>
<span class="sd">    weights : numpy.ndarray (float)</span>
<span class="sd">        The associated weight value for each coordinate (m,).</span>
<span class="sd">    n_coefficients : int</span>
<span class="sd">        The number of coefficients to fit.</span>
<span class="sd">    bandwidth : int</span>
<span class="sd">        The bandwidth of the observation.</span>
<span class="sd">    degrees : numpy.ndarray (int)</span>
<span class="sd">        The degrees of the splines to fit (n_dimensions,).</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in knot-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    start_indices : numpy.ndarray (int)</span>
<span class="sd">        The starting indices of shape (m,) as returned by</span>
<span class="sd">        :func:`create_ordering`.</span>
<span class="sd">    next_indices : numpy.ndarray (int)</span>
<span class="sd">        The next indices of shape (m,) as returned by :func:`create_ordering`.</span>
<span class="sd">    panel_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the panel mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the panel shape (n_knots - (2 * degrees) - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the spline mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the spline shape (degrees + 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_spline_coefficients).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amat, beta, knot_splines, ssr : array, array, array, float</span>
<span class="sd">        The observation matrix amat of shape (n_coefficients, bandwidth), the</span>
<span class="sd">        observation matrix beta of shape (n_coefficients,), the base spline</span>
<span class="sd">        coefficients for each knot (n_dimensions, n_knots, max(degree) + 1),</span>
<span class="sd">        and ssr (sum of the residuals squared)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">max_k1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
    <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">splines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">max_k1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">work_spline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">splines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">n_spline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span>

    <span class="n">sum_square_residual</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">panel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_indices</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">panel_index</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="p">[:,</span> <span class="n">panel</span><span class="p">]</span>
        <span class="n">knot_index</span> <span class="o">=</span> <span class="n">panel_index</span> <span class="o">+</span> <span class="n">degrees</span>
        <span class="n">j_rot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">j_rot</span> <span class="o">+=</span> <span class="n">panel_mapping</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">panel</span><span class="p">]</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span>

            <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
                <span class="n">evaluate_bspline</span><span class="p">(</span>
                    <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                    <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point</span><span class="p">],</span> <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                    <span class="n">work_spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]):</span>  <span class="c1"># copy it over for later use</span>
                    <span class="n">splines</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">work_spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

            <span class="c1"># Initialize a new row of the observation matrix</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Calculate the spline dimensional cross-products and store it in</span>
            <span class="c1"># the row.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spline</span><span class="p">):</span>
                <span class="n">row_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">weight</span>
                <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
                    <span class="n">spline_index</span> <span class="o">=</span> <span class="n">spline_mapping</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">s</span> <span class="o">*=</span> <span class="n">work_spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">spline_index</span><span class="p">]</span>
                    <span class="n">row_index</span> <span class="o">+=</span> <span class="n">spline_index</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="n">row</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

            <span class="c1"># Rotate the row into a triangle by givens transformations</span>
            <span class="n">i_rot</span> <span class="o">=</span> <span class="n">j_rot</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">i_rot</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pivot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Calculate parameters</span>
                <span class="n">amat</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span> <span class="o">=</span> <span class="n">givens_parameters</span><span class="p">(</span>
                    <span class="n">pivot</span><span class="p">,</span> <span class="n">amat</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="c1"># Apply transformation to the RHS</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">i_rot</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                    <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">i_rot</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">b1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i3</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Apply transformation to the LHS</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i3</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">):</span>
                    <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">amat</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                        <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">amat</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="n">i2</span><span class="p">])</span>

            <span class="n">sum_square_residual</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">next_indices</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">sum_square_residual</span></div>



<div class="viewcode-block" id="back_substitute">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.back_substitute">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">back_substitute</span><span class="p">(</span><span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use back-substitution to solve a reduced row-echelon form matrix.</span>

<span class="sd">    The amat matrix MUST be full rank.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    amat : numpy.ndarray (float)</span>
<span class="sd">        The &#39;A&#39; in the system Ax = B of shape (&gt;=n_coefficients, &gt;=bandwidth).</span>
<span class="sd">    beta : numpy.ndarray (float)</span>
<span class="sd">        The &#39;B&#39; in the system Ax = B of shape (&gt;=n_coefficients,).</span>
<span class="sd">    n_coefficients : int</span>
<span class="sd">        The number of coefficients to solve for.</span>
<span class="sd">    bandwidth : int</span>
<span class="sd">        The bandwidth of matrix A (amat).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients : numpy.ndarray (float)</span>
<span class="sd">        The coefficients of shape (n_coefficients.).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n_coefficients</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">coefficients</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">/</span> <span class="n">amat</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coefficients</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">b1</span><span class="p">:</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">value</span> <span class="o">-=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">coefficients</span></div>



<div class="viewcode-block" id="solve_rank_deficiency">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.solve_rank_deficiency">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">solve_rank_deficiency</span><span class="p">(</span><span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">tolerance</span>
                          <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve a rank-deficient row-echelon reduced form matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    amat : numpy.ndarray (float)</span>
<span class="sd">        The &#39;A&#39; in the system Ax = B of shape (&gt;=n_coefficients, &gt;=bandwidth).</span>
<span class="sd">    beta : numpy.ndarray (float)</span>
<span class="sd">        The &#39;B&#39; in the system Ax = B of shape (&gt;=n_coefficients,).</span>
<span class="sd">    n_coefficients : int</span>
<span class="sd">        The number of coefficients to solve for.</span>
<span class="sd">    bandwidth : int</span>
<span class="sd">        The bandwidth of matrix A (amat).</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The value over which the zeroth element of `amat` will be considered</span>
<span class="sd">        rank deficient.  Deficient rows will be rotated into a new reduced</span>
<span class="sd">        rank matrix and solved accordingly.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients, ssr, rank : numpy.ndarray (float), float, int</span>
<span class="sd">        The coefficients of shape (n_coefficients.), the sum of the squared</span>
<span class="sd">        residuals (ssr), and the rank.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">nc1</span> <span class="o">=</span> <span class="n">n_coefficients</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">deficiency</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_squared_residuals</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># 90</span>
        <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">deficiency</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nc1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">yi</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b1</span><span class="p">):</span>
            <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="n">b1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">):</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nc1</span> <span class="o">-</span> <span class="n">ii</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">piv</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">piv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># givens_rotate</span>
                <span class="n">amat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span> <span class="o">=</span> <span class="n">givens_parameters</span><span class="p">(</span>
                    <span class="n">piv</span><span class="p">,</span> <span class="n">amat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">yi</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i2</span><span class="p">):</span>
                    <span class="n">j1</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j1</span><span class="p">],</span> <span class="n">amat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                        <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">j1</span><span class="p">],</span> <span class="n">amat</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">j1</span><span class="p">])</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">j1</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i2</span><span class="p">):</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">row</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">sum_squared_residuals</span> <span class="o">+=</span> <span class="n">yi</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># 90</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">n_coefficients</span> <span class="o">-</span> <span class="n">deficiency</span>
    <span class="n">amat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rank</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">beta2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">ii</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># 120</span>
        <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">beta2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">amat2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">j1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">jj</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 110</span>
            <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">kk</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">jj</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">amat2</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># 200</span>
        <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ii</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 130</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">row</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">jj</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">):</span>  <span class="c1"># 140</span>
            <span class="n">row</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">jj</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">):</span>  <span class="c1"># 190</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">piv</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j3</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># irrelevant - just for numba compilation</span>
            <span class="k">if</span> <span class="n">piv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="p">):</span>  <span class="c1"># 150</span>
                    <span class="n">j3</span> <span class="o">=</span> <span class="n">j2</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span>
                <span class="n">jj</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># givens_rotate</span>
                <span class="n">amat2</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span> <span class="o">=</span> <span class="n">givens_parameters</span><span class="p">(</span><span class="n">piv</span><span class="p">,</span> <span class="n">amat2</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">j1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">kk</span> <span class="o">=</span> <span class="n">jj</span>
                <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="p">):</span>  <span class="c1"># 170</span>
                    <span class="n">j3</span> <span class="o">=</span> <span class="n">j2</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">kk</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">],</span> <span class="n">amat2</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">j3</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                        <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">],</span> <span class="n">amat2</span><span class="p">[</span><span class="n">kk</span><span class="p">,</span> <span class="n">j3</span><span class="p">])</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span>
                <span class="n">jj</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">beta2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">amat2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>  <span class="c1"># 220</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 210</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">stor1</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">stor2</span> <span class="o">=</span> <span class="n">amat2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>
                <span class="n">store</span> <span class="o">-=</span> <span class="n">stor1</span> <span class="o">*</span> <span class="n">stor2</span>

            <span class="n">stor1</span> <span class="o">=</span> <span class="n">amat2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">beta2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">store</span> <span class="o">/</span> <span class="n">stor1</span>

    <span class="n">beta2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">amat2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>  <span class="c1"># 250</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 240</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">stor1</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">stor2</span> <span class="o">=</span> <span class="n">amat2</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span>
                <span class="n">store</span> <span class="o">-=</span> <span class="n">stor1</span> <span class="o">*</span> <span class="n">stor2</span>
            <span class="n">stor1</span> <span class="o">=</span> <span class="n">amat2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">beta2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">store</span> <span class="o">/</span> <span class="n">stor1</span>

    <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># 280</span>
        <span class="n">store</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ij</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="p">):</span>  <span class="c1"># 270</span>
            <span class="n">ij</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">ij</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">stor1</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">ij</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">stor2</span> <span class="o">=</span> <span class="n">beta2</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
            <span class="n">store</span> <span class="o">+=</span> <span class="n">stor1</span> <span class="o">*</span> <span class="n">stor2</span>
            <span class="n">kk</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">store</span>

    <span class="n">stor3</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># 310</span>
        <span class="k">if</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">store</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nc1</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span><span class="p">):</span>  <span class="c1"># 290</span>
                <span class="n">ij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
                <span class="n">stor1</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span>
                <span class="n">stor2</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">store</span> <span class="o">-=</span> <span class="n">stor1</span> <span class="o">*</span> <span class="n">stor2</span>

        <span class="n">stor1</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">stor2</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stor1</span> <span class="o">*=</span> <span class="n">stor2</span>
        <span class="n">stor3</span> <span class="o">+=</span> <span class="n">stor1</span> <span class="o">*</span> <span class="p">(</span><span class="n">stor1</span> <span class="o">-</span> <span class="n">store</span> <span class="o">-</span> <span class="n">store</span><span class="p">)</span>

    <span class="n">fac</span> <span class="o">=</span> <span class="n">stor3</span>
    <span class="n">sum_squared_residuals</span> <span class="o">+=</span> <span class="n">fac</span>
    <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">sum_squared_residuals</span><span class="p">,</span> <span class="n">rank</span></div>



<div class="viewcode-block" id="solve_observation">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.solve_observation">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">solve_observation</span><span class="p">(</span><span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">eps</span>
                      <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve a row-echelon reduced linear system of equations Ax=B.</span>

<span class="sd">    Returns the results of :func:`back_substitute` if A is full rank, or the</span>
<span class="sd">    results of :func:`solve_rank_deficiency` otherwise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    amat : numpy.ndarray (float)</span>
<span class="sd">        The array A in row-echelon form.  Should be of shape</span>
<span class="sd">        (&gt;=n_coefficients, &gt;=bandwidth).</span>
<span class="sd">    beta : numpy.ndarray (float)</span>
<span class="sd">        The array B accounting for row-echelon form.  Should be of shape</span>
<span class="sd">        (&gt;=n_coefficients,).</span>
<span class="sd">    n_coefficients : int</span>
<span class="sd">        The number of coefficients to solve for.</span>
<span class="sd">    bandwidth : int</span>
<span class="sd">        The bandwidth of the observation matrix A (`amat`).</span>
<span class="sd">    eps : float</span>
<span class="sd">        The precision to determine singular values of A.  If any row of</span>
<span class="sd">        amat[:,0] &lt; (eps * max(amat[:,0])) it will be considered singular.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients, rank, ssr : numpy.ndarray (float), int, float</span>
<span class="sd">        The derived coefficients, the rank of A, and the sum of the squared</span>
<span class="sd">        residuals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diagonals</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[:</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">max_diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diagonals</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">max_diagonal</span>
    <span class="n">full_rank</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">diagonal</span> <span class="ow">in</span> <span class="n">diagonals</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">diagonal</span> <span class="o">&lt;</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="n">full_rank</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">full_rank</span><span class="p">:</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">back_substitute</span><span class="p">(</span><span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">n_coefficients</span>
        <span class="n">sum_squared_residuals</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">amat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">beta2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>  <span class="c1"># copy over amat, beta</span>
            <span class="n">beta2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">amat2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">coefficients</span><span class="p">,</span> <span class="n">sum_squared_residuals</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">solve_rank_deficiency</span><span class="p">(</span>
            <span class="n">amat2</span><span class="p">,</span> <span class="n">beta2</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sum_squared_residuals</span></div>



<div class="viewcode-block" id="knot_fit">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.knot_fit">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">knot_fit</span><span class="p">(</span><span class="n">splines</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">start_indices</span><span class="p">,</span> <span class="n">next_indices</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span>
             <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">panel_shape</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
             <span class="n">coordinates</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the spline fit at each knot location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    splines : numpy.ndarray (float)</span>
<span class="sd">        The splines of shape (n_dimensions, n_data, max(k1)).</span>
<span class="sd">    coefficients : numpy.ndarray (float)</span>
<span class="sd">        The spline coefficients of shape (n_coefficients,).</span>
<span class="sd">    start_indices : numpy.ndarray (int)</span>
<span class="sd">        The start indices of the reverse lookup array of shape (n_data,).  See</span>
<span class="sd">        :func:`create_ordering` for further details.</span>
<span class="sd">    next_indices : numpy.ndarray (int)</span>
<span class="sd">        The &quot;next&quot; indices of the reverse lookup array of shape (n_data,_.  See</span>
<span class="sd">        :func:`create_ordering` for further details.</span>
<span class="sd">    panel_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the panel mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the panel shape (n_knots - (2 * degrees) - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the spline mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the spline shape (degrees + 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_spline_coefficients).</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in knot-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    panel_shape : numpy.ndarray (int)</span>
<span class="sd">        The panel shape will be defined as n_knots - (2 * k1) + 1 where k1 and</span>
<span class="sd">        n_knots are both of shape (n_dimensions,).</span>
<span class="sd">    k1 : numpy.ndarray (int)</span>
<span class="sd">        An array of shape (n_dimensions,) where k1[dimension] =</span>
<span class="sd">        degree[dimension] + 1.</span>
<span class="sd">    weights : numpy.ndarray (float)</span>
<span class="sd">        The value weights of shape (n_data,).</span>
<span class="sd">    values : numpy.ndarray (float)</span>
<span class="sd">        The values to fit of shape (n_data,).</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The coordinates of each value in each dimension of shape</span>
<span class="sd">        (n_dimensions, n_data).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fit, knot_weights, knot_coordinates : 3-tuple of numpy.ndarray (float)</span>
<span class="sd">        The fitted value at each knot of shape (n_data,), the knot weights of</span>
<span class="sd">        shape (max_panels,), and the knot coordinates of shape (max_panels,)</span>
<span class="sd">        where max_panels is the maximum number of panels available in the</span>
<span class="sd">        spline fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">n_panels</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_spline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">start_indices</span><span class="o">.</span><span class="n">size</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">max_panels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">panel_shape</span><span class="p">)</span>

    <span class="n">knot_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">max_panels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">knot_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">max_panels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">panel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_panels</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">p_map</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="p">[:,</span> <span class="n">panel</span><span class="p">]</span>
        <span class="n">j_rot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">j_rot</span> <span class="o">+=</span> <span class="n">p_map</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">point</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>

            <span class="n">fit_value</span> <span class="o">=</span> <span class="n">fit_point</span><span class="p">(</span>
                <span class="n">coefficients</span><span class="p">,</span> <span class="n">splines</span><span class="p">[:,</span> <span class="n">point</span><span class="p">],</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span>
                <span class="n">j_rot</span><span class="p">,</span> <span class="n">n_spline</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">)</span>
            <span class="n">fit</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_value</span>

            <span class="n">sq</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">-</span> <span class="n">fit_value</span><span class="p">)</span>
            <span class="n">sq</span> <span class="o">*=</span> <span class="n">sq</span>

            <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
                <span class="n">d_index</span> <span class="o">=</span> <span class="n">p_map</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="n">knot_weights</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">d_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sq</span>
                <span class="n">knot_coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">d_index</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">sq</span> <span class="o">*</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point</span><span class="p">])</span>

            <span class="n">point</span> <span class="o">=</span> <span class="n">next_indices</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fit</span><span class="p">,</span> <span class="n">knot_weights</span><span class="p">,</span> <span class="n">knot_coordinates</span></div>



<div class="viewcode-block" id="add_knot">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.add_knot">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_knot</span><span class="p">(</span><span class="n">knot_weights</span><span class="p">,</span> <span class="n">knot_coords</span><span class="p">,</span> <span class="n">panel_shape</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">n_knots</span><span class="p">,</span>
             <span class="n">knot_estimate</span><span class="p">,</span> <span class="n">k1</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a knot to the spline fit.</span>

<span class="sd">    Adds a knot near the currently highest weighted knot.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knot_weights : numpy.ndarray (float)</span>
<span class="sd">        The knot weights of shape (n_dimensions, n_knots).</span>
<span class="sd">    knot_coords : numpy.ndarray (float)</span>
<span class="sd">        The knot coordinates of shape (n_dimensions, n_knots).</span>
<span class="sd">    panel_shape : numpy.ndarray (int)</span>
<span class="sd">        The number of panels in the spline fit of shape (n_dimensions,).</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    n_knots : numpy.ndarray (int)</span>
<span class="sd">        The number of knots in each dimension of shape (n_dimensions,).</span>
<span class="sd">    knot_estimate : numpy.ndarray (int)</span>
<span class="sd">        The maximum number of knots allowable of shape (n_dimensions,).</span>
<span class="sd">    k1 : numpy.ndarray (int)</span>
<span class="sd">        An array of shape (n_dimensions,) where k1[dimension] =</span>
<span class="sd">        degree[dimension] + 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    exit_code : int</span>
<span class="sd">        Returns an exit code of 1 if the maximum number of allowable knots has</span>
<span class="sd">        already been reached and no more should be added.  Returns an exit code</span>
<span class="sd">        of 5 if the new knot location coincides with an already existing knot.</span>
<span class="sd">        Returns 0 if a knot was successfully added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">size</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">knot_estimate</span><span class="p">[</span><span class="n">dimension</span><span class="p">]:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exit_code</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">exit_code</span>

        <span class="n">max_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">max_dimension</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">knot_estimate</span><span class="p">[</span><span class="n">dimension</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">panel_shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">knot_weights</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">max_weight</span><span class="p">:</span>
                    <span class="n">max_dimension</span> <span class="o">=</span> <span class="n">dimension</span>
                    <span class="n">max_index</span> <span class="o">=</span> <span class="n">index</span>
                    <span class="n">max_weight</span> <span class="o">=</span> <span class="n">w</span>

        <span class="k">if</span> <span class="n">max_dimension</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">exit_code</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">return</span> <span class="n">exit_code</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">knot_coords</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">,</span> <span class="n">max_index</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="n">knot_weights</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">,</span> <span class="n">max_index</span><span class="p">]</span>
        <span class="n">knot_weights</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">,</span> <span class="n">max_index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># don&#39;t use again</span>

        <span class="n">knot_line</span> <span class="o">=</span> <span class="n">knots</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">]</span>
        <span class="n">knot_index</span> <span class="o">=</span> <span class="n">max_index</span> <span class="o">+</span> <span class="n">k1</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">]</span>
        <span class="n">fac1</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">knot_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span>
        <span class="n">fac2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">knot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fac1</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">fac2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">fac2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">fac1</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_knots</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">knot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">knot_line</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">knot_line</span><span class="p">[</span><span class="n">knot_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">n_knots</span><span class="p">[</span><span class="n">max_dimension</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">exit_code</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">exit_code</span></div>



<div class="viewcode-block" id="evaluate_bspline">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.evaluate_bspline">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">evaluate_bspline</span><span class="p">(</span><span class="n">knot_line</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">knot_index</span><span class="p">,</span> <span class="n">spline</span><span class="o">=</span><span class="kc">None</span>
                     <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate b-splines for given knots at a coordinate.</span>

<span class="sd">    Evaluates the (degree + 1) non-zero b-splines at t[i] &lt;= x &lt; t[i + 1]</span>
<span class="sd">    where t is the line of knots `knot_line` and i is the `knot_index`.</span>
<span class="sd">    This uses the stable recurrence relation of DeBoor and Cox (2007).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knot_line : numpy.ndarray (float)</span>
<span class="sd">        The line of monotonically increasing knots of shape (&gt;=n_knots).</span>
<span class="sd">    degree : int</span>
<span class="sd">        The degree of spline to evaluate.</span>
<span class="sd">    x : float</span>
<span class="sd">        The coordinate at which the spline should be evaluated.</span>
<span class="sd">    knot_index : int</span>
<span class="sd">        The index (i) of the knot satisfying t[i] &lt;= x &lt; t[i + 1] where</span>
<span class="sd">        t is the `knot_line`.</span>
<span class="sd">    spline : numpy.ndarray (float), optional</span>
<span class="sd">        An optionally created array to hold the results of this function of</span>
<span class="sd">        shape (&gt;=degree + 1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spline : numpy.ndarray (float)</span>
<span class="sd">        The output spline of shape (degree + 1) if `spline` is not supplied as</span>
<span class="sd">        an input parameter, or (spline.size,) otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">spline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">spline</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">):</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="p">):</span>
            <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">spline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span><span class="p">):</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ku</span> <span class="o">=</span> <span class="n">knot_index</span> <span class="o">+</span> <span class="n">i1</span>
            <span class="n">kl</span> <span class="o">=</span> <span class="n">ku</span> <span class="o">-</span> <span class="n">j1</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">kl</span><span class="p">]</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">ku</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">low</span> <span class="o">==</span> <span class="n">high</span><span class="p">:</span>
                <span class="n">spline</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span>
                <span class="n">spline</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">spline</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spline</span></div>



<div class="viewcode-block" id="determine_smoothing_spline">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.determine_smoothing_spline">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">determine_smoothing_spline</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="n">n_knots</span><span class="p">,</span> <span class="n">knot_estimate</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span>
                               <span class="n">initial_sum_square_residual</span><span class="p">,</span> <span class="n">smoothing</span><span class="p">,</span>
                               <span class="n">smoothing_difference</span><span class="p">,</span>
                               <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span>
                               <span class="n">amat</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">max_iteration</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span>
                               <span class="n">knot_mapping</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">splines</span><span class="p">,</span> <span class="n">start_indices</span><span class="p">,</span>
                               <span class="n">next_indices</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span>
                               <span class="n">coordinates</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">panel_shape</span><span class="p">,</span>
                               <span class="n">accuracy</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth the current solution to a specified level.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    n_knots : numpy.ndarray (int)</span>
<span class="sd">        The number of knots in each dimension of shape (n_dimensions,).</span>
<span class="sd">    knot_estimate : numpy.ndarray (int)</span>
<span class="sd">        The maximum number of knots allowable of shape (n_dimensions,).</span>
<span class="sd">    degrees : numpy.ndarray (int)</span>
<span class="sd">        The degrees of the spline in each dimension (n_dimensions,).</span>
<span class="sd">    initial_sum_square_residual : float</span>
<span class="sd">        The initial sum square of the residuals from the first knot fit.</span>
<span class="sd">    smoothing : float</span>
<span class="sd">        Used to specify the smoothing factor.</span>
<span class="sd">    smoothing_difference : float</span>
<span class="sd">        The sum of the square residuals minus the smoothing factor.</span>
<span class="sd">    n_coefficients : int</span>
<span class="sd">        The number of coefficients to fit.</span>
<span class="sd">    bandwidth : int</span>
<span class="sd">        The bandwidth of the observation.</span>
<span class="sd">    amat : numpy.ndarray (float)</span>
<span class="sd">        The &#39;A&#39; in the system Ax = B of shape (&gt;=n_coefficients, &gt;=bandwidth).</span>
<span class="sd">    beta : numpy.ndarray (float)</span>
<span class="sd">        The &#39;B&#39; in the system Ax = B of shape (&gt;=n_coefficients,).</span>
<span class="sd">    max_iteration : int</span>
<span class="sd">        The maximum number of iterations used to determine the</span>
<span class="sd">        smoothing spline.</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in knot-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    knot_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the knot mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    eps : float</span>
<span class="sd">        The precision to determine singular values of A.  If any row of</span>
<span class="sd">        amat[:,0] &lt; (eps * max(amat[:,0])) it will be considered singular.</span>
<span class="sd">    splines : numpy.ndarray (float)</span>
<span class="sd">        The splines of shape (n_dimensions, n_data, max(k1)).</span>
<span class="sd">    start_indices : numpy.ndarray (int)</span>
<span class="sd">        The starting indices of shape (m,) as returned by</span>
<span class="sd">        :func:`create_ordering`.</span>
<span class="sd">    next_indices : numpy.ndarray (int)</span>
<span class="sd">        The next indices of shape (m,) as returned by :func:`create_ordering`.</span>
<span class="sd">    panel_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the panel mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the panel shape (n_knots - (2 * degrees) - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        The 1-D to N-D spline mapping array as returned by</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be of shape</span>
<span class="sd">        (n_dimensions, n_spline).</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The coordinates at which to evaluate the spline of shape</span>
<span class="sd">        (n_dimensions, n).</span>
<span class="sd">    values : numpy.ndarray (float)</span>
<span class="sd">        An array of values of shape (n_data,).</span>
<span class="sd">    weights : numpy.ndarray (float)</span>
<span class="sd">        The value weights of shape (n_data,).</span>
<span class="sd">    panel_shape : numpy.ndarray (int)</span>
<span class="sd">        The number of panels in the spline fit of shape (n_dimensions,).</span>
<span class="sd">    accuracy : float</span>
<span class="sd">        The accuracy that is used to determine when a suitable smoothing fit</span>
<span class="sd">        has been achieved.  Iterations will stop when</span>
<span class="sd">        abs(smoothing - sum_square_residuals) &lt; accuracy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients, fp, ier, fitted_values : ndarray, float, float, ndarray</span>
<span class="sd">        The new spline coefficients, sum of the residuals^2, exit code, and</span>
<span class="sd">        the fitted values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">degrees</span><span class="o">.</span><span class="n">size</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">b_splines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">knot_estimate</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">k2</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">nk1</span> <span class="o">=</span> <span class="n">n_knots</span> <span class="o">-</span> <span class="n">k1</span>

    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nk1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">==</span> <span class="n">k1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">discontinuity_jumps</span><span class="p">(</span><span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">n_knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                            <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">b_splines</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">fp0</span> <span class="o">=</span> <span class="n">initial_sum_square_residual</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">smoothing</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">fp0</span> <span class="o">-</span> <span class="n">s</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">f3</span> <span class="o">=</span> <span class="n">smoothing_difference</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">rn</span> <span class="o">=</span> <span class="n">n_coefficients</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">rn</span> <span class="o">/</span> <span class="n">p</span>

    <span class="c1"># Find the bandwidth of the extended observation matrix</span>
    <span class="n">iband3</span> <span class="o">=</span> <span class="n">k1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_dimensions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">iband3</span> <span class="o">*=</span> <span class="n">nk1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
    <span class="n">iband4</span> <span class="o">=</span> <span class="n">iband3</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">ich1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ich3</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iband4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iband4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">iband4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">start_indices</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iteration</span><span class="p">):</span>
        <span class="n">pinv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>
            <span class="n">ff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">iband4</span> <span class="o">&gt;</span> <span class="n">bandwidth</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">iband4</span><span class="p">):</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nk1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">==</span> <span class="n">k1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">knot_step</span> <span class="o">=</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
            <span class="c1"># Extend the observation matrix with the rows of a matrix,</span>
            <span class="c1"># expressing that for x=cst. sp(x, y) must be a polynomial in y of</span>
            <span class="c1"># degree ky.</span>

            <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iband4</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k2</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">nk1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k2</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k2</span><span class="p">[</span><span class="n">dimension</span><span class="p">]):</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">ll</span> <span class="o">*</span> <span class="n">knot_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_splines</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">*</span> <span class="n">pinv</span>

                <span class="n">j_rots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">knot_mapping</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">==</span> <span class="n">ii</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j_rot</span> <span class="ow">in</span> <span class="n">j_rots</span><span class="p">:</span>

                    <span class="n">zi</span> <span class="o">=</span> <span class="mf">0.0</span>

                    <span class="c1"># Copy the row</span>
                    <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iband4</span><span class="p">):</span>
                        <span class="n">h</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">i_rot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j_rot</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">):</span>
                        <span class="n">pivot</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">i2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">iband3</span><span class="p">,</span> <span class="n">n_coefficients</span> <span class="o">-</span> <span class="n">i_rot</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">q</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span> <span class="o">=</span> <span class="n">givens_parameters</span><span class="p">(</span>
                                <span class="n">pivot</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                            <span class="n">zi</span><span class="p">,</span> <span class="n">ff</span><span class="p">[</span><span class="n">i_rot</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                                <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">ff</span><span class="p">[</span><span class="n">i_rot</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">i2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">break</span>

                            <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i2</span><span class="p">):</span>
                                <span class="n">l1</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">h</span><span class="p">[</span><span class="n">l1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="n">l1</span><span class="p">]</span> <span class="o">=</span> <span class="n">givens_rotate</span><span class="p">(</span>
                                    <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">l1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i_rot</span><span class="p">,</span> <span class="n">l1</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">i2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i2</span><span class="p">):</span>
                            <span class="n">h</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">ll</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">h</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">break</span>

        <span class="n">dmax</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dmax</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dmax</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">dmax</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sigma</span><span class="p">:</span>
                <span class="n">coefficients</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">solve_rank_deficiency</span><span class="p">(</span>
                    <span class="n">q</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">iband4</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">back_substitute</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="n">n_coefficients</span><span class="p">,</span> <span class="n">iband4</span><span class="p">)</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">n_coefficients</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_coefficients</span><span class="p">):</span>
            <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dmax</span>

        <span class="n">fitted_values</span><span class="p">,</span> <span class="n">knot_weights</span><span class="p">,</span> <span class="n">knot_coordinates</span> <span class="o">=</span> <span class="n">knot_fit</span><span class="p">(</span>
            <span class="n">splines</span><span class="o">=</span><span class="n">splines</span><span class="p">,</span>
            <span class="n">coefficients</span><span class="o">=</span><span class="n">coefficients</span><span class="p">,</span>
            <span class="n">start_indices</span><span class="o">=</span><span class="n">start_indices</span><span class="p">,</span>
            <span class="n">next_indices</span><span class="o">=</span><span class="n">next_indices</span><span class="p">,</span>
            <span class="n">panel_mapping</span><span class="o">=</span><span class="n">panel_mapping</span><span class="p">,</span>
            <span class="n">spline_mapping</span><span class="o">=</span><span class="n">spline_mapping</span><span class="p">,</span>
            <span class="n">knot_steps</span><span class="o">=</span><span class="n">knot_steps</span><span class="p">,</span>
            <span class="n">panel_shape</span><span class="o">=</span><span class="n">panel_shape</span><span class="p">,</span>
            <span class="n">k1</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">weights</span> <span class="o">*</span> <span class="p">(</span><span class="n">values</span> <span class="o">-</span> <span class="n">fitted_values</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">fpms</span> <span class="o">=</span> <span class="n">fp</span> <span class="o">-</span> <span class="n">s</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fpms</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">accuracy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="n">n_coefficients</span><span class="p">:</span>
                <span class="c1"># Rank deficient solution</span>
                <span class="n">ier</span> <span class="o">=</span> <span class="o">-</span><span class="n">rank</span>
                <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">fitted_values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Good solution</span>
                <span class="n">ier</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">fitted_values</span>

        <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">fpms</span>

        <span class="k">if</span> <span class="n">ich3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f3</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">accuracy</span><span class="p">:</span>
                <span class="c1"># The initial choice of p is too large</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="n">f3</span> <span class="o">=</span> <span class="n">f2</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="mf">0.04</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">p1</span><span class="p">):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">p2</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># next iteration</span>
            <span class="k">elif</span> <span class="n">f2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ich3</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ich1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">accuracy</span><span class="p">:</span>
                <span class="c1"># The initial choice of p is too small</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span>
                <span class="n">p</span> <span class="o">/=</span> <span class="mf">0.04</span>

                <span class="k">if</span> <span class="n">p3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># next iteration</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">p3</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">p2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">p3</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># next iteration</span>

            <span class="n">ich1</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">f2</span> <span class="o">&gt;=</span> <span class="n">f1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">f2</span> <span class="o">&lt;=</span> <span class="n">f3</span><span class="p">):</span>
            <span class="c1"># Can&#39;t determine p</span>
            <span class="n">ier</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">fitted_values</span>

        <span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">rational_interp_zero</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span>
                                                         <span class="n">f2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">f3</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Iteration reached maximum number</span>
        <span class="n">ier</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span><span class="p">,</span> <span class="n">fitted_values</span></div>



<div class="viewcode-block" id="discontinuity_jumps">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.discontinuity_jumps">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">discontinuity_jumps</span><span class="p">(</span><span class="n">knot_line</span><span class="p">,</span> <span class="n">n_knot</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">b_spline</span>
                        <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the discontinuity jumps.</span>

<span class="sd">    Calculates the discontinuity jumps of the kth derivative of the b-splines</span>
<span class="sd">    of degree k at the knots k+2 -&gt; n - k - 1.  The results are updated</span>
<span class="sd">    in-place in the `b_spline` array.</span>

<span class="sd">    Adapted from the Fortran function fpdisc in the fitpack library.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    knot_line : numpy.ndarray (float)</span>
<span class="sd">        The knot locations in a single dimension of shape (&gt;= n_knots,).</span>
<span class="sd">    n_knot : int</span>
<span class="sd">        The number of knots in the knot line.</span>
<span class="sd">    degree : int</span>
<span class="sd">        The degree of the spline.</span>
<span class="sd">    b_spline : numpy.ndarray (float)</span>
<span class="sd">        An array of shape (max(knot_estimate), k + 2) where k is the degree of</span>
<span class="sd">        the spline containing the spline coefficients.  Values will be updated</span>
<span class="sd">        in-place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">nk1</span> <span class="o">=</span> <span class="n">n_knot</span> <span class="o">-</span> <span class="n">k1</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="p">(</span><span class="n">nk1</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">knot_line</span><span class="p">[</span><span class="n">nk1</span><span class="p">]</span> <span class="o">-</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">degree</span><span class="p">])</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">nk1</span><span class="p">):</span>

        <span class="n">lmk</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">-</span> <span class="n">k1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k1</span><span class="p">):</span>
            <span class="n">ik</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k1</span>
            <span class="n">lj</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">lk</span> <span class="o">=</span> <span class="n">lj</span> <span class="o">-</span> <span class="n">k2</span>
            <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">-</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">lk</span><span class="p">]</span>
            <span class="n">h</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">-</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span>

        <span class="n">lp</span> <span class="o">=</span> <span class="n">lmk</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
            <span class="n">jk</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">):</span>
                <span class="n">jk</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">prod</span> <span class="o">*=</span> <span class="n">h</span><span class="p">[</span><span class="n">jk</span><span class="p">]</span> <span class="o">*</span> <span class="n">fac</span>

            <span class="n">lk</span> <span class="o">=</span> <span class="n">lp</span> <span class="o">+</span> <span class="n">k1</span>
            <span class="n">b_spline</span><span class="p">[</span><span class="n">lmk</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">knot_line</span><span class="p">[</span><span class="n">lk</span><span class="p">]</span> <span class="o">-</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">lp</span><span class="p">])</span> <span class="o">/</span> <span class="n">prod</span>
            <span class="n">lp</span> <span class="o">+=</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="rational_interp_zero">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.rational_interp_zero">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rational_interp_zero</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">f3</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines p where (u + p + v)/(p + w) = 0.</span>

<span class="sd">    Given three points (p1, f1), (p2, f2), (p3, f3), rational_interp_zero gives</span>
<span class="sd">    the value of p such that the rational interpolating function of the form</span>
<span class="sd">    r(p) = (u*p+v)/(p+w) equals zero at p.</span>

<span class="sd">    Adapted from the Fortran function fprati in the fitpack library.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1 : float</span>
<span class="sd">    f1 : float</span>
<span class="sd">    p2 : float</span>
<span class="sd">    f2 : float</span>
<span class="sd">    p3 : float</span>
<span class="sd">    f3 : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p, p1, f1, p2, f2, p3, f3 : float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">p3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># The value of p in case p3 = infinity</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f3</span><span class="p">)</span> <span class="o">*</span> <span class="n">f2</span> <span class="o">-</span> <span class="n">p2</span> <span class="o">*</span> <span class="p">(</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f3</span><span class="p">)</span> <span class="o">*</span> <span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f2</span><span class="p">)</span> <span class="o">*</span> <span class="n">f3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">*</span> <span class="p">(</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f3</span><span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">f2</span> <span class="o">*</span> <span class="p">(</span><span class="n">f3</span> <span class="o">-</span> <span class="n">f1</span><span class="p">)</span>
        <span class="n">h3</span> <span class="o">=</span> <span class="n">f3</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f2</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">p1</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">h3</span> <span class="o">+</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">p3</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">h2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">p1</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">p2</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">+</span> <span class="n">p3</span> <span class="o">*</span> <span class="n">h3</span><span class="p">)</span>

    <span class="c1"># Adjust the value of p1, f1, p3, and f3 such that f1 &gt; 0 and f3 &lt; 0.</span>
    <span class="k">if</span> <span class="n">f2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="n">f3</span> <span class="o">=</span> <span class="n">f2</span>

    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">f3</span></div>



<div class="viewcode-block" id="fit_point">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.fit_point">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fit_point</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">j_rot</span><span class="p">,</span>
              <span class="n">n_spline</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate fitted value given a spline and coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coefficients : numpy.ndarray (float)</span>
<span class="sd">        The coefficients of shape (n_coefficients,).</span>
<span class="sd">    spline : numpy.ndarray (float)</span>
<span class="sd">        The spline for the point of shape (n_dimensions, n_spline).</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        The 1-D to N-D spline mapping array as returned by</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be of shape</span>
<span class="sd">        (n_dimensions, n_spline).</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The N-D to 1-D knot mapping steps as returned by</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be of shape (n_dimensions,).</span>
<span class="sd">    j_rot : int</span>
<span class="sd">        The starting 1-D index on the coefficient array for the given spline.</span>
<span class="sd">    n_spline : int</span>
<span class="sd">        The total number of spline coefficients that will be used to perform</span>
<span class="sd">        the fit.</span>
<span class="sd">    n_dimensions : int</span>
<span class="sd">        The number of dimensions in the fit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fitted_value : float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fit_value</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spline</span><span class="p">):</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">j_rot</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">spline_i</span> <span class="o">=</span> <span class="n">spline_mapping</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">*=</span> <span class="n">spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">spline_i</span><span class="p">]</span>
            <span class="n">i1</span> <span class="o">+=</span> <span class="n">spline_i</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">*=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
        <span class="n">fit_value</span> <span class="o">+=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">fit_value</span></div>



<div class="viewcode-block" id="perform_fit">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.perform_fit">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">perform_fit</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span>
                <span class="n">panel_steps</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">nk1</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">n_knots</span>
                <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a given spline at multiple coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinates : numpy.ndarray (float)</span>
<span class="sd">        The coordinates at which to evaluate the spline of shape</span>
<span class="sd">        (n_dimensions, n).</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    coefficients : numpy.ndarray (float)</span>
<span class="sd">        The spline coefficients of shape (n_coefficients,).</span>
<span class="sd">    degrees : numpy.ndarray (int)</span>
<span class="sd">        The degrees of the spline in each dimension (n_dimensions,).</span>
<span class="sd">    panel_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the panel mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the panel shape (n_knots - (2 * degrees) - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    panel_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in panel-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape `Spline.panel_shape` into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in knot-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    nk1 : numpy.ndarray (int)</span>
<span class="sd">        An array of shape (n_dimensions,) containing the values n_knots - k1</span>
<span class="sd">        where n_knots are the number of knots in each dimension, and k1 are the</span>
<span class="sd">        spline degrees + 1 in each dimension.</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the spline mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the spline shape (degrees + 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_spline_coefficients).</span>
<span class="sd">    n_knots : numpy.ndarray (int)</span>
<span class="sd">        The number of knots in each dimension (n_dimensions,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fitted_values : numpy.ndarray (float)</span>
<span class="sd">        The spline evaluated at `coordinates` of shape (n,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">n_spline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span>
    <span class="n">spline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">k1</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">upper_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">lower_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c1"># Find the panel to which each point belongs</span>

    <span class="n">knot_indices</span> <span class="o">=</span> <span class="n">find_knots</span><span class="p">(</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
        <span class="n">knots</span><span class="o">=</span><span class="n">knots</span><span class="p">,</span>
        <span class="n">valid_knot_start</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
        <span class="n">valid_knot_end</span><span class="o">=</span><span class="n">nk1</span><span class="p">)</span>

    <span class="n">panel_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">panel_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_line</span> <span class="o">=</span> <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">lower_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">upper_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">n_knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">panel_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>

    <span class="n">start_indices</span><span class="p">,</span> <span class="n">next_indices</span> <span class="o">=</span> <span class="n">create_ordering</span><span class="p">(</span><span class="n">panel_indices</span><span class="p">)</span>
    <span class="n">n_panels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">start_indices</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">panel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_panels</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">p_map</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="p">[:,</span> <span class="n">panel</span><span class="p">]</span>
        <span class="n">knot_index</span> <span class="o">=</span> <span class="n">p_map</span> <span class="o">+</span> <span class="n">degrees</span>
        <span class="n">j_rot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">j_rot</span> <span class="o">+=</span> <span class="n">p_map</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">point</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
                <span class="n">x_val</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point</span><span class="p">]</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">lower_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="n">upper_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x_val</span> <span class="o">&lt;</span> <span class="n">ll</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">ll</span>
                <span class="k">elif</span> <span class="n">x_val</span> <span class="o">&gt;</span> <span class="n">ul</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">ul</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_val</span>
                <span class="n">evaluate_bspline</span><span class="p">(</span>
                    <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                    <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>

            <span class="n">fitted_values</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_point</span><span class="p">(</span>
                <span class="n">coefficients</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">j_rot</span><span class="p">,</span>
                <span class="n">n_spline</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">)</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">next_indices</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fitted_values</span></div>



<div class="viewcode-block" id="single_fit">
<a class="viewcode-back" href="../../../../source/grig.toolkit.splines.html#grig.toolkit.splines.spline_utils.single_fit">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">single_fit</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span>
               <span class="n">panel_steps</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">nk1</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span>
               <span class="n">k1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_spline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">work_spline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">lower_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fitted value at the given coordinate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinate : numpy.ndarray (float)</span>
<span class="sd">        The coordinate at which to return a fit of shape (n_dimensions,).</span>
<span class="sd">    knots : numpy.ndarray (float)</span>
<span class="sd">        The knots in each dimension of shape (n_dimensions, max_knot_estimate).</span>
<span class="sd">        Must be monotonically increasing for each dimension.</span>
<span class="sd">    coefficients : numpy.ndarray (float)</span>
<span class="sd">        The coefficients of shape (n_coefficients,).</span>
<span class="sd">    degrees : numpy.ndarray (int)</span>
<span class="sd">        The degrees of the spline in each dimension (n_dimensions,).</span>
<span class="sd">    panel_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the panel mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the panel shape (n_knots - (2 * degrees) - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_panels).</span>
<span class="sd">    panel_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in panel-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape `Spline.panel_shape` into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    knot_steps : numpy.ndarray (int)</span>
<span class="sd">        The flat index mapping steps in knot-space of shape (n_dimensions,).</span>
<span class="sd">        These are returned by passing the shape (n_knots - degrees - 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.</span>
<span class="sd">    nk1 : numpy.ndarray (int)</span>
<span class="sd">        An array of shape (n_dimensions,) containing the values n_knots - k1</span>
<span class="sd">        where n_knots are the number of knots in each dimension, and k1 are the</span>
<span class="sd">        spline degrees + 1 in each dimension.</span>
<span class="sd">    spline_mapping : numpy.ndarray (int)</span>
<span class="sd">        An array containing the spline mapping (flat to n-D) indices.  This is</span>
<span class="sd">        created by passing the spline shape (degrees + 1) into</span>
<span class="sd">        :func:`flat_index_mapping`.  Should be an array of shape</span>
<span class="sd">        (n_dimensions, n_spline_coefficients).</span>
<span class="sd">    k1 : numpy.ndarray (int)</span>
<span class="sd">        An array of shape (n_dimensions,) where k1[dimension] =</span>
<span class="sd">        degree[dimension] + 1.</span>
<span class="sd">    n_spline : int</span>
<span class="sd">        The total number of spline coefficients that will be used to perform</span>
<span class="sd">        the fit.</span>
<span class="sd">    work_spline : numpy.ndarray (float)</span>
<span class="sd">        An optional work array of shape (n_dimensions, max(k1)) that can</span>
<span class="sd">        be supplied in order to skip the overhead involved with array creation.</span>
<span class="sd">    lower_bounds : numpy.ndarray (float)</span>
<span class="sd">        Specifies the lower range of valid coordinates for each dimension and</span>
<span class="sd">        is of shape (n_dimensions,).</span>
<span class="sd">    upper_bounds : numpy.ndarray (float)</span>
<span class="sd">        Specifies the upper range of valid coordinates for each dimension and</span>
<span class="sd">        is of shape (n_dimensions,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fitted_value : float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">knot_index</span> <span class="o">=</span> <span class="n">find_knot</span><span class="p">(</span>
        <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
        <span class="n">knots</span><span class="o">=</span><span class="n">knots</span><span class="p">,</span>
        <span class="n">valid_knot_start</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
        <span class="n">valid_knot_end</span><span class="o">=</span><span class="n">nk1</span><span class="p">,</span>
        <span class="n">allow_outside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="o">=</span><span class="n">lower_bounds</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="o">=</span><span class="n">upper_bounds</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">knot_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">k1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">work_spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">work_spline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">k1</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nb</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_spline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span>

    <span class="n">panel</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">panel</span> <span class="o">+=</span> <span class="p">(</span><span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                  <span class="p">)</span> <span class="o">*</span> <span class="n">panel_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">evaluate_bspline</span><span class="p">(</span>
            <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">coordinate</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
            <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">work_spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>

    <span class="n">panel_map</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="p">[:,</span> <span class="n">panel</span><span class="p">]</span>
    <span class="n">j_rot</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">j_rot</span> <span class="o">+=</span> <span class="n">panel_map</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

    <span class="n">fitted_value</span> <span class="o">=</span> <span class="n">fit_point</span><span class="p">(</span>
        <span class="n">coefficients</span><span class="p">,</span> <span class="n">work_spline</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">j_rot</span><span class="p">,</span>
        <span class="n">n_spline</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fitted_value</span></div>



<span class="k">def</span> <span class="nf">perform_fit_slow</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">panel_mapping</span><span class="p">,</span>
                     <span class="n">panel_steps</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">nk1</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">n_knots</span>
                     <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is for testing purposes only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinates</span>
<span class="sd">    knots</span>
<span class="sd">    coefficients</span>
<span class="sd">    degrees</span>
<span class="sd">    panel_mapping</span>
<span class="sd">    panel_steps</span>
<span class="sd">    knot_steps</span>
<span class="sd">    nk1</span>
<span class="sd">    spline_mapping</span>
<span class="sd">    n_knots</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">n_spline</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">k1</span><span class="p">))</span>
    <span class="n">spline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">k1</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">fitted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">upper_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">lower_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Find the panel to which each point belongs</span>

    <span class="n">knot_indices</span> <span class="o">=</span> <span class="n">find_knots</span><span class="p">(</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
        <span class="n">knots</span><span class="o">=</span><span class="n">knots</span><span class="p">,</span>
        <span class="n">valid_knot_start</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
        <span class="n">valid_knot_end</span><span class="o">=</span><span class="n">nk1</span><span class="p">)</span>

    <span class="n">panel_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">panel_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">knot_line</span> <span class="o">=</span> <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="n">lower_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">upper_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">knot_line</span><span class="p">[</span><span class="n">n_knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">panel_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">knot_indices</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">degree</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>

    <span class="n">start_indices</span><span class="p">,</span> <span class="n">next_indices</span> <span class="o">=</span> <span class="n">create_ordering</span><span class="p">(</span><span class="n">panel_indices</span><span class="p">)</span>
    <span class="n">n_panels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">start_indices</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">panel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_panels</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">start_indices</span><span class="p">[</span><span class="n">panel</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">point</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">p_map</span> <span class="o">=</span> <span class="n">panel_mapping</span><span class="p">[:,</span> <span class="n">panel</span><span class="p">]</span>
        <span class="n">knot_index</span> <span class="o">=</span> <span class="n">p_map</span> <span class="o">+</span> <span class="n">degrees</span>
        <span class="n">j_rot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">j_rot</span> <span class="o">+=</span> <span class="n">p_map</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">*</span> <span class="n">knot_steps</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">point</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
                <span class="n">x_val</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">dimension</span><span class="p">,</span> <span class="n">point</span><span class="p">]</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="n">lower_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="n">upper_limits</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x_val</span> <span class="o">&lt;</span> <span class="n">ll</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">ll</span>
                <span class="k">elif</span> <span class="n">x_val</span> <span class="o">&gt;</span> <span class="n">ul</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">ul</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_val</span>
                <span class="n">evaluate_bspline</span><span class="p">(</span>
                    <span class="n">knots</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">degrees</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                    <span class="n">knot_index</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">spline</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>

            <span class="n">fitted_values</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_point</span><span class="p">(</span>
                <span class="n">coefficients</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">spline_mapping</span><span class="p">,</span> <span class="n">knot_steps</span><span class="p">,</span> <span class="n">j_rot</span><span class="p">,</span>
                <span class="n">n_spline</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">)</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">next_indices</span><span class="p">[</span><span class="n">point</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fitted_values</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.toolkit.splines.spline_utils</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>