<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grig.resample_base &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=9559a862"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.resample_base</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for grig.resample_base</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">import</span> <span class="nn">bottleneck</span> <span class="k">as</span> <span class="nn">bn</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">psutil</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">gamma</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">mkdtemp</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">grig.grid.base_grid</span> <span class="kn">import</span> <span class="n">BaseGrid</span>
<span class="kn">from</span> <span class="nn">grig.resample_utils</span> <span class="kn">import</span> <span class="n">scale_coordinates</span>
<span class="kn">from</span> <span class="nn">grig.toolkit.multiproc</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">multitask</span><span class="p">,</span> <span class="n">relative_cores</span><span class="p">,</span> <span class="n">pickle_object</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">grig.toolkit.func</span> <span class="kn">import</span> <span class="n">robust_mask</span>
<span class="kn">from</span> <span class="nn">grig.tree.base_tree</span> <span class="kn">import</span> <span class="n">BaseTree</span>


<span class="n">_global_resampling_values</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ResampleBase&#39;</span><span class="p">,</span> <span class="s1">&#39;_global_resampling_values&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="ResampleBase">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase">[docs]</a>
<span class="k">class</span> <span class="nc">ResampleBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                 <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">robust</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negthresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window_estimate_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">window_estimate_percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">window_estimate_oversample</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                 <span class="n">large_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">check_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">memory_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class to resample data using local polynomial fits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : array_like of float</span>
<span class="sd">            (n_features, n_samples) array of independent values.  A local</span>
<span class="sd">            internal copy will be created if it is not a numpy.float64</span>
<span class="sd">            type.</span>
<span class="sd">        data : array_like of float</span>
<span class="sd">            (n_sets, n_samples) or (n_samples,) array of dependent values.</span>
<span class="sd">            multiple (n_sets) sets of data are supplied, then n_sets solutions</span>
<span class="sd">            will be calculated at each resampling point.</span>
<span class="sd">        error : array_like of float, optional</span>
<span class="sd">            (n_sets, n_samples) or (n_samples,) array of error (1-sigma) values</span>
<span class="sd">            associated with the `data` array.  `error` will be used to</span>
<span class="sd">            weight fits, and be propagated to the output error values.  If not</span>
<span class="sd">            supplied, the error may still be calculated from residuals to the</span>
<span class="sd">            fit during :func:`ResamplePolynomial.__call__`.</span>
<span class="sd">        mask : array_like of bool, optional</span>
<span class="sd">            (n_sets, n_data) or (n_data,) array of bool where `True`</span>
<span class="sd">            indicates a valid data point that can be included the fitting</span>
<span class="sd">            and `False` indicates data points that should be excluded from</span>
<span class="sd">            the fit.  Masked points will be reflected in the output counts</span>
<span class="sd">            array.  If not supplied, all samples are considered valid.</span>
<span class="sd">        window : array_like or float or int, optional</span>
<span class="sd">            (n_features,) array or single value specifying the maximum</span>
<span class="sd">            distance (distance definition is handled by `distance_kwargs`) of a</span>
<span class="sd">            data sample from a resampling point such that it can be included in</span>
<span class="sd">            a local fit.  `window` may be declared for each feature.  For</span>
<span class="sd">            example, when fitting 2-dimensional (x, y) data, a window of 1.0</span>
<span class="sd">            would create a circular fitting window around each resampling</span>
<span class="sd">            point, whereas a window of (1.0, 0.5) would create an elliptical</span>
<span class="sd">            fitting window with a semi-major axis of 1.0 in x and semi-minor</span>
<span class="sd">            axis of 0.5 in y.  If not supplied, `window` is estimated via</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        robust : float, optional</span>
<span class="sd">            Specifies an outlier rejection threshold for `data`. A data point</span>
<span class="sd">            is identified as an outlier if abs(x_i - x_med)/MAD &gt; robust, where</span>
<span class="sd">            x_med is the median, and MAD is the Median Absolute Deviation</span>
<span class="sd">            defined as 1.482 * median(abs(x_i - x_med)).</span>
<span class="sd">        negthresh : float, optional</span>
<span class="sd">            Specifies a negative value rejection threshold such that</span>
<span class="sd">            data &lt; (-stddev(data) * negthresh) will be excluded from the fit.</span>
<span class="sd">        window_estimate_bins : int, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        window_estimate_percentile : int or float, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        window_estimate_oversample : int or float, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            Number of points at which to switch to brute-force during the</span>
<span class="sd">            ball tree query algorithm.  See `sklearn.neighbours.BallTree`</span>
<span class="sd">            for further details.</span>
<span class="sd">        large_data : bool, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the ball tree should be created on</span>
<span class="sd">            subsets of the data.</span>
<span class="sd">        check_memory : bool, optional</span>
<span class="sd">            If `True`, check the memory requirements for resampling the</span>
<span class="sd">            supplied data.</span>
<span class="sd">        memory_buffer : float, optional</span>
<span class="sd">            A fraction (positive or negative) with which to modify the memory</span>
<span class="sd">            estimates for the process memory requirements.  Memory estimates</span>
<span class="sd">            are scaled by the factor 1 + memory_buffer.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.  This is important in determining which samples lie</span>
<span class="sd">            inside the window region of a resampling point, and when deriving</span>
<span class="sd">            distance weighting factors.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : Invalid inputs to __init__ or __call__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_sets</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multiset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_error_valid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_settings</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_input_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                                 <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">negthresh</span><span class="o">=</span><span class="n">negthresh</span><span class="p">,</span>
                                 <span class="n">robust</span><span class="o">=</span><span class="n">robust</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_sample_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">window_estimate_bins</span><span class="o">=</span><span class="n">window_estimate_bins</span><span class="p">,</span>
            <span class="n">window_estimate_percentile</span><span class="o">=</span><span class="n">window_estimate_percentile</span><span class="p">,</span>
            <span class="n">window_estimate_oversample</span><span class="o">=</span><span class="n">window_estimate_oversample</span><span class="p">,</span>
            <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="n">large_data</span><span class="o">=</span><span class="n">large_data</span><span class="p">,</span>
            <span class="n">check_memory</span><span class="o">=</span><span class="n">check_memory</span><span class="p">,</span> <span class="n">memory_buffer</span><span class="o">=</span><span class="n">memory_buffer</span><span class="p">,</span>
            <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : number of data features (dimensions)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multi_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : True if solving for multiple data sets&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : The number of data sets to fit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_sets</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : The number of samples in each data set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray (n_features,) : Window radius in each dimension.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;dict : Fit reduction settings applied during last call&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_settings</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fitting tree representative of points to fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseTree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">tree</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the grid class of the resampler</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseGrid subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_class</span><span class="p">()</span>

<div class="viewcode-block" id="ResampleBase.sufficient_memory_for">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.sufficient_memory_for">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sufficient_memory_for</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether there is sufficient available memory for the task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        memory : int or None</span>
<span class="sd">            The memory required for the task in bytes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        perform_task : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">memory</span> <span class="o">&lt;</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span><span class="o">.</span><span class="n">available</span></div>


<div class="viewcode-block" id="ResampleBase.global_resampling_values">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.global_resampling_values">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">global_resampling_values</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the global resampling values.</span>

<span class="sd">        The global resampling values are of main importance when performing</span>
<span class="sd">        multiprocessing, and allows each process to gain fast access to the</span>
<span class="sd">        necessary data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_global_resampling_values</span></div>


<div class="viewcode-block" id="ResampleBase.estimate_max_bytes">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.estimate_max_bytes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_max_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_sets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">full_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the maximum number of bytes required by a reduction.</span>

<span class="sd">        Assumes that many factors are precalculated for processing time</span>
<span class="sd">        reduction and that the ball-tree is constructed in the least efficient</span>
<span class="sd">        configuration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates for the tree of shape (n_dimensions, n)</span>
<span class="sd">        window : int or float, optional</span>
<span class="sd">            The size of the tree windows</span>
<span class="sd">        n_sets : int, optional</span>
<span class="sd">            The number of data sets to reduce sharing coordinates.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            The number of leaves used to construct the ball-tree.</span>
<span class="sd">        full_tree : bool, optional</span>
<span class="sd">            Calculate the maximum number of bytes if the full ball-tree is</span>
<span class="sd">            pre-calculated.  Otherwise, calculates the size of a single</span>
<span class="sd">            neighborhood sized ball-tree.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments to pass into the calculation for</span>
<span class="sd">            subclasses of the Reduction.  Will include `order` (`int`) for</span>
<span class="sd">            polynomial resampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_size : int</span>
<span class="sd">            An upper limit for the maximum number of bytes used to construct</span>
<span class="sd">            the reduction including pre-calculation and all possible inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">BaseTree</span><span class="o">.</span><span class="n">get_class_for</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">tree_bytes</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">estimate_max_bytes</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span>
            <span class="n">full_tree</span><span class="o">=</span><span class="n">full_tree</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">float_bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">n_dimensions</span>

        <span class="c1"># A second hood tree is built for the fitting coordinates</span>
        <span class="n">hood_tree_bytes</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">estimate_hood_tree_bytes</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

        <span class="c1"># 3 is from data, mask, and error</span>
        <span class="n">data_sets</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n_sets</span>
        <span class="n">data_bytes</span> <span class="o">=</span> <span class="n">data_sets</span> <span class="o">*</span> <span class="n">float_bytes</span>
        <span class="k">return</span> <span class="n">data_bytes</span> <span class="o">+</span> <span class="n">tree_bytes</span> <span class="o">+</span> <span class="n">hood_tree_bytes</span></div>


<div class="viewcode-block" id="ResampleBase.get_grid_class">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.get_grid_class">[docs]</a>
    <span class="k">def</span> <span class="nf">get_grid_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the appropriate grid class for the resampler.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseGrid subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BaseGrid</span><span class="o">.</span><span class="n">get_class_for</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_process_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">negthresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Formats the input data, error, and mask for subsequent use.</span>

<span class="sd">        Sets the data, mask, and error attributes to numpy arrays of shape</span>
<span class="sd">        (n_sets, n_samples).</span>

<span class="sd">        The output mask will be a union of the input mask (if there is one) and</span>
<span class="sd">        finite data values and nonzero error values.  If the user has provided</span>
<span class="sd">        `robust` or `negthresh` then the mask will be updated to reflect this.</span>
<span class="sd">        See :func:`ResamplePolynomial.__init__` for further details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_input_arrays</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_samples</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiset</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_sets</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiset</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_sets</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">robust_mask</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">robust</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">negthresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="p">(</span><span class="o">-</span><span class="n">rms</span> <span class="o">*</span> <span class="n">negthresh</span><span class="p">)</span>

        <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_error_valid</span> <span class="o">=</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_valid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_sets</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">error</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

            <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">invalid</span> <span class="o">|=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="n">invalid</span> <span class="o">|=</span> <span class="n">error</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">error</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_set</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All data has been flagged as invalid&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">invalid</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_input_arrays</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks the validity of arguments to __init__</span>

<span class="sd">        Checks that sample coordinates, values, error, and mask have compatible</span>
<span class="sd">        dimensions.</span>

<span class="sd">        Raises a ValueError if an argument or parameter is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coordinates array must have 1 (n_samples,) &quot;</span>
                             <span class="s2">&quot;or 2 (n_features, n_samples) axes.&quot;</span><span class="p">)</span>

        <span class="n">ndata</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data sample size does not match coordinates&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data must have 1 or 2 (multi-set) dimensions&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Error may either be scalar value applied to all, or an array</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span> <span class="ow">and</span> <span class="n">error</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">error</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                        <span class="ow">and</span> <span class="n">error</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># Error contains a single value for each data set</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Error must be a single value, an array matching the &quot;</span>
                        <span class="s2">&quot;data shape, or an array containing a single value &quot;</span>
                        <span class="s2">&quot;for each data set.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mask shape does not match data&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span>

<div class="viewcode-block" id="ResampleBase.set_sample_tree">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.set_sample_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sample_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                        <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">window_estimate_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                        <span class="n">window_estimate_percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">window_estimate_oversample</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                        <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                        <span class="n">large_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">check_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">memory_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">memory_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the sample tree from input coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (float)</span>
<span class="sd">            The input coordinates of shape (n_features, n_samples).</span>
<span class="sd">        radius :  float or sequence (float), optional</span>
<span class="sd">            The radius of the window around each fitting point used to</span>
<span class="sd">            determine sample selection for fit.  If not supplied, will be</span>
<span class="sd">            estimated using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        window_estimate_bins : int, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        window_estimate_percentile : int or float, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        window_estimate_oversample : int or float, optional</span>
<span class="sd">            Used to estimate the `window` if not supplied using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            Number of points at which to switch to brute-force during the</span>
<span class="sd">            ball tree query algorithm.  See `sklearn.neighbours.BallTree`</span>
<span class="sd">            for further details.</span>
<span class="sd">        large_data : bool or None, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the ball tree should be created on</span>
<span class="sd">            subsets of the data.</span>
<span class="sd">        check_memory : bool, optional</span>
<span class="sd">            If `True`, check the memory requirements for resampling the</span>
<span class="sd">            supplied data.</span>
<span class="sd">        memory_buffer : float, optional</span>
<span class="sd">            A fraction (positive or negative) with which to modify the memory</span>
<span class="sd">            estimates for the process memory requirements.  Memory estimates</span>
<span class="sd">            are scaled by the factor 1 + memory_buffer.</span>
<span class="sd">        memory_kwargs : dict, optional</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.  This is important in determining which samples lie</span>
<span class="sd">            inside the window region of a resampling point, and when deriving</span>
<span class="sd">            distance weighting factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_to_window</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">feature_bins</span><span class="o">=</span><span class="n">window_estimate_bins</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">window_estimate_percentile</span><span class="p">,</span>
            <span class="n">oversample</span><span class="o">=</span><span class="n">window_estimate_oversample</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">memory_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memory_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">check_memory</span><span class="p">:</span>
            <span class="n">full_process_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_max_bytes</span><span class="p">(</span>
                <span class="n">scaled_coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span>
                <span class="n">n_sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">full_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">memory_kwargs</span><span class="p">)</span>
            <span class="n">split_process_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_max_bytes</span><span class="p">(</span>
                <span class="n">scaled_coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span>
                <span class="n">n_sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">full_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">memory_kwargs</span><span class="p">)</span>
            <span class="n">available_memory</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span><span class="o">.</span><span class="n">total</span>

            <span class="k">if</span> <span class="n">memory_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">memory_buffer</span><span class="p">)</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">split_process_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">split_process_size</span><span class="p">)</span>
                <span class="n">full_process_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">full_process_size</span><span class="p">)</span>

            <span class="n">max_cores</span> <span class="o">=</span> <span class="n">relative_cores</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">process_memory</span> <span class="o">=</span> <span class="n">available_memory</span> <span class="o">-</span> <span class="n">full_process_size</span>
            <span class="n">max_full_jobs</span> <span class="o">=</span> <span class="n">process_memory</span> <span class="o">/</span> <span class="n">full_process_size</span>
            <span class="n">max_split_jobs</span> <span class="o">=</span> <span class="n">process_memory</span> <span class="o">/</span> <span class="n">split_process_size</span>
            <span class="n">max_full_jobs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_full_jobs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_cores</span><span class="p">))</span>
            <span class="n">max_split_jobs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_split_jobs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_cores</span><span class="p">))</span>

            <span class="n">memory_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;available_memory&#39;</span><span class="p">:</span> <span class="n">available_memory</span><span class="p">,</span>
                           <span class="s1">&#39;full_process_size&#39;</span><span class="p">:</span> <span class="n">full_process_size</span><span class="p">,</span>
                           <span class="s1">&#39;split_process_size&#39;</span><span class="p">:</span> <span class="n">split_process_size</span><span class="p">,</span>
                           <span class="s1">&#39;max_full_jobs&#39;</span><span class="p">:</span> <span class="n">max_full_jobs</span><span class="p">,</span>
                           <span class="s1">&#39;max_split_jobs&#39;</span><span class="p">:</span> <span class="n">max_split_jobs</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">large_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_processes</span> <span class="o">=</span> <span class="n">max_cores</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for main process</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">max_processes</span> <span class="o">*</span> <span class="n">full_process_size</span>
                <span class="n">large_data</span> <span class="o">=</span> <span class="n">max_size</span> <span class="o">&gt;=</span> <span class="n">available_memory</span>
            <span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;large_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">large_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memory_info</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">large_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">large_data</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">tree_class</span> <span class="o">=</span> <span class="n">BaseTree</span><span class="o">.</span><span class="n">get_class_for</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span> <span class="o">=</span> <span class="n">tree_class</span><span class="p">(</span>
            <span class="n">scaled_coordinates</span><span class="p">,</span> <span class="n">build_type</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span>
            <span class="n">large_data</span><span class="o">=</span><span class="n">large_data</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span> <span class="o">=</span> <span class="n">memory_info</span></div>


    <span class="k">def</span> <span class="nf">_scale_to_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">feature_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                         <span class="n">oversample</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale input coordinates to units of the resampling window.</span>

<span class="sd">        Coordinates (:math:`x`) are scaled such that for dimension :math:`k`,</span>
<span class="sd">        the coordinates stored in the resampling tree (see</span>
<span class="sd">        :func:`resampling.tree.BaseTree`) are set as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            x_k^{\prime} = \frac{x_k - min(x_k)}{\Omega_k}</span>

<span class="sd">        where :math:`\Omega` is the resampling window radius.  If the window</span>
<span class="sd">        radius (or principle axes) are unknown, an attempt is made to determine</span>
<span class="sd">        one using `:func:`Resampler.estimate_feature_windows`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (n_features, n_coordinates)</span>
<span class="sd">            The sample coordinates.</span>
<span class="sd">        radius : numpy.ndarray (n_features,), optional</span>
<span class="sd">            The radius of the window around each fitting point used to</span>
<span class="sd">            determine sample selection for fit.  If not supplied, will be</span>
<span class="sd">            estimated using</span>
<span class="sd">            :func:`ResamplePolynomial.estimate_feature_windows`.</span>
<span class="sd">        feature_bins : int, optional</span>
<span class="sd">            When estimating `radius`, gives the number of bins in each</span>
<span class="sd">            dimension by which to equally divide (by ordinate, not count) the</span>
<span class="sd">            feature coordinates for the purposes of finding the sample density.</span>
<span class="sd">        percentile : int or float, optional</span>
<span class="sd">            When estimating `radius`, the percentile used to define a</span>
<span class="sd">            representative value for samples per bin.  The default (50), gives</span>
<span class="sd">            the median of all bin populations.</span>
<span class="sd">        oversample : int or float, optional</span>
<span class="sd">            When estimating `radius`, the oversampling factor for the window</span>
<span class="sd">            region.  A value of one will result in a window that should provide</span>
<span class="sd">            the exact number of samples required for a fit assuming uniform</span>
<span class="sd">            density of the samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scaled_coordinates : numpy.ndarray (n_features, n_coordinates)</span>
<span class="sd">            The coordinates scaled to units of the window radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_feature_windows</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">feature_bins</span><span class="o">=</span><span class="n">feature_bins</span><span class="p">,</span>
                <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
                <span class="n">oversample</span><span class="o">=</span><span class="n">oversample</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">radius</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">:</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_offsets</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">scale_coordinates</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_offsets</span><span class="p">)</span>

<div class="viewcode-block" id="ResampleBase.estimate_feature_windows">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.estimate_feature_windows">[docs]</a>
    <span class="k">def</span> <span class="nf">estimate_feature_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">feature_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                 <span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">oversample</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the radius of the fitting window for each feature.</span>

<span class="sd">        The estimate of the window is given as the minimum required to</span>
<span class="sd">        theoretically allow for a polynomial fit based on the number of samples</span>
<span class="sd">        within such a window.  Since the window is a constant of the</span>
<span class="sd">        resampling algorithm, it is difficult to calculate a precise value</span>
<span class="sd">        that will allow all fits to occur at every point within (or close to)</span>
<span class="sd">        the sample distribution.</span>

<span class="sd">        Therefore, the sample distribution is divided up into `feature_bins`</span>
<span class="sd">        n-dimensional boxes over each feature.  For example, if</span>
<span class="sd">        `feature_bins=10` for 2-dimensional data, we would divide the sample</span>
<span class="sd">        distribution into a total of 100 (10 * 10) equal boxes before counting</span>
<span class="sd">        the number of samples inside each box.</span>

<span class="sd">        The number of samples used to then calculate the final window radius</span>
<span class="sd">        is determined from a given `percentile` (default = 50) of the box</span>
<span class="sd">        counts.</span>

<span class="sd">        For a fit of polynomial order :math:`p`, the minimum number of samples</span>
<span class="sd">        required for fitting is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            N = (p + 1)^K</span>

<span class="sd">        for :math:`K` features if the order is &quot;symmetrical&quot; (i.e., the same</span>
<span class="sd">        for each feature), or</span>

<span class="sd">        .. math::</span>

<span class="sd">            N_{required} = \prod_{k=1}^{K}{(p_k + 1)}</span>

<span class="sd">        if the fit order varies by feature.  Coordinates are then scaled so</span>
<span class="sd">        that:</span>

<span class="sd">        .. math::</span>

<span class="sd">            x_k^{\prime} = \text{feature\_bins} \times \frac{x_k - min(x_k)}</span>
<span class="sd">                           {\beta_k}</span>

<span class="sd">        where the scaling factor :math:`\beta_k = max(x_k) - min(x_k)`. In this</span>
<span class="sd">        scheme, the coordinates have been normalized such that the width of the</span>
<span class="sd">        bin in each dimension is 1, and has a volume equal to one.  Therefore,</span>
<span class="sd">        the sample density (:math:`\rho`) of the bin is equal to the number of</span>
<span class="sd">        samples it contains.  The volume of a unit radius spheroid is then</span>
<span class="sd">        calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            V_{r=1} = \frac{\pi^{K/2}}{\Gamma(\frac{n}{2} + 1)}</span>

<span class="sd">        and the expected number of samples expected to fall inside the spheroid</span>
<span class="sd">        is given as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            N_{r=1} = \rho V_{r=1}</span>

<span class="sd">        We can then set the radius of the spheroid to give the required number</span>
<span class="sd">        of points as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            r_{scaled} = \left( \frac{N_{required} \nu}{N_{r=1}}</span>
<span class="sd">                         \right)^{\frac{1}{K}} + \epsilon</span>

<span class="sd">        where :math:`\nu` is the `oversample` factor and :math:`\epsilon` is</span>
<span class="sd">        added to ensure that if resampling on a uniform grid of samples,</span>
<span class="sd">        fitting at a point between two samples will always result in enough</span>
<span class="sd">        samples available to perform a fit.  :math:`\epsilon` is given as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \epsilon = 0.5 \rho^{\frac{-1}{K}}</span>

<span class="sd">        or half the average spacing between samples.  We can then define the</span>
<span class="sd">        final window radius for dimension :math:`k` as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Omega_k = \frac{\beta_k r_{scaled}}{\text{feature\_bins}}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (n_features, n_coordinates)</span>
<span class="sd">            The coordinates of all samples to be fit.</span>
<span class="sd">        feature_bins : int, optional</span>
<span class="sd">            The number of bins to divide the sample coordinates into, per</span>
<span class="sd">            feature, when determining the sample density (default = 10).</span>
<span class="sd">        percentile : int or float, optional</span>
<span class="sd">            The percentile used to define a representative value for samples</span>
<span class="sd">            per bin.  The default (50), gives the median of all bin</span>
<span class="sd">            populations.</span>
<span class="sd">        oversample : int or float, optional</span>
<span class="sd">            The oversampling factor for the window region.  A value of one will</span>
<span class="sd">            result in a window that should provide the exact number of samples</span>
<span class="sd">            required for a polynomial fit of the given order assuming</span>
<span class="sd">            uniform density of the samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        window : numpy.ndarray (n_features,)</span>
<span class="sd">            The principle axes of an ellipsoid used to create a fitting</span>
<span class="sd">            region around each resampling point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Scale all coordinates between 0 and 1 (inclusive)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">features</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">feature_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">feature_bins</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">feature_bins</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">feature_bins</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">feature_bins</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span>
            <span class="n">x0</span><span class="p">,</span> <span class="p">[</span><span class="n">feature_bins</span><span class="p">]</span> <span class="o">*</span> <span class="n">features</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">bin_population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">percentile</span><span class="p">)</span>

        <span class="n">unit_spheroid_volume</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="p">(</span><span class="n">features</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                                <span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">((</span><span class="n">features</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">bin_volume</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># in units of feature_bins (just for my notes)</span>
        <span class="n">bin_density</span> <span class="o">=</span> <span class="n">bin_population</span> <span class="o">/</span> <span class="n">bin_volume</span>
        <span class="n">unit_spheroid_count</span> <span class="o">=</span> <span class="n">unit_spheroid_volume</span> <span class="o">*</span> <span class="n">bin_density</span>

        <span class="n">required_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_minimum_points</span><span class="p">()</span>
        <span class="n">unit_radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">required_samples</span> <span class="o">*</span> <span class="n">oversample</span>
                       <span class="o">/</span> <span class="n">unit_spheroid_count</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">features</span><span class="p">)</span>

        <span class="n">unit_sample_spacing</span> <span class="o">=</span> <span class="n">bin_density</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">features</span><span class="p">)</span>
        <span class="n">max_offset</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">unit_sample_spacing</span>
        <span class="n">unit_radius</span> <span class="o">+=</span> <span class="n">max_offset</span>

        <span class="n">scaled_radius</span> <span class="o">=</span> <span class="n">unit_radius</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">/</span> <span class="n">feature_bins</span>

        <span class="k">return</span> <span class="n">scaled_radius</span></div>


<div class="viewcode-block" id="ResampleBase.calculate_minimum_points">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.calculate_minimum_points">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_minimum_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum number of points for a fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : n-tuple</span>
<span class="sd">            Input arguments used to determine the number of points required for</span>
<span class="sd">            a fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        minimum_points : int</span>
<span class="sd">            The minimum number of points for a fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ResampleBase.reduction_settings">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.reduction_settings">[docs]</a>
    <span class="k">def</span> <span class="nf">reduction_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_weighting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">fit_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                           <span class="n">edge_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">edge_algorithm</span><span class="o">=</span><span class="s1">&#39;distribution&#39;</span><span class="p">,</span>
                           <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_threading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a set of reduction instructions based on user input.</span>

<span class="sd">        This method is responsible for determining, formatting, and checking</span>
<span class="sd">        a number variables required for the resampling algorithm based on</span>
<span class="sd">        user input.  For detailed descriptions of user options, please see</span>
<span class="sd">        :func:`ResamplePolynomial.__call__`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_weighting : bool, optional</span>
<span class="sd">        fit_threshold : float, optional</span>
<span class="sd">        cval : float, optional</span>
<span class="sd">        edge_threshold : float or array_like (n_features,), optional</span>
<span class="sd">        edge_algorithm : str, optional</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">        use_threading : bool, optional</span>
<span class="sd">            If `True`, force use of threads during multiprocessing.</span>
<span class="sd">        use_processes : bool, optional</span>
<span class="sd">            If `True`, force use of sub-processes during multiprocessing.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Optional keyword arguments to the reduction settings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        settings : dict</span>
<span class="sd">            The reduction settings.  Also, stored as</span>
<span class="sd">            :func:`ResamplePolynomial.fit_settings`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">features</span>
        <span class="n">error_weighting</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_valid</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">edge_threshold</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">edge_threshold</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="n">edge_threshold</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">edge_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">edge_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_threshold</span><span class="o">.</span><span class="n">size</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_features</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge threshold size does not match number of &quot;</span>
                             <span class="s2">&quot;features.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">edge_threshold</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">edge_threshold</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">n_features</span><span class="p">:</span>
            <span class="n">edge_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="n">edge_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">edge_func_lookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;distribution&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;ellipsoid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;box&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">edge_algorithm</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">edge_algorithm</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">edge_algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_func_lookup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown edge algorithm: </span><span class="si">{</span><span class="n">edge_algorithm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">edge_algorithm_idx</span> <span class="o">=</span> <span class="n">edge_func_lookup</span><span class="p">[</span><span class="n">edge_algorithm</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">edge_threshold</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge threshold must positive valued.&quot;</span><span class="p">)</span>

        <span class="n">upper_edge_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">edge_algorithm</span> <span class="o">==</span> <span class="s1">&#39;distribution&#39;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">edge_threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">upper_edge_limit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge threshold must be less than &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">upper_edge_limit</span><span class="si">}</span><span class="s2"> for &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">edge_algorithm</span><span class="si">}</span><span class="s2"> algorithm&quot;</span><span class="p">)</span>

        <span class="n">check_fit</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">fit_threshold</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">check_fit</span><span class="p">:</span>
            <span class="n">fit_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">fit_threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fit_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="n">use_processes</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">use_processes</span><span class="p">)</span>
        <span class="n">use_threading</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">use_threading</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_processes</span> <span class="ow">and</span> <span class="n">use_threading</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can use either thread or process based &quot;</span>
                             <span class="s2">&quot;multiprocessing; not both.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">use_processes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_threading</span><span class="p">:</span>
            <span class="n">use_processes</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">block_memory_usage</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;large_data&#39;</span><span class="p">]:</span>
            <span class="n">block_memory_usage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;split_process_size&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">block_memory_usage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;full_process_size&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_settings</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;n_features&#39;</span><span class="p">:</span> <span class="n">n_features</span><span class="p">,</span>
            <span class="s1">&#39;error_weighting&#39;</span><span class="p">:</span> <span class="n">error_weighting</span><span class="p">,</span>
            <span class="s1">&#39;fit_threshold&#39;</span><span class="p">:</span> <span class="n">fit_threshold</span><span class="p">,</span>
            <span class="s1">&#39;cval&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">cval</span><span class="p">),</span>
            <span class="s1">&#39;edge_threshold&#39;</span><span class="p">:</span> <span class="n">edge_threshold</span><span class="p">,</span>
            <span class="s1">&#39;edge_algorithm&#39;</span><span class="p">:</span> <span class="n">edge_algorithm</span><span class="p">,</span>
            <span class="s1">&#39;edge_algorithm_idx&#39;</span><span class="p">:</span> <span class="n">edge_algorithm_idx</span><span class="p">,</span>
            <span class="s1">&#39;jobs&#39;</span><span class="p">:</span> <span class="n">jobs</span><span class="p">,</span>
            <span class="s1">&#39;use_processes&#39;</span><span class="p">:</span> <span class="n">use_processes</span><span class="p">,</span>
            <span class="s1">&#39;use_threading&#39;</span><span class="p">:</span> <span class="n">use_threading</span><span class="p">,</span>
            <span class="s1">&#39;block_memory_usage&#39;</span><span class="p">:</span> <span class="n">block_memory_usage</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_settings</span></div>


    <span class="k">def</span> <span class="nf">_check_call_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the fitting coordinates have the correct dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : N-tuple</span>
<span class="sd">            The input coordinates for each feature.  Either arrays or</span>
<span class="sd">            scalar values for N features.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of features present in the fitting coordinates does</span>
<span class="sd">            not match the sample coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nargs</span><span class="si">}</span><span class="s2">-feature coordinates passed to &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="si">}</span><span class="s2">-feature resampler.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">fit_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">edge_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">edge_algorithm</span><span class="o">=</span><span class="s1">&#39;distribution&#39;</span><span class="p">,</span> <span class="n">error_weighting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_threading</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">get_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">get_cross_derivatives</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample data defined during initialization onto new coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : array_like or n-tuple of array_like</span>
<span class="sd">            args can take one of the following formats:</span>

<span class="sd">                - grid : n-tuple of array_like</span>
<span class="sd">                  Here `n` is the number of dimensions and each array should</span>
<span class="sd">                  be of shape (n_data,).  This indicates that resampling</span>
<span class="sd">                  should occur on a grid where the first argument</span>
<span class="sd">                  corresponds to the coordinates along the first dimension.</span>
<span class="sd">                - single point : n-tuple of float</span>
<span class="sd">                  `n` is the number of dimensions.  The coordinate to</span>
<span class="sd">                  resample onto.</span>
<span class="sd">                - irregular : array_like</span>
<span class="sd">                  An array of shape (n_dimensions, n_ndata) defining a</span>
<span class="sd">                  set of coordinates onto which to resample.</span>

<span class="sd">        fit_threshold : float, optional</span>
<span class="sd">            If nonzero, rejects a polynomial fit if it deviates by</span>
<span class="sd">            `|fit_threshold|` * the RMS of the samples.  If it is rejected,</span>
<span class="sd">            that value will be replaced by the mean (error weighted if set),</span>
<span class="sd">            if `fit_threshold &gt; 0` or NaN if `fit_threshold &lt; 0`.</span>
<span class="sd">        cval : float, optional</span>
<span class="sd">            During fitting, any fit that does not meet the `order_algorithm`</span>
<span class="sd">            requirement will be set to this value. This will be NaN by default.</span>
<span class="sd">        edge_threshold : float or array_like or float</span>
<span class="sd">            If set to a value &gt; 0, edges of the fit will be masked out</span>
<span class="sd">            according to `edge_algorithm`. Values close to zero will result in</span>
<span class="sd">            a low degree of edge clipping, while values close to 1 clip edges</span>
<span class="sd">            to a greater extent.  The exact definition of `edge_threshold`</span>
<span class="sd">            depends on the algorithm.  For further details, please see</span>
<span class="sd">            :func:`resampling.resample_utils.check_edges`.</span>
<span class="sd">        edge_algorithm : str, optional</span>
<span class="sd">            Describes how to clip edges if edge_threshold is non-zero. The</span>
<span class="sd">            available algorithms are:</span>

<span class="sd">                - &#39;distribution&#39; (default): Statistics on sample distributions</span>
<span class="sd">                  are calculated, and if the resampling point is &gt; 1/threshold</span>
<span class="sd">                  standard deviations away from the sample mean, it will be</span>
<span class="sd">                  clipped.</span>
<span class="sd">                - &#39;ellipsoid&#39;: If the samples used to fit a</span>
<span class="sd">                  resampling point deviate from the resampling point</span>
<span class="sd">                  location by more than this amount, it will be clipped.</span>
<span class="sd">                - &#39;box&#39;: If the flattened 1-dimensional distribution</span>
<span class="sd">                  of samples center-of-mass deviates from the resampling</span>
<span class="sd">                  point location in any dimension, it will be clipped.</span>
<span class="sd">                - &#39;range&#39;: Over each dimension, check the distribution of</span>
<span class="sd">                  points is greater than edge_threshold to the &quot;left&quot; and</span>
<span class="sd">                  &quot;right&quot; of the resampling point.</span>
<span class="sd">        error_weighting : bool, optional</span>
<span class="sd">            If `True` (default), weight polynomial fitting by the `error`</span>
<span class="sd">            values of each sample.</span>
<span class="sd">        is_covar : bool, optional</span>
<span class="sd">            If True, the input data is treated as a covariance instead of</span>
<span class="sd">            a flux, and is propagated as if through a weighted mean.</span>
<span class="sd">        jobs : int, optional</span>
<span class="sd">            Specifies the maximum number of concurrently running jobs.  An</span>
<span class="sd">            attempt will be made to parallel process using a thread-pool if</span>
<span class="sd">            available, but will otherwise revert to the &quot;loky&quot; backend.</span>
<span class="sd">            Values of 0 or 1 will result in serial processing.  A negative</span>
<span class="sd">            value sets jobs to `n_cpus + 1 + jobs` such that -1 would use</span>
<span class="sd">            all cpus, and -2 would use all but one cpu.</span>
<span class="sd">        use_threading : bool, optional</span>
<span class="sd">            If `True`, force use of threads during multiprocessing.</span>
<span class="sd">        use_processes : bool, optional</span>
<span class="sd">            If `True`, force use of sub-processes during multiprocessing.</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">            If `True`, If True returns the error which is given as the weighted</span>
<span class="sd">            RMS of the samples used for each resampling point.</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">            If `True` returns the number of samples used to fit each resampling</span>
<span class="sd">            point.</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">            If `True`, returns the sum of all sample weights (error and</span>
<span class="sd">            distance) used in the fit at each resampling point.</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">            If `True`, returns the sum of all sample distance weights (not</span>
<span class="sd">            including error) used in the fit at each resampling point.</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">            If `True`, returns the reduced chi-squared statistic of the fit</span>
<span class="sd">            at each resampling point.  Note that this is only valid if errors</span>
<span class="sd">            were supplied during :func:`ResamplePolynomial.__init__`.</span>
<span class="sd">        get_cross_derivatives : bool, optional</span>
<span class="sd">            If `True`, returns the derivative mean-squared-cross-product of</span>
<span class="sd">            the fit derivatives at each resampling point.</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">            If `True`, returns the offset of the resampling point from the</span>
<span class="sd">            center of the sample distribution used to generate the fit as</span>
<span class="sd">            a variance.  i.e., a return value of 9 indicates a 3-sigma</span>
<span class="sd">            deviation of the resampling point from the sample distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit, [optional return values]</span>
<span class="sd">            The data fit at `args`.  Optional return values may also be</span>
<span class="sd">            returned if any of the get_* options are `True`.  If all are set</span>
<span class="sd">            to `True`, the return order is: fit, error, counts, weights,</span>
<span class="sd">            distance_weights, rchi2, cross_derivatives, offset_variance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_call_arguments</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction_settings</span><span class="p">(</span>
            <span class="n">error_weighting</span><span class="o">=</span><span class="n">error_weighting</span><span class="p">,</span>
            <span class="n">fit_threshold</span><span class="o">=</span><span class="n">fit_threshold</span><span class="p">,</span>
            <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
            <span class="n">edge_threshold</span><span class="o">=</span><span class="n">edge_threshold</span><span class="p">,</span>
            <span class="n">edge_algorithm</span><span class="o">=</span><span class="n">edge_algorithm</span><span class="p">,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">,</span>
            <span class="n">use_threading</span><span class="o">=</span><span class="n">use_threading</span><span class="p">,</span>
            <span class="n">use_processes</span><span class="o">=</span><span class="n">use_processes</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pre_fit</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">jobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check the maximum number of jobs here</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="n">relative_cores</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;large_data&#39;</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">max_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;max_split_jobs&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_info</span><span class="p">[</span><span class="s1">&#39;max_full_jobs&#39;</span><span class="p">]</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">jobs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_jobs</span><span class="p">))</span>

        <span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">distance_weights</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
         <span class="n">derivative_cross_products</span><span class="p">,</span> <span class="n">distribution_offset_variance</span>
         <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_loop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_tree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="p">,</span>
            <span class="n">settings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">get_error</span><span class="o">=</span><span class="n">get_error</span><span class="p">,</span>
            <span class="n">get_counts</span><span class="o">=</span><span class="n">get_counts</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="n">get_weights</span><span class="p">,</span>
            <span class="n">get_distance_weights</span><span class="o">=</span><span class="n">get_distance_weights</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="n">get_rchi2</span><span class="p">,</span>
            <span class="n">get_cross_derivatives</span><span class="o">=</span><span class="n">get_cross_derivatives</span><span class="p">,</span>
            <span class="n">get_offset_variance</span><span class="o">=</span><span class="n">get_offset_variance</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="n">jobs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_set</span><span class="p">:</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">distance_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_cross_derivatives</span><span class="p">:</span>
                <span class="n">derivative_cross_products</span> <span class="o">=</span> <span class="n">derivative_cross_products</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">distribution_offset_variance</span> <span class="o">=</span> <span class="n">distribution_offset_variance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_error</span> <span class="ow">or</span> <span class="n">get_counts</span> <span class="ow">or</span> <span class="n">get_weights</span>
                <span class="ow">or</span> <span class="n">get_rchi2</span> <span class="ow">or</span> <span class="n">get_distance_weights</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">fit</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">error</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">counts</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">weights</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">distance_weights</span><span class="p">),)</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">sigma</span><span class="p">),)</span>

            <span class="k">if</span> <span class="n">get_cross_derivatives</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">singular</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_set</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">derivative_cross_products</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">derivative_cross_products</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">features</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_set</span><span class="p">:</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">derivative_cross_products</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">shape</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">derivative_cross_products</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),)</span>

            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span>
                    <span class="n">distribution_offset_variance</span><span class="p">),)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fit</span>

<div class="viewcode-block" id="ResampleBase.pre_fit">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.pre_fit">[docs]</a>
    <span class="k">def</span> <span class="nf">pre_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform pre-fitting steps and build the fitting tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        settings : dict</span>
<span class="sd">            Settings calculated via `reduction_settings` to be applied</span>
<span class="sd">            if necessary.</span>
<span class="sd">        args : n-tuple</span>
<span class="sd">            The call input arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_class</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tree_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_tree</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">build_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">,</span>
            <span class="n">scale_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale_offsets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResampleBase.block_loop">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.block_loop">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">block_loop</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sample_values</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                   <span class="n">settings</span><span class="p">,</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">get_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">get_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">get_cross_derivatives</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform resampling reduction in parallel or series.</span>

<span class="sd">        Utility function to allow the resampling algorithm to process blocks</span>
<span class="sd">        of data in series or parallel, recombining the data once complete.</span>
<span class="sd">        Please see :func:`ResamplePolynomial.__call__` for descriptions of the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_values : numpy.ndarray</span>
<span class="sd">        error : numpy.ndarray</span>
<span class="sd">        mask : numpy.ndarray</span>
<span class="sd">        fit_tree : BaseTree</span>
<span class="sd">        sample_tree : BaseTree</span>
<span class="sd">        settings : dict</span>
<span class="sd">        iteration : int</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">        get_cross_derivatives : bool, optional</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">        jobs : int, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_results : 8-tuple of numpy.ndarray</span>
<span class="sd">            In order: fit, error, counts, weights, distance weights,</span>
<span class="sd">                reduced chi-squared, MSCP derivatives, distribution offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_values</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                <span class="n">get_error</span><span class="p">,</span> <span class="n">get_counts</span><span class="p">,</span> <span class="n">get_weights</span><span class="p">,</span> <span class="n">get_distance_weights</span><span class="p">,</span>
                <span class="n">get_rchi2</span><span class="p">,</span> <span class="n">get_cross_derivatives</span><span class="p">,</span> <span class="n">get_offset_variance</span><span class="p">,</span>
                <span class="n">settings</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">process_blocks</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span>
                                    <span class="n">fit_tree</span><span class="p">,</span> <span class="n">jobs</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>

        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">sample_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_fits</span> <span class="o">=</span> <span class="n">fit_tree</span><span class="o">.</span><span class="n">n_members</span>
        <span class="n">n_features</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="o">.</span><span class="n">features</span>

        <span class="k">return</span> <span class="n">ResampleBase</span><span class="o">.</span><span class="n">combine_blocks</span><span class="p">(</span>
            <span class="n">blocks</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">,</span> <span class="n">n_features</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cval&#39;</span><span class="p">],</span>
            <span class="n">get_error</span><span class="o">=</span><span class="n">get_error</span><span class="p">,</span>
            <span class="n">get_counts</span><span class="o">=</span><span class="n">get_counts</span><span class="p">,</span>
            <span class="n">get_weights</span><span class="o">=</span><span class="n">get_weights</span><span class="p">,</span>
            <span class="n">get_distance_weights</span><span class="o">=</span><span class="n">get_distance_weights</span><span class="p">,</span>
            <span class="n">get_rchi2</span><span class="o">=</span><span class="n">get_rchi2</span><span class="p">,</span>
            <span class="n">get_cross_derivatives</span><span class="o">=</span><span class="n">get_cross_derivatives</span><span class="p">,</span>
            <span class="n">get_offset_variance</span><span class="o">=</span><span class="n">get_offset_variance</span><span class="p">)</span></div>


<div class="viewcode-block" id="ResampleBase.process_blocks">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.process_blocks">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">process_blocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">sample_tree</span><span class="p">,</span> <span class="n">fit_tree</span><span class="p">,</span>
                       <span class="n">jobs</span><span class="p">,</span> <span class="n">iteration</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for handling block resampling in a multiprocessing environment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : n-tuple</span>
<span class="sd">            The arguments to pass into :func:`multitask`.</span>
<span class="sd">        kwargs : dict or None</span>
<span class="sd">            The keyword arguments to pass into :func:`multitask`.</span>
<span class="sd">        settings : dict</span>
<span class="sd">            Reduction settings.</span>
<span class="sd">        sample_tree : BaseTree</span>
<span class="sd">            The resampling tree in sample space.</span>
<span class="sd">        fit_tree : BaseTree</span>
<span class="sd">            The fitting tree.</span>
<span class="sd">        jobs : int</span>
<span class="sd">            The number of jobs to perform in parallel.</span>
<span class="sd">        iteration : int</span>
<span class="sd">            The current resampling iteration.  This is simply used as a marker</span>
<span class="sd">            to distinguish pickled files on each resampling run.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        blocks : list</span>
<span class="sd">            A list of the return values from the `process_block` method</span>
<span class="sd">            for each block.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">block_population</span> <span class="o">=</span> <span class="n">fit_tree</span><span class="o">.</span><span class="n">block_population</span>
        <span class="n">hood_population</span> <span class="o">=</span> <span class="n">sample_tree</span><span class="o">.</span><span class="n">hood_population</span>

        <span class="n">cores</span> <span class="o">=</span> <span class="n">relative_cores</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cores</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">mkdtemp</span><span class="p">()</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">cache_dir</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;resampling_cache_&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">fit_tree</span><span class="p">)</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">pickle_object</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cache_dir</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;iteration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iteration</span>
        <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;block_memory_usage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;block_memory_usage&#39;</span><span class="p">)</span>
        <span class="n">task_args</span> <span class="o">=</span> <span class="n">filename</span><span class="p">,</span> <span class="n">iteration</span>

        <span class="n">old_threading</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">THREADING_LAYER</span>
        <span class="n">numba</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">THREADING_LAYER</span> <span class="o">=</span> <span class="s1">&#39;threadsafe&#39;</span>
        <span class="n">force_threading</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_threading&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">force_processes</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_processes&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="n">multitask</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">process_block</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">fit_tree</span><span class="o">.</span><span class="n">n_blocks</span><span class="p">),</span> <span class="n">task_args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">jobs</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="p">(</span><span class="n">block_population</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hood_population</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">force_threading</span><span class="o">=</span><span class="n">force_threading</span><span class="p">,</span>
            <span class="n">force_processes</span><span class="o">=</span><span class="n">force_processes</span><span class="p">)</span>

        <span class="n">numba</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">THREADING_LAYER</span> <span class="o">=</span> <span class="n">old_threading</span>

        <span class="k">if</span> <span class="s1">&#39;args&#39;</span> <span class="ow">in</span> <span class="n">_global_resampling_values</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;iteration&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">_global_resampling_values</span><span class="p">[</span><span class="s1">&#39;block_memory_usage&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cache_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blocks</span></div>


<div class="viewcode-block" id="ResampleBase.process_block">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.process_block">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">process_block</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run :func:`solve_fits` on each block.</span>

<span class="sd">        Utility function that parses the settings and tree objects to something</span>
<span class="sd">        usable by the numba JIT compiled resampling functions.  This is not</span>
<span class="sd">        meant to be called directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : 2-tuple</span>
<span class="sd">            A tuple of form (filename, iteration) where the filename is a</span>
<span class="sd">            string pointing towards a previously saved pickle file containing</span>
<span class="sd">            the relevant information for the reduction if required.  If set to</span>
<span class="sd">            `None`, the arguments are retrieved from the</span>
<span class="sd">            `_global_resampling_values` global parameter.</span>
<span class="sd">        block : int</span>
<span class="sd">            The block index to process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : 9-tuple of numpy.ndarray</span>
<span class="sd">            The first element contains the fit point indices to be fit.  For</span>
<span class="sd">            the remaining elements, please see :func:`solve_fits` return</span>
<span class="sd">            values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ResampleBase.combine_blocks">
<a class="viewcode-back" href="../../source/grig.html#grig.resample_base.ResampleBase.combine_blocks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span>
                       <span class="n">get_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">get_distance_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_rchi2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">get_cross_derivatives</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_offset_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines the results from multiple reductions into one set.</span>

<span class="sd">        The resampling reduction may be performed in serial or parallel over</span>
<span class="sd">        multiple &quot;blocks&quot;, where each block contains a set of spatially</span>
<span class="sd">        close fit coordinates and all samples necessary to perform a fit</span>
<span class="sd">        over all points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        blocks : n-tuple of processed reductions for n blocks.</span>
<span class="sd">        n_sets : int</span>
<span class="sd">            The number of data sets in the reduction.  Each set is contains</span>
<span class="sd">            the same sample coordinates as all other sets, but the sample</span>
<span class="sd">            values may vary.</span>
<span class="sd">        n_fits : int</span>
<span class="sd">            The number of fitting points over all blocks.</span>
<span class="sd">        n_dimensions : int</span>
<span class="sd">            The number of coordinate dimensions.</span>
<span class="sd">        cval : float</span>
<span class="sd">            The fill value for missing data in the output fit value arrays.</span>
<span class="sd">        get_error : bool, optional</span>
<span class="sd">            If `True`, indicates that errors on the fit were calculated.</span>
<span class="sd">        get_counts : bool, optional</span>
<span class="sd">            If `True`, indicates that the number of samples used for each</span>
<span class="sd">            fit should be returned.</span>
<span class="sd">        get_weights : bool, optional</span>
<span class="sd">            If `True`, indicates that the total weight sum of all samples used</span>
<span class="sd">            in each fit should be returned.</span>
<span class="sd">        get_distance_weights : bool, optional</span>
<span class="sd">            If `True`, indicates that the distance weight sum of all samples</span>
<span class="sd">            used in each fit should be returned.</span>
<span class="sd">        get_rchi2 : bool, optional</span>
<span class="sd">            If `True`, indicates that the reduced chi-squared statistic for</span>
<span class="sd">            each fit should be returned.</span>
<span class="sd">        get_cross_derivatives : bool, optional</span>
<span class="sd">            If `True`, indicates that the derivative MSCP should be returned.</span>
<span class="sd">        get_offset_variance : bool, optional</span>
<span class="sd">            If `True`, indicates that the offset variance of the fit from the</span>
<span class="sd">            sample distribution should be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : 8-tuple of numpy.ndarray</span>
<span class="sd">            results[0] = fitted values</span>
<span class="sd">            results[1] = error on the fit</span>
<span class="sd">            results[2] = counts</span>
<span class="sd">            results[3] = total weight sums</span>
<span class="sd">            results[4] = total distance weight sums</span>
<span class="sd">            results[5] = reduced chi-squared statistic</span>
<span class="sd">            results[6] = derivative MSCP</span>
<span class="sd">            results[7] = offset variance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The return value is always an 8-tuple, and the get_* keywords indicate</span>
<span class="sd">        whether the calculated values in the block reductions are valid.  If</span>
<span class="sd">        `False`, the corresponding output array will have the correct number of</span>
<span class="sd">        axes, but be of zero size.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cval</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
            <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
            <span class="n">rchi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rchi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_cross_derivatives</span><span class="p">:</span>
            <span class="n">cross_derivatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="p">(</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cross_derivatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_sets</span><span class="p">,</span> <span class="n">n_fits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">fit_indices</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fit</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
                <span class="n">error</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_counts</span><span class="p">:</span>
                <span class="n">counts</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_weights</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_distance_weights</span><span class="p">:</span>
                <span class="n">distance_weights</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_rchi2</span><span class="p">:</span>
                <span class="n">rchi2</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_cross_derivatives</span><span class="p">:</span>
                <span class="n">cross_derivatives</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">get_offset_variance</span><span class="p">:</span>
                <span class="n">offsets</span><span class="p">[:,</span> <span class="n">fit_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">distance_weights</span><span class="p">,</span> <span class="n">rchi2</span><span class="p">,</span>
                <span class="n">cross_derivatives</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.resample_base</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>