<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grig.tree.kernel_tree &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=9559a862"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.tree.kernel_tree</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for grig.tree.kernel_tree</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">grig.tree.base_tree</span> <span class="kn">import</span> <span class="n">BaseTree</span>
<span class="kn">from</span> <span class="nn">grig.toolkit.splines.spline</span> <span class="kn">import</span> <span class="n">Spline</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;KernelTree&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="KernelTree">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.kernel_tree.KernelTree">[docs]</a>
<span class="k">class</span> <span class="nc">KernelTree</span><span class="p">(</span><span class="n">BaseTree</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">build_type</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                 <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">kernel_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">imperfect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">large_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">spline_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a tree structure for use with the kernel resampling algorithm.</span>

<span class="sd">        The resampling tree is primarily responsible for deriving and</span>
<span class="sd">        storing all independent variables necessary for kernel fitting,</span>
<span class="sd">        as well as allowing fast access to those variables that belong to</span>
<span class="sd">        coordinates within a certain radius of a given point.</span>

<span class="sd">        TREE STRUCTURE AND ACCESS</span>

<span class="sd">        The tree itself is divided into N-dimensional blocks, each of which</span>
<span class="sd">        is allocated a set of coordinates.  The width of these blocks should</span>
<span class="sd">        correspond to the `window` (:math:`\Omega`) defined in the resampling</span>
<span class="sd">        algorithm, and coordinates should be scaled accordingly.  For example,</span>
<span class="sd">        if the window radius is set to :math:`\Omega=4` in (arbitrary) units</span>
<span class="sd">        for the purposes of resampling 1-dimensional data, and the independent</span>
<span class="sd">        values are:</span>

<span class="sd">            x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>

<span class="sd">        They should be supplied to the tree as :math:`x^\prime = x / \Omega`.</span>

<span class="sd">        .. math::</span>

<span class="sd">            x^\prime = \frac{x}{\Omega} =</span>
<span class="sd">                [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5]</span>

<span class="sd">        The tree defines blocks by grouping all coordinates with the same</span>
<span class="sd">        floored values into a single block.  Therefore, in this case the tree</span>
<span class="sd">        will contain 3 blocks.  The first contains [0.25, 0.5, 0.75], the</span>
<span class="sd">        second contains [1, 1.25, 1.5, 1.75], and the third contains</span>
<span class="sd">        [2, 2.25, 2.5].</span>

<span class="sd">        The reasoning behind the whole tree structure is to allow for easy</span>
<span class="sd">        extraction of all coordinates within range of a user supplied</span>
<span class="sd">        coordinate.  This is done in two stages:  The first is to find out</span>
<span class="sd">        which block the user supplied coordinate belongs to.  We can then</span>
<span class="sd">        quickly narrow down the search by recognizing that coordinates in the</span>
<span class="sd">        tree population inside the window region of the supplied coordinate</span>
<span class="sd">        must either belong to the same block, or to immediately neighboring</span>
<span class="sd">        blocks since each block of the tree is the same width as the window</span>
<span class="sd">        radius.</span>

<span class="sd">        Once all candidates have been identified, the next step is to keep</span>
<span class="sd">        only those that are within a radius :math:`\Omega` of the user supplied</span>
<span class="sd">        coordinate.  This can be accomplished quickly using the ball-tree</span>
<span class="sd">        algorithm (see :func:`sklearn.neighbors.BallTree`.</span>

<span class="sd">        In practice, the resampling algorithm loops through each block of</span>
<span class="sd">        the tree in parallel.  For each block, all user supplied coordinates</span>
<span class="sd">        (points at which a fit is required) within that block, and all tree</span>
<span class="sd">        members within the neighborhood (the block and all adjacent blocks</span>
<span class="sd">        including diagonals) are evaluated in one step by the ball-tree</span>
<span class="sd">        algorithm so that for each point, we quickly get all tree members</span>
<span class="sd">        within that point&#39;s window region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        argument : numpy.ndarray (n_features, n_samples) or n-tuple</span>
<span class="sd">            Either the independent coordinates of samples in n_features-space,</span>
<span class="sd">            or the shape defining the skeleton of the tree.</span>
<span class="sd">        shape : n-tuple, optional</span>
<span class="sd">            If coordinates were supplied with `argument`, the shape of the</span>
<span class="sd">            tree to build.  Otherwise, the shape will be determined from the</span>
<span class="sd">            coordinate values in each dimension as</span>
<span class="sd">            floor(max(coordinates[i])) + 1 for dimension i.</span>
<span class="sd">        build_type : str, optional</span>
<span class="sd">            Must be one of {&#39;hood&#39;, &#39;balltree&#39;, &#39;all&#39;, None}.  Defines the</span>
<span class="sd">            type of tree structures to create.</span>
<span class="sd">        order : int or array_like (n_features,), optional</span>
<span class="sd">           The symmetrical or asymmetrical orders respectively.  Symmetrical</span>
<span class="sd">           orders are selected by supplying an integer to this parameter.</span>
<span class="sd">        fix_order : bool, optional</span>
<span class="sd">            If `order` is symmetrical, allow for a varying order in an attempt</span>
<span class="sd">            to pass the order validation algorithm (the order can only</span>
<span class="sd">            decrease).</span>
<span class="sd">        balltree_metric : str or sklearn.neighbors.DistanceMetric object</span>
<span class="sd">            The distance metric to use for the tree. Default=’minkowski’ with</span>
<span class="sd">            p=2 (that is, a euclidean metric). See the documentation of the</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric` class for a list of</span>
<span class="sd">            available metrics. ball_tree.valid_metrics gives a list of the</span>
<span class="sd">            metrics which are valid for BallTree.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            If `build_type` was set to &#39;all&#39; or &#39;balltree&#39;, defines the leaf</span>
<span class="sd">            size of the BallTree.  Please see</span>
<span class="sd">            :func:`sklearn.neighbors.BallTree` for further details.</span>
<span class="sd">        kernel : numpy.ndarray (float)</span>
<span class="sd">            The kernel to apply as an array with n_features dimensions.</span>
<span class="sd">        kernel_spacing : float or numpy.ndarray (float), optional</span>
<span class="sd">            The spacing between kernel elements for all or each feature.  If</span>
<span class="sd">            an array is supplied, should be of shape (n_features,).</span>
<span class="sd">        kernel_offsets : tuple or array_like, optional</span>
<span class="sd">            If the kernel is regular, should be an n-dimensional tuple</span>
<span class="sd">            containing the grid indices in each dimension.  Otherwise, should</span>
<span class="sd">            be an array of shape (n_dimensions, kernel.size).</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            Used to specify the smoothing factor.  If set to `None`, the</span>
<span class="sd">            smoothing will be determined based on user settings or input data.</span>
<span class="sd">            If `exact` is `True`, smoothing will be disabled (zero).  If</span>
<span class="sd">            `exact` is `False`, smoothing will be set to n - sqrt(2 * n)</span>
<span class="sd">            where n is the number of data values.  For interpolation, smoothing</span>
<span class="sd">            should be set to zero.  Smoothing must be &gt;= 0.</span>
<span class="sd">        imperfect : bool, optional</span>
<span class="sd">            If a spline fit to the kernel is allowed to be imperfect (`True`),</span>
<span class="sd">            will only raise an error on spline fitting if a major error was</span>
<span class="sd">            encountered.  Otherwise, fits will be permitted so long as a</span>
<span class="sd">            solution was reached, even if that solution did not meet</span>
<span class="sd">            expectations.</span>
<span class="sd">        degrees : int or numpy.ndarray (int), optional</span>
<span class="sd">            The degree of spline to fit in each dimension.  Either a scalar can</span>
<span class="sd">            be supplied pertaining to all dimensions, or an array of shape</span>
<span class="sd">            (n_dimensions,) can be used.</span>
<span class="sd">        large_data : bool, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the ball tree should be created on</span>
<span class="sd">            subsets of the data.</span>
<span class="sd">        spline_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments for spline initialization.  Please see</span>
<span class="sd">            :class:`Spline` for further details.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">build_type</span><span class="o">=</span><span class="n">build_type</span><span class="p">,</span>
                         <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="n">large_data</span><span class="o">=</span><span class="n">large_data</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imperfect</span> <span class="o">=</span> <span class="n">imperfect</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spline_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">spline_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="n">kernel_spacing</span><span class="p">,</span>
                            <span class="n">kernel_offsets</span><span class="o">=</span><span class="n">kernel_offsets</span><span class="p">,</span>
                            <span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">spline_kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the degree of the spline fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The spline degrees of shape (n_dimensions,) for each dimension</span>
<span class="sd">            in (x, y, z, ...) order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">degrees</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline smoothing factor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">smoothing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exit_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline exit code.</span>

<span class="sd">        Please see :class:`Spline` for further details on all codes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">exit_code</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exit_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline exit message.</span>

<span class="sd">        Please see :class:`Spline` for further details on all codes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Spline has not been initialized.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">exit_message</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the spline successfully fit the provided kernel.</span>

<span class="sd">        If imperfect fits are permitted, will return `True` so long as a</span>
<span class="sd">        solution exists.  In cases where imperfect fits are not allowed, the</span>
<span class="sd">        fit will only be considered valid if a full rank solution has been</span>
<span class="sd">        determine, or the fit was successful within the provided user or</span>
<span class="sd">        default parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid : bool</span>
<span class="sd">            `True` if the fit provides a valid solution, and `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_code</span>
        <span class="k">if</span> <span class="n">code</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imperfect</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="o">-</span><span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">code</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">rank</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline coefficients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (float)</span>
<span class="sd">            The spline coefficients of shape (n_coefficients,).  Here,</span>
<span class="sd">            n_coefficients = product(n_knots - degrees - 1) over all</span>
<span class="sd">            dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">coefficients</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">knots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates of the spline knots.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (float)</span>
<span class="sd">            An array of shape (n_dimensions, max(n_knots)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">knots</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">panel_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the 1-D to N-D panel mapping used for subsequent fitting.</span>

<span class="sd">        Each panel is bounded by the knot vertices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The 1-D to N-D panel map of shape (n_dimensions, n_panels).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">panel_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">panel_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the 1-D panel mapping steps for each dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The panel steps of shape (n_dimensions,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">panel_steps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">knot_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the 1-D panel mapping steps for each dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The knot steps of shape (n_dimensions,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">knot_steps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nk1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nk1 values for the knots.</span>

<span class="sd">        The returned value is n_knots - degrees - 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The nk1 values of shape (n_dimensions,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">nk1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spline_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the 1-D to N-D index map for the spline.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            The spline map of shape (n_dimensions, product(degrees + 1)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">spline_mapping</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of spline knots in each dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray (int)</span>
<span class="sd">            An array of shape (n_dimensions,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span><span class="o">.</span><span class="n">n_knots</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the extent of the kernel coordinates in each dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extent : numpy.ndarray (float)</span>
<span class="sd">            An array of shape (n_dimensions, 2) where extent[0, 0] gives the</span>
<span class="sd">            minimum offset for dimension 0 and extent[0, 1] gives the maximum</span>
<span class="sd">            offset for dimension 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">resampling_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spline parameters necessary for resampling.</span>

<span class="sd">        Returns all of the arguments in the correct order necessary for</span>
<span class="sd">        :func:`perform_fit` aside from the coordinates (the first argument).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">panel_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">panel_steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">knot_steps</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nk1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_knots</span><span class="p">)</span>

<div class="viewcode-block" id="KernelTree.set_kernel">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.kernel_tree.KernelTree.set_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kernel_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">degrees</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">imperfect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">spline_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setting the kernel automatically initializes a :class:`Spline` object</span>
<span class="sd">        that is solved and may be used for interpolating kernel values at</span>
<span class="sd">        locations away from the kernel vertices.  Both regular (grid) kernels</span>
<span class="sd">        and irregular kernels may be supplied.  Either `kernel_spacing` or</span>
<span class="sd">        `kernel_offsets` must be supplied in order to determine the coordinates</span>
<span class="sd">        of any interpolated points.  In the case of irregular kernels, these</span>
<span class="sd">        must be provided in `kernel_offsets`.  For regularly spaced grid,</span>
<span class="sd">        `kernel_spacing` may be provided instead.</span>

<span class="sd">        Generally, smoothing should be set to zero for interpolation.  However,</span>
<span class="sd">        in cases where a noisy irregular kernel is provided, smoothing may be</span>
<span class="sd">        set to `None` for a nominal fit, or provided if an optimal value is</span>
<span class="sd">        known.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kernel : numpy.ndarray (float)</span>
<span class="sd">            The kernel to set.  Must have n_features dimensions.</span>
<span class="sd">        kernel_spacing : float or numpy.ndarray (float), optional</span>
<span class="sd">            The spacing between each kernel element in units of the</span>
<span class="sd">            coordinates. Supply either as a single value for all features,</span>
<span class="sd">            or as an array of shape (n_features,) giving the kernel</span>
<span class="sd">            spacing for each feature.</span>
<span class="sd">        kernel_offsets : tuple or array_like, optional</span>
<span class="sd">            If the kernel is regular, should be an n-dimensional tuple</span>
<span class="sd">            containing the grid indices in each dimension.  Otherwise, should</span>
<span class="sd">            be an array of shape (n_dimensions, kernel.size).</span>
<span class="sd">        degrees : int or numpy.ndarray (int), optional</span>
<span class="sd">            The degree of spline to fit in each dimension.  Either a scalar can</span>
<span class="sd">            be supplied pertaining to all dimensions, or an array of shape</span>
<span class="sd">            (n_dimensions,) can be used.</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            Used to specify the smoothing factor.  If set to `None`, the</span>
<span class="sd">            smoothing will be determined based on user settings or input data.</span>
<span class="sd">            If `exact` is `True`, smoothing will be disabled (zero).  If</span>
<span class="sd">            `exact` is `False`, smoothing will be set to n - sqrt(2 * n)</span>
<span class="sd">            where n is the number of data values.  For interpolation,</span>
<span class="sd">            smoothing should be set to zero.  Smoothing must be &gt;= 0.</span>
<span class="sd">        imperfect : bool, optional</span>
<span class="sd">            If a spline fit to the kernel is allowed to be imperfect (`True`),</span>
<span class="sd">            will only raise an error on spline fitting if a major error was</span>
<span class="sd">            encountered.  Otherwise, fits will be permitted so long as a</span>
<span class="sd">            solution was reached, even if that solution did not meet</span>
<span class="sd">            expectations.</span>
<span class="sd">        spline_kwargs : dict, optional</span>
<span class="sd">            Please see :class:`Spline` for a list of all spline initialization</span>
<span class="sd">            keyword arguments.  Note that `solve` will always be set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">imperfect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imperfect</span> <span class="o">=</span> <span class="n">imperfect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="n">kernel_spacing</span><span class="p">,</span>
                          <span class="n">kernel_offsets</span><span class="o">=</span><span class="n">kernel_offsets</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_spline</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">,</span> <span class="o">**</span><span class="n">spline_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="KernelTree.parse_kernel">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.kernel_tree.KernelTree.parse_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">parse_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">kernel_offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check and then convert the kernel arguments for spline fitting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kernel : numpy.ndarray (float)</span>
<span class="sd">            The kernel to set.  Must have n_features dimensions.</span>
<span class="sd">        kernel_spacing : float or numpy.ndarray (float), optional</span>
<span class="sd">            The spacing between each kernel element in units of the</span>
<span class="sd">            coordinates. Supply either as a single value for all features,</span>
<span class="sd">            or as an array of shape (n_features,) giving the kernel spacing</span>
<span class="sd">            for each feature.</span>
<span class="sd">        kernel_offsets : tuple or array_like, optional</span>
<span class="sd">            If the kernel is regular, should be an n-dimensional tuple</span>
<span class="sd">            containing the grid indices in each dimension.  Otherwise, should</span>
<span class="sd">            be an array of shape (n_dimensions, kernel.size).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">get_offsets</span> <span class="o">=</span> <span class="n">kernel_offsets</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">kernel_spacing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kernel_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply either kernel_spacing or &quot;</span>
                             <span class="s2">&quot;kernel_offsets.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_offsets</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Kernel must have the same number of &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;dimensions as the input data &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="n">irregular</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">get_offsets</span><span class="p">:</span>
            <span class="n">kernel_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel_spacing</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="c1"># Expand to all dimensions if a single value was supplied.</span>
            <span class="k">if</span> <span class="n">kernel_spacing</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">kernel_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">kernel_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">kernel_spacing</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Kernel spacing size does not equal the number of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;features (</span><span class="si">{</span><span class="n">kernel_spacing</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">kernel_offsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
                <span class="n">numpy_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>
                <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">numpy_axis</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
                <span class="n">axis_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
                <span class="n">axis_coordinates</span> <span class="o">*=</span> <span class="n">kernel_spacing</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="n">kernel_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis_coordinates</span><span class="p">)</span>
            <span class="n">kernel_offsets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kernel_offsets</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_spacing</span> <span class="o">=</span> <span class="n">kernel_spacing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_spacing</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kernel_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">kernel_offsets</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kernel_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;1-D kernel coordinates do not match kernel &quot;</span>
                                 <span class="s2">&quot;shape.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">irregular</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kernel_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel_offsets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Irregular kernel offsets should be supplied &quot;</span>
                                 <span class="s2">&quot;as an (n_dimensions, kernel.size) array.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kernel_coordinates</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Irregular kernel offsets do not match &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;expected shape &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">kernel</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">). Received &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kernel_coordinates</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">kernel_offsets</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span> <span class="o">=</span> <span class="n">kernel_coordinates</span></div>


<div class="viewcode-block" id="KernelTree.fit_spline">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.kernel_tree.KernelTree.fit_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">spline_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a spline to the tree kernel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees : int or numpy.ndarray (int), optional</span>
<span class="sd">            The degree of spline to fit in each dimension.  Either a scalar can</span>
<span class="sd">            be supplied pertaining to all dimensions, or an array of shape</span>
<span class="sd">            (n_dimensions,) can be used.</span>
<span class="sd">        smoothing : float, optional</span>
<span class="sd">            Used to specify the smoothing factor.  If set to `None`, the</span>
<span class="sd">            smoothing will be determined based on user settings or input data.</span>
<span class="sd">            If `exact` is `True`, smoothing will be disabled (zero).  If</span>
<span class="sd">            `exact` is `False`, smoothing will be set to n - sqrt(2 * n)</span>
<span class="sd">            where n is the number of data values.  For interpolation,</span>
<span class="sd">            smoothing should be set to zero.  Smoothing must be &gt;= 0.</span>
<span class="sd">        spline_kwargs : dict, optional</span>
<span class="sd">            Please see :class:`Spline` for a list of all spline initialization</span>
<span class="sd">            keyword arguments.  Note that `solve` will always be set to `True`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">           If the fit to the kernel was not adequate for further fitting.  If</span>
<span class="sd">           no further tweaking of the input parameters is possible, set</span>
<span class="sd">           `imperfect`=`True` during initialization, or manually set the</span>
<span class="sd">           `imperfect` attribute to `True` manually.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;solve&#39;</span> <span class="ow">in</span> <span class="n">spline_kwargs</span><span class="p">:</span>
            <span class="n">spline_kwargs</span><span class="p">[</span><span class="s1">&#39;solve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spline</span> <span class="o">=</span> <span class="n">Spline</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                             <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">spline_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsuccessful fit: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">exit_message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.tree.kernel_tree</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>