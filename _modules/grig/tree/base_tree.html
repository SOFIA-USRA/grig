<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grig.tree.base_tree &#8212; Grig 1.0.1.dev4+g74c80f7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pyramid.css?v=a5b9c134" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=9559a862"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.tree.base_tree</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for grig.tree.base_tree</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">BallTree</span>
<span class="kn">import</span> <span class="nn">grig.tree</span> <span class="k">as</span> <span class="nn">tree_module</span>
<span class="kn">from</span> <span class="nn">grig.toolkit.func</span> <span class="kn">import</span> <span class="n">byte_size_of_object</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BaseTree&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="BaseTree">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree">[docs]</a>
<span class="k">class</span> <span class="nc">BaseTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">build_type</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                 <span class="n">large_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a tree structure for use with the resampling algorithm.</span>

<span class="sd">        The resampling tree is primarily responsible for deriving and</span>
<span class="sd">        storing all independent variables necessary for polynomial fitting,</span>
<span class="sd">        as well as allowing fast access to those variables that belong to</span>
<span class="sd">        coordinates within a certain radius of a given point.</span>

<span class="sd">        TREE STRUCTURE AND ACCESS</span>

<span class="sd">        The tree itself is divided into N-dimensional blocks, each of which</span>
<span class="sd">        is allocated a set of coordinates.  The width of these blocks should</span>
<span class="sd">        correspond to the `window` (:math:`\Omega`) defined in the resampling</span>
<span class="sd">        algorithm, and coordinates should be scaled accordingly.  For example,</span>
<span class="sd">        if the window radius is set to :math:`\Omega=4` in (arbitrary) units</span>
<span class="sd">        for the purposes of resampling 1-dimensional data, and the independent</span>
<span class="sd">        values are:</span>

<span class="sd">            x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>

<span class="sd">        They should be supplied to the tree as :math:`x^\prime = x / \Omega`.</span>

<span class="sd">        .. math::</span>

<span class="sd">            x^\prime = \frac{x}{\Omega} =</span>
<span class="sd">                [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5]</span>

<span class="sd">        The tree defines blocks by grouping all coordinates with the same</span>
<span class="sd">        floored values into a single block.  Therefore, in this case the tree</span>
<span class="sd">        will contain 3 blocks.  The first contains [0.25, 0.5, 0.75], the</span>
<span class="sd">        second contains [1, 1.25, 1.5, 1.75], and the third contains</span>
<span class="sd">        [2, 2.25, 2.5].</span>

<span class="sd">        The reasoning behind the whole tree structure is to allow for easy</span>
<span class="sd">        extraction of all coordinates within range of a user supplied</span>
<span class="sd">        coordinate.  This is done in two stages:  The first is to find out</span>
<span class="sd">        which block the user supplied coordinate belongs to.  We can then</span>
<span class="sd">        quickly narrow down the search by recognizing that coordinates in the</span>
<span class="sd">        tree population inside the window region of the supplied coordinate</span>
<span class="sd">        must either belong to the same block, or to immediately neighboring</span>
<span class="sd">        blocks since each block of the tree is the same width as the window</span>
<span class="sd">        radius.</span>

<span class="sd">        Once all candidates have been identified, the next step is to keep</span>
<span class="sd">        only those that are within a radius :math:`\Omega` of the user supplied</span>
<span class="sd">        coordinate.  This can be accomplished quickly using the ball-tree</span>
<span class="sd">        algorithm (see :func:`sklearn.neighbors.BallTree`.</span>

<span class="sd">        In practice, the resampling algorithm loops through each block of</span>
<span class="sd">        the tree in parallel.  For each block, all user supplied coordinates</span>
<span class="sd">        (points at which a fit is required) within that block, and all tree</span>
<span class="sd">        members within the neighborhood (the block and all adjacent blocks</span>
<span class="sd">        including diagonals) are evaluated in one step by the ball-tree</span>
<span class="sd">        algorithm so that for each point, we quickly get all tree members</span>
<span class="sd">        within that point&#39;s window region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        argument : numpy.ndarray (n_features, n_samples) or n-tuple</span>
<span class="sd">            Either the independent coordinates of samples in n_features-space,</span>
<span class="sd">            or the shape defining the skeleton of the tree.</span>
<span class="sd">        shape : n-tuple, optional</span>
<span class="sd">            If coordinates were supplied with `argument`, the shape of the</span>
<span class="sd">            tree to build.  Otherwise, the shape will be determined from the</span>
<span class="sd">            coordinate values in each dimension as</span>
<span class="sd">            floor(max(coordinates[i])) + 1 for dimension i.</span>
<span class="sd">        build_type : str, optional</span>
<span class="sd">            Must be one of {&#39;hood&#39;, &#39;balltree&#39;, &#39;all&#39;, None}.  Defines the</span>
<span class="sd">            type of tree structures to create.</span>
<span class="sd">        balltree_metric : str or sklearn.neighbors.DistanceMetric object</span>
<span class="sd">            The distance metric to use for the tree. Default=’minkowski’ with</span>
<span class="sd">            p=2 (that is, a euclidean metric). See the documentation of the</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric` class for a list of</span>
<span class="sd">            available metrics. ball_tree.valid_metrics gives a list of the</span>
<span class="sd">            metrics which are valid for BallTree.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            If `build_type` was set to &#39;all&#39; or &#39;balltree&#39;, defines the leaf</span>
<span class="sd">            size of the BallTree.  Please see</span>
<span class="sd">            :func:`sklearn.neighbors.BallTree` for further details.</span>
<span class="sd">        large_data : bool, optional</span>
<span class="sd">            If `True`, indicates that this resampling algorithm will run on</span>
<span class="sd">            a large set of data, and the tree should be created on subsets</span>
<span class="sd">            of the data only when necessary.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_blocks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ball_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_offsets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_population</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hood_population</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">large_data</span> <span class="o">=</span> <span class="n">large_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_block</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_members</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span> <span class="o">=</span> <span class="n">leaf_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_kwargs</span> <span class="o">=</span> <span class="n">distance_kwargs</span>

        <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_tree</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">build_type</span><span class="p">,</span>
                            <span class="n">leaf_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the shape of the coordinate bins of the tree.</span>

<span class="sd">        The coordinate bins divide coordinates into bins where all values</span>
<span class="sd">        between 2 &lt;= x_i &lt; 3 for coordinate x in dimension i are in bin 0.</span>
<span class="sd">        Note that coordinates should have been scaled accordingly such that</span>
<span class="sd">        they range between 0 -&gt; n, where n are the maximum number of bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shape : tuple (int)</span>
<span class="sd">            The number of bins in each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of features (dimensions) in the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of blocks in the tree.</span>

<span class="sd">        The total number of blocks is simply the number of available coordinate</span>
<span class="sd">        bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_blocks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a search array used to identify neighbouring blocks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        search_array : numpy.ndarray (int)</span>
<span class="sd">            An (n_features, n_permutations) containing values {-1, 0, 1} where</span>
<span class="sd">            each permutation gives a block offset in relation to a central</span>
<span class="sd">            block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">balltree_initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `True` if the BallTree has been initialized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ball_initialized</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hood_initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `True` if the neighbourhood tree has been initialized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_members</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of coordinates stored in the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="BaseTree.estimate_ball_tree_bytes">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.estimate_ball_tree_bytes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_ball_tree_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the maximum number of bytes used to construct the ball-tree.</span>

<span class="sd">        According to sklearn documentation, the memory needed to store the</span>
<span class="sd">        tree scales as::</span>

<span class="sd">             2 ** (1 + floor(log2((n-1) / leaf_size))) - 1</span>

<span class="sd">        However, empirically the data also scale as (ndim+1) * leaf_size.</span>

<span class="sd">        The estimated number of elements is given as::</span>

<span class="sd">            (ndim+1) * leaf_size * (2 ** (1+floor(log2((n-1) / leaf_size)))-1)</span>

<span class="sd">        This is then scaled by the number of bytes in a float (typically 8).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates of shape (n_dimensions, n)</span>
<span class="sd">        leaf_size : int</span>
<span class="sd">            The number of leaves used to construct the ball-tree</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_size : int</span>
<span class="sd">            The maximum number of bytes used to construct the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">leaf_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leaf_size</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">float_bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">n_dimensions</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">leaf_size</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">correcting_factor</span> <span class="o">=</span> <span class="n">leaf_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_dimensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">n_elements</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">correcting_factor</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">*</span> <span class="n">float_bytes</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.estimate_split_tree_bytes">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.estimate_split_tree_bytes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_split_tree_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size of a ball tree for a single neighborhood.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates of shape (n_dimensions, n)</span>
<span class="sd">        window : int or float or numpy.ndarray, optional</span>
<span class="sd">            The window binning size.  If a numpy array is supplied, it should</span>
<span class="sd">            be of shape (n_dimensions,).</span>
<span class="sd">        leaf_size : int</span>
<span class="sd">            The number of leaves used to construct the ball-tree</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_size : int</span>
<span class="sd">            The maximum number of bytes used to construct the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">leaf_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leaf_size</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">estimate_n_bins</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
        <span class="n">samples_per_bin</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">n_bins</span>
        <span class="n">bins_per_hood</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">**</span> <span class="n">n_dimensions</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">bins_per_hood</span> <span class="o">*</span> <span class="n">samples_per_bin</span>  <span class="c1"># samples in each hood tree</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">leaf_size</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">correcting_factor</span> <span class="o">=</span> <span class="n">leaf_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_dimensions</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">float_bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">n_elements</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">correcting_factor</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">*</span> <span class="n">float_bytes</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.estimate_n_bins">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.estimate_n_bins">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_n_bins</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the number of bins in the hood tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates of shape (n_dimensions, n).</span>
<span class="sd">        window : int or float or numpy.ndarray, optional</span>
<span class="sd">            The window binning size.  If a numpy array is supplied, it should</span>
<span class="sd">            be of shape (n_dimensions,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bytes : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">):</span>
            <span class="n">span</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">span</span> <span class="o">/=</span> <span class="n">window</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">span</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bins</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_bins</span></div>


<div class="viewcode-block" id="BaseTree.estimate_hood_tree_bytes">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.estimate_hood_tree_bytes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_hood_tree_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the maximum byte size for the neighborhood tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates of shape (n_dimensions, n).</span>
<span class="sd">        window : int or float or numpy.ndarray, optional</span>
<span class="sd">            The window binning size.  If a numpy array is supplied, it should</span>
<span class="sd">            be of shape (n_dimensions,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bytes : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">n_dimensions</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">estimate_n_bins</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">n_dimensions</span>

        <span class="n">test_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">item_byte_size</span> <span class="o">=</span> <span class="n">test_array</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">empty_byte_size</span> <span class="o">=</span> <span class="n">byte_size_of_object</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span>
        <span class="n">average_samples</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">n_bins</span>
        <span class="n">array_byte_size</span> <span class="o">=</span> <span class="n">empty_byte_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">item_byte_size</span> <span class="o">*</span> <span class="n">average_samples</span><span class="p">)</span>
        <span class="c1"># Add all sub arrays and the container array</span>
        <span class="n">hood_tree_byte_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">array_byte_size</span> <span class="o">*</span> <span class="n">n_bins</span><span class="p">)</span> <span class="o">+</span> <span class="n">empty_byte_size</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hood_tree_byte_size</span><span class="p">))</span></div>


<div class="viewcode-block" id="BaseTree.estimate_max_bytes">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.estimate_max_bytes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">estimate_max_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                           <span class="n">full_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the maximum number of bytes required by the tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            The coordinates for the tree of shape (n_dimensions, n)</span>
<span class="sd">        window : int or float, optional</span>
<span class="sd">            The size of the tree windows</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            The number of leaves used to construct the ball-tree</span>
<span class="sd">        full_tree : bool, optional</span>
<span class="sd">            Calculate the maximum number of bytes if the full ball-tree is</span>
<span class="sd">            pre-calculated.  Otherwise, calculates the size of a single</span>
<span class="sd">            neighborhood sized ball-tree.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments to pass that may be used by subclasses</span>
<span class="sd">            of the BaseTree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_size : int</span>
<span class="sd">            The maximum number of bytes used to construct the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">float_bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>

        <span class="c1"># 1 for coordinates, 1 for coordinate offsets.</span>
        <span class="n">coordinate_bytes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">float_bytes</span>
        <span class="k">if</span> <span class="n">full_tree</span><span class="p">:</span>
            <span class="n">ball_tree_bytes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">estimate_ball_tree_bytes</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ball_tree_bytes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">estimate_split_tree_bytes</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">)</span>

        <span class="n">hood_tree_bytes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">estimate_hood_tree_bytes</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">ball_tree_bytes</span> <span class="o">+</span> <span class="n">hood_tree_bytes</span> <span class="o">+</span> <span class="n">coordinate_bytes</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.get_class_for">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.get_class_for">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_class_for</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Tree class specific to a given grid, resampler, or name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thing : BaseGrid or ResampleBase or str</span>
<span class="sd">            Either a sub-class of a BaseGrid, ResampleBase, or a string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseTree subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">thing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
                <span class="n">class_name</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">class_name</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="s1">&#39;Grid&#39;</span> <span class="ow">in</span> <span class="n">class_name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">class_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;Grid&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s1">&#39;Resample&#39;</span> <span class="ow">in</span> <span class="n">class_name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">class_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;Resample&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">BaseTree</span><span class="o">.</span><span class="n">get_class_for_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.get_class_for_name">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.get_class_for_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_class_for_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Tree class of the given name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseTree subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_path</span> <span class="o">=</span> <span class="n">tree_module</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;base&#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">else</span> <span class="n">name</span>
        <span class="n">module_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree_path</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">_tree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;Tree&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">module_path</span><span class="p">)</span>  <span class="c1"># Allow errors</span>
            <span class="n">tree_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">return</span> <span class="n">BaseTree</span>
            <span class="k">return</span> <span class="n">tree_class</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BaseTree</span></div>


    <span class="k">def</span> <span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the shape of the tree.</span>

<span class="sd">        The shape of the tree determines the number of n-dimensional coordinate</span>
<span class="sd">        bins.  Once defined, a number of useful factors are pre-calculated to</span>
<span class="sd">        allow for easy determination of neighboring bins to any given bin.</span>

<span class="sd">        The search kernel is every permutation of [-1, 0, 1] over all features,</span>
<span class="sd">        meaning each bin not on the edge of the tree bounds has :math:`3^n - 1`</span>
<span class="sd">        neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : n-tuple of int</span>
<span class="sd">            The size for each of the n features of the tree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

        <span class="n">searches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_search</span> <span class="o">=</span> <span class="n">searches</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># self._multipliers = abs(searches)</span>
        <span class="c1"># self._deltas = -1 * (searches &lt; 0)</span>
        <span class="c1"># reverse_search = searches * -1</span>
        <span class="c1"># self._reverse_deltas = -1 * (reverse_search &lt; 0)</span>

        <span class="c1"># Reset necessary attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_offsets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_population</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hood_population</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BaseTree.to_index">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.to_index">[docs]</a>
    <span class="k">def</span> <span class="nf">to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the tree block indices of a coordinate or set of coordinates.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A tree of shape (5, 6) in 2 dimensions contains coordinates ranging</span>
<span class="sd">        from 0-5 in x, and 0-6 in y.  The coordinate (x, y) = (2.7, 3.1) would</span>
<span class="sd">        exist in tree block [2, 3] (floored values), but the tree block</span>
<span class="sd">        structure is one-dimensional.  The actual block index would be</span>
<span class="sd">        15 since it is calculated as (2 * 6) + 3, or (x * shape[1]) + y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (n_feature,) or (n_feature, n_coordinates)</span>
<span class="sd">            The coordinates for which to return tree block indices.</span>
<span class="sd">            Coordinates should be scaled such that they range from</span>
<span class="sd">            0 -&gt; tree.shape[k] for the feature k.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index or indices : np.int64 or np.ndarray (n_coordinates,)</span>
<span class="sd">            The tree block indices for the supplied coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">single</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">single</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">single</span> <span class="k">else</span> <span class="n">index</span></div>


<div class="viewcode-block" id="BaseTree.from_index">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.from_index">[docs]</a>
    <span class="k">def</span> <span class="nf">from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the lower corner coordinate for a tree block index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The lower corner coordinate in a tree block is given as the floored</span>
<span class="sd">        values of all coordinates that exist inside the block.  For example,</span>
<span class="sd">        the index 15 in a tree of shape (5, 6) corresponds to coordinates in</span>
<span class="sd">        the range x = (2-&gt;3), y = (3-&gt;4).  Therefore, the lower coordinate is</span>
<span class="sd">        (2, 3).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or numpy.ndarray (n_indices,)</span>
<span class="sd">            The indices for which to return the lower corner coordinate(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lower_corner_coordinates : numpy.ndarray of int</span>
<span class="sd">           An array of shape (n_features,) or (n_features, n_indices)</span>
<span class="sd">           containing the lower corner coordinates of supplied tree block</span>
<span class="sd">           indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">single</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">==</span> <span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">coordinates</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">single</span> <span class="k">else</span> <span class="n">coordinates</span></div>


<div class="viewcode-block" id="BaseTree.build_tree">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.build_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                   <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the ball and hood tree structures from coordinates.</span>

<span class="sd">        Populates the tree with coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray (n_features, n_coordinates)</span>
<span class="sd">            The coordinates from which to build the trees.</span>
<span class="sd">        shape : n-tuple of int, optional</span>
<span class="sd">            The shape of the tree.  If not supplied it is calculated as</span>
<span class="sd">            floor(max(coordinate[k])) + 1 for the feature k.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Specifies the trees to build.  Available options are {&#39;hood&#39;,</span>
<span class="sd">            &#39;balltree&#39;, &#39;all&#39;, None}.  The default (&#39;all&#39;) builds both</span>
<span class="sd">            the balltree and hood tree.</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            An specifies the point at which the ball tree switches over to</span>
<span class="sd">            the brute force method.  See :func:`sklearn.neighbors.BallTree`</span>
<span class="sd">            for further information.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hood&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_hood_tree</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;balltree&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_ball_tree</span><span class="p">(</span><span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_hood_tree</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_ball_tree</span><span class="p">(</span><span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown tree building method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.build_ball_tree_for_block">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.build_ball_tree_for_block">[docs]</a>
    <span class="k">def</span> <span class="nf">build_ball_tree_for_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a ball tree for a neighborhood around a single block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        block : int</span>
<span class="sd">            The center block of the neighborhood.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hood_initialized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_hood_tree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_members</span><span class="p">,</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hood_members</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_block</span><span class="p">,</span> <span class="n">get_locations</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_build_ball_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the balltree structure.</span>

<span class="sd">        The balltree is created using :func:`sklearn.neighbors.BallTree` and</span>
<span class="sd">        allows rapid calculation of relative distances from a supplied set</span>
<span class="sd">        of coordinates to those within the tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leaf_size : int, optional</span>
<span class="sd">            An specifies the point at which the ball tree switches over to</span>
<span class="sd">            the brute force method.  See :func:`sklearn.neighbors.BallTree`</span>
<span class="sd">            for further information.</span>
<span class="sd">        distance_kwargs : dict, optional</span>
<span class="sd">            Optional keyword arguments passed into</span>
<span class="sd">            :func:`sklearn.neighbors.DistanceMetric`.  The default is to use</span>
<span class="sd">            the &quot;minkowski&quot; definition with `p=2`, i.e., the Euclidean</span>
<span class="sd">            definition.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ball_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_block</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">large_data</span><span class="p">:</span>
            <span class="c1"># Do not attempt to build a full ball tree for large data</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">leaf_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                      <span class="n">leaf_size</span><span class="o">=</span><span class="n">leaf_size</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">distance_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ball_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_build_hood_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the hood tree structure.</span>

<span class="sd">        The hood tree defines a number of attributes allowing for fast access</span>
<span class="sd">        to all coordinates within a tree block, or the coordinates within</span>
<span class="sd">        a tree block and all neighboring blocks.  A single block and all its</span>
<span class="sd">        neighboring blocks are referred to as the &quot;neighborhood&quot; or &quot;hood&quot; of</span>
<span class="sd">        the block.  In addition, the population of each block and hood are also</span>
<span class="sd">        stored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="p">[</span><span class="n">bins</span><span class="p">,</span> <span class="n">indices</span><span class="p">]),</span>
                                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">bins</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">block_offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_population</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hood_population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_population</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_in_hood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_population</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_blocks</span><span class="p">):</span>
            <span class="n">hoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighborhood</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">cull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hoods</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hood_population</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_in_hood</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hood_population</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_population</span><span class="p">[</span><span class="n">hoods</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_in_hood</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_population</span><span class="p">[</span><span class="n">hoods</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BaseTree.query_radius">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.query_radius">[docs]</a>
    <span class="k">def</span> <span class="nf">query_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all tree members within a certain distance of given points.</span>

<span class="sd">        Quickly retrieves all members of the tree population within the radius</span>
<span class="sd">        of some defined coordinate(s).  The default distance definition is</span>
<span class="sd">        &quot;minkowski&quot; with p=2, which is equivalent to the &quot;euclidean&quot;</span>
<span class="sd">        definition. For a list of available distance metric please see</span>
<span class="sd">        `sklearn.neighbors.BallTree.valid_metrics`.  The distance metric may</span>
<span class="sd">        be defined during PolynomialTree initialization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            An (n_features, n_coordinates) or (n_features,) array containing</span>
<span class="sd">            coordinates around which to determine tree members within a</span>
<span class="sd">            certain radius.</span>
<span class="sd">        radius : float, optional</span>
<span class="sd">            The search radius around each coordinate.</span>
<span class="sd">        block : int, optional</span>
<span class="sd">            Used to create a temporary ball tree for the given block when</span>
<span class="sd">            operating on large data.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Keywords for :func:`sklearn.neighbors.BallTree.query_radius`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indices : numpy.ndarray of object (n_coordinates,)</span>
<span class="sd">            Each element is a numpy integer array containing the indices of</span>
<span class="sd">            tree members within `radius`.  This return value may change</span>
<span class="sd">            depending on the options in `kwargs`.  Please see</span>
<span class="sd">            :func:`sklearn.neighbors.BallTree.query_radius` for further</span>
<span class="sd">            information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">large_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No block number for large data query has &quot;</span>
                                 <span class="s2">&quot;been supplied.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_ball_tree_for_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span><span class="o">.</span><span class="n">query_radius</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_distance&#39;</span><span class="p">):</span>
                <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">distances</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ball_tree_members</span><span class="p">[</span><span class="n">point_indices</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">return_distance</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">distances</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">indices</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">balltree_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Ball tree not initialized&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_balltree</span><span class="o">.</span><span class="n">query_radius</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseTree.block_members">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.block_members">[docs]</a>
    <span class="k">def</span> <span class="nf">block_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">get_locations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get block members from the neighborhood tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        block : np.ndarray of int</span>
<span class="sd">            Block locations.</span>
<span class="sd">        get_locations : bool, optional</span>
<span class="sd">            If set, locations of members are also returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        members : np.ndarray</span>
<span class="sd">            Members of the block.</span>
<span class="sd">        locations : np.ndarray, optional</span>
<span class="sd">            Locations of the members.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Neighborhood tree not initialized.&quot;</span><span class="p">)</span>
        <span class="n">members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree</span><span class="p">[</span><span class="n">block</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">get_locations</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">members</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">members</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="n">members</span><span class="p">]</span></div>


<div class="viewcode-block" id="BaseTree.neighborhood">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.neighborhood">[docs]</a>
    <span class="k">def</span> <span class="nf">neighborhood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cull</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">valid_neighbors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a neighborhood from an input index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The center index for the neighborhood.</span>
<span class="sd">        cull : bool, optional</span>
<span class="sd">            If set, bad indices are dropped.</span>
<span class="sd">        valid_neighbors : bool, optional</span>
<span class="sd">            If set, returns good locations as well as the neighborhood..</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hood : np.ndarray of int</span>
<span class="sd">            The tree block indices for the neighborhood.</span>
<span class="sd">        keep : np.ndarray of bool, optional</span>
<span class="sd">            Good indices in the neighborhood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_index</span><span class="p">(</span><span class="n">index</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="p">(</span><span class="n">expanded</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">expanded</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_index</span><span class="p">(</span><span class="n">expanded</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad</span>
        <span class="k">if</span> <span class="n">cull</span><span class="p">:</span>
            <span class="n">hood</span> <span class="o">=</span> <span class="n">hood</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hood</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">hood</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span> <span class="k">if</span> <span class="n">valid_neighbors</span> <span class="k">else</span> <span class="n">hood</span></div>


<div class="viewcode-block" id="BaseTree.hood_members">
<a class="viewcode-back" href="../../../source/grig.tree.html#grig.tree.base_tree.BaseTree.hood_members">[docs]</a>
    <span class="k">def</span> <span class="nf">hood_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_block</span><span class="p">,</span> <span class="n">get_locations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all members within the neighborhood of a single block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center_block : int</span>
<span class="sd">            The index of the block at the center of the neighborhood.</span>
<span class="sd">        get_locations : bool, optional</span>
<span class="sd">            If `True`, return the coordinates of the hood members.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        members, [coordinates]</span>
<span class="sd">            members is a numpy.ndarray of int and shape (found_members,).</span>
<span class="sd">            If `get_locations` was set to `True,` coordinates is of shape</span>
<span class="sd">            (n_features, found_members).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hood_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Neighborhood tree not initialized.&quot;</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighborhood</span><span class="p">(</span><span class="n">center_block</span><span class="p">,</span> <span class="n">cull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hood_members</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_population</span><span class="p">[</span><span class="n">blocks</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">block_members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_members</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">hood_members</span><span class="p">[</span><span class="n">found</span><span class="p">:</span> <span class="n">found</span> <span class="o">+</span> <span class="n">block_members</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_members</span>
            <span class="n">found</span> <span class="o">+=</span> <span class="n">block_members</span><span class="o">.</span><span class="n">size</span>

        <span class="n">hood_members</span> <span class="o">=</span> <span class="n">hood_members</span><span class="p">[:</span><span class="n">found</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">get_locations</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hood_members</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hood_members</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="n">hood_members</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the block index of a coordinate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : int or numpy.ndarray (features,) or (features, n_coordinates)</span>
<span class="sd">            The block for which to find the lower coordinate.  If `reverse` is</span>
<span class="sd">            `False`, returns the block index for a given coordinate.</span>
<span class="sd">        reverse : bool, optional</span>
<span class="sd">            Specifies if the return value should be the lower coordinate or</span>
<span class="sd">            block index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        block_index or coordinate : int or numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Grig 1.0.1.dev4+g74c80f7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">grig.tree.base_tree</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, SOFIA-USRA.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>